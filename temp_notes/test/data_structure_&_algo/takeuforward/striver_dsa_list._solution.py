
# region INSTRUCTIONS
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ -> EASY 
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ -> MEDIUM
ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´ -> HARD
â­â­â­ -> QUESTION PATTERN 
ğŸ‘‰ğŸ‘‰ğŸ‘‰ -> ADDITIONAL QUESTION
ğŸ˜ğŸ˜ğŸ˜ -> ALGORITHM
ğŸ”— -> LINK 
ğŸ“½ï¸ ->

pending - explained sudo code /steps 

'''

# endregion 





# region 1.2 PATTERN PROBLEMS 
# ---------------------------
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/strivers-a2z-dsa-course/must-do-pattern-problems-before-starting-dsa/

https://www.youtube.com/watch?v=tNm_NNSB3_w&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=5


- for outer loop, count the number of lines/rows
- for inner loop, count the number of elements in each line or focus on the columns and connect them somehow to the rows
- print them inside the inner loop
- observe symmetry

'''

# PATTERN 1
'''
*****
*****
*****
*****
*****
'''
rows = 5
for i in range(rows):
    for j in range(rows):
        print("*", end="")
    print("\n")

# PATTERN 2
'''
*
**
***
****
*****
'''
rows = 5
for i in range(rows):
    # change
    for j in range(i+1):
        print("*", end="")
    print("\n")

# PATTERN 3
'''
1
12
123
1234
12345
'''
rows = 5
for i in range(1,rows+1):
    # change
    for j in range(1,i+1):
        print(j, end="")
    print("\n")

# PATTERN 4
'''
1
22
333
4444
55555
'''
for i in range(1,rows+1):
    for j in range(1,i+1):
        # change
        print(i, end="")
    print("\n")

# PATTERN 5
'''
â­â­â­
*****
****
***
**
*
'''
for i in range(rows):
    # change
    for j in range(rows-i):
        print("*", end="")
    print("\n")

# PATTERN 6
'''
12345
1234
123
12
1
'''
for i in range(1,rows+1):
    # change
    for j in range(1,rows+1-i+1):
        print(j, end="")
    print("\n")

# PATTERN 7
'''
â­â­â­
    *    

   ***   

  *****  

 ******* 

*********
'''
for i in range(1,rows):
    for j in range(1,rows-i):
      print("_", end="")
    
    # important
    for j in range(2*i-1):
      print("*", end="")
        
    for j in range(1,rows-i):
      print("_", end="")
    print("\n")

# PATTERN 8
'''
â­â­â­
*********
 ******* 
  ***** 
   ***   
    *    
'''
for i in range(1,rows):
    for j in range(1,i):
      print(" ", end="")
        
    # important
    for j in range(2*rows-2*i-1):
      print("*", end="")
        
    for j in range(1,i):
      print(" ", end="")
    print("\n")


# PATTERN 9
'''
    *    
   ***   
  *****  
 ******* 
*********
*********
 ******* 
  ***** 
   ***   
    *  
'''
for i in range(1,rows):
    for j in range(1,rows-i):
      print(" ", end="")
        
    for j in range(2*i-1):
      print("*", end="")
        
    for j in range(1,rows-i):
      print(" ", end="")
    print("\n")
    
for i in range(1,rows):
    for j in range(1,i):
      print(" ", end="")
        
    for j in range(2*rows-2*i-1):
      print("*", end="")
        
    for j in range(1,i):
      print(" ", end="")
    print("\n")


# PATTERN 10
'''
â­â­â­
*
**
***
****
*****
****
***
**
*
'''
for i in range(1,2*rows):
    # important
    row_number = i
    if i>rows:
      row_number = 2*rows-i
    for j in range(row_number):
      print("*", end="")
    print("\n")
    
# PATTERN 11
'''
â­â­â­
1
01
101
0101
10101
'''
for i in range(1,rows+1):
    # important
    start = 0
    if i%2: start = 1
    for j in range(i):
      print(start, end="")
      # important
      start = 1 - start             # 1-0 = 1 and 1-1 = 0, flipping the number
    print("\n")
    
# PATTERN 12
'''
1      1
12    21
123  321
12344321
'''
for i in range(1,rows+1):
    for j in range(1,i+1):
      print(j, end="")
      
    # important
    for j in range(2*rows-2*i):
      print("_", end="")
      
    for j in range(i,0,-1):             # 4,3,2,1, reversing the count
      print(j, end="")
      
    print("\n")

# PATTERN 13
'''
â­â­â­
1 
2 3
4 5 6
7 8 9 10
11 12 13 14 15
'''
# important
num = 1
for i in range(1, rows+1):
    for j in range(i):
      print(num, end=" ")
      num = num + 1
    print("\n")
    
# PATTERN 14
'''
â­â­â­
A
AB
ABC
ABCD
ABCDE
'''
for i in range(rows+1):
    for j in range(i):
      # important
      print(chr(65+j), end="")
    print("\n")
    
    
# PATTERN 15
'''
ABCDE
ABCD
ABC
AB
A
'''
for i in range(rows+1):
    # important
    for j in range(rows-i):
      print(chr(65+j), end="")
    print("\n")
    
# PATTERN 16
'''
A
BB
CCC
DDDD
EEEEE
'''
for i in range(rows):
    # important
    for j in range(i+1):
      print(chr(65+i), end="")
    print("\n")

# PATTERN 17
'''
â­â­â­
ğŸ˜ğŸ˜ğŸ˜
   A
  ABA
 ABCBA
ABCDCBA
'''
for i in range(1,num + 1):
  for j in range(num-i):
    print("_", end="")
  # important
  for k in range(i):
    print(chr(65 + k), end="")
  # important
  for k in range(i-1,0,-1):
    print(chr(64+k), end="")
  for j in range(num-i):
    print("_", end="")
  print("\n")
    
# PATTERN 18
'''
E
DE
CDE
BCDE
ABCDE
'''
for i in range(1,num+1):
  for j in range(i):
    # important
    print(chr(65+ (num - j -1)), end="")
  print("\n")

# PATTERN 19
'''
**********
****  ****
***    ***
**      **
*        *
*        *
**      **
***    ***
****  ****
**********
'''
for i in range(num):
  for j in range(num-i):
    print("*", end="")
  # important
  for j in range(2*i):
    print("_", end="")
  for j in range(num-i):
    print("*", end="")
  print("\n")
  
for i in range(num):
  for j in range(i+1):
    print("*", end="")
  # important
  for j in range(2*(num - i-1)):
    print("_", end="")
  for j in range(i+1):
    print("*", end="")
  print("\n")

# PATTERN 20
'''
â­â­â­
*        *
**      **
***    ***
****  ****
**********
****  ****
***    ***
**      **
*        *
'''
# important
for i in range(1, 2*num):
  # Lower Part
  if i> ((2*num-1)//2):
    for j in range(2*num-i):
      print("*", end="")
    for j in range(2*(i-num)):
      print("_", end="")
    for j in range(2*num-i):
      print("*", end="")
    print("\n")
  else:
    # Upper Part
    for j in range(i):
      print("*", end="")
    for j in range(2*(num - i)):
      print("_", end="")
    for j in range(i):
      print("*", end="")
    print("\n")

# PATTERN 21
'''
â­â­â­
****
*  *
*  *
****
'''
for i in range(num):
    for j in range(num):
        # important
        if i == 0 or i == num-1 or j == 0 or j == num-1:
            print("*", end="")
        else:
            print(" ", end="")
    print()

# PATTERN 22
'''
â­â­â­
4444444
4333334
4322234
4321234
4322234
4333334
4444444
'''
# important
n=5
for i in range(2*n-1):
  for j in range(2*n-1):
    top = i 
    bottom = (2*n-2) -i  # (2n-1)-1-i
    left = j
    right = (2*n-2) -j  # (2n-1)-1-j
    print(n - min(min(top, bottom), min(left, right)), end="")
  print("\n")


# endregion





# region 1.3 C++ and Java STL 
# ---------------------------
'''
- medium
- https://www.youtube.com/watch?v=RRVYpIET_RU
- https://takeuforward.org/c/c-stl-tutorial-most-frequent-used-stl-containers/
'''


# endregion 





# region 1.4 MATHS PROBLEM 
# ------------------------

# TODO : 1 Count digits in a number
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢
â­â­â­ Using //and %

https://takeuforward.org/data-structure/count-digits-in-a-number/

https://practice.geeksforgeeks.org/problems/count-digits5716/1

https://www.youtube.com/watch?v=1xNbjMdbjug&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=7

- 
to reduce the number, divide - 123 // 10 = 12
to get the last number, modulo - 123 % 10 = 3
ğŸ˜ğŸ˜ğŸ˜ count = int(math.log10(num)) + 1

number / 10 -> TC is O(log10(number))
number / 2 -> TC is O(log2(number))
number / 5 -> TC is O(log5(number))
'''
# Method 1 - brute force
'''
TC- O(log10(N)) 
SC - O(1)
'''
def count(num):
  count = 0
  while(num > 0):
    count = count + 1  
    num = num//10
  return count

num = 5216566
print(count(num))

# Method 2 - optimal approch
'''
TC - O(1)
SC - O(1)
'''
import math
num = 5216566
print(int(math.log10(num)) + 1)

# 

# TODO : 2 Reverse a number
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/maths/reverse-digits-of-a-number

https://leetcode.com/problems/reverse-integer/

https://www.youtube.com/watch?v=1xNbjMdbjug&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=7

ğŸ˜ğŸ˜ğŸ˜ newNumber = newNumber * 10 + lastDigit

'''
# Method 1 - optimal approch
'''
Time Complexity: O(log10(n))

Space Complexity: O(1)
'''
def reverse(nnum):
  reverse_num = 0
  while(num > 0):
    rem = num % 10
    reverse_num = reverse_num * 10 + rem
    num = num//10
  return reverse_num

num = 23521
print(reverse(num))

# TODO : 3 Check pallindrome
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/data-structure/check-if-a-number-is-palindrome-or-not/

https://leetcode.com/problems/palindrome-number/

https://www.youtube.com/watch?v=1xNbjMdbjug&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=7

121 - orignal and reverse of orignal are same
'''
# Method 1 - optimal solution
'''
Time Complexity: O(log10(n))

Space Complexity: O(1)
'''
def pallindrome(num):
  original_num = num
  reverse_num = 0
  while(num > 0):
    rem  = num % 10
    reverse_num = reverse_num * 10 + rem
    num = num//10
  if original_num is reverse_num:
    return True
  else:
    return False
num = 121
print(pallindrome(num))

# 


# 4 Armstrong Numbers 
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/maths/check-if-a-number-is-armstrong-number-or-not/

https://leetcode.com/problems/armstrong-number/

https://www.youtube.com/watch?v=1xNbjMdbjug&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=7

3^3 + 7^3 + 1^3 = 371
'''
# Method 1 - optimal approch
'''
TC - O(log10(N))
SC - O(1)
'''
def armstrong(num):
  original_num = num
  calculated_num = 0
  while(num > 0):
    temp_num = num % 10
    calculated_num = calculated_num + temp_num * temp_num * temp_num
    num = num//10
  if original_num == calculated_num:
    print(f"{original_num} is armstrong number.")
  else:
    print(f"{original_num} is not armstrong number.")
num = 371
print(armstrong(num))

# 5 Print all divisors
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢
â­â­â­

https://takeuforward.org/data-structure/print-all-divisors-of-a-given-number/

https://practice.geeksforgeeks.org/problems/sum-of-all-divisors-from-1-to-n4738/1

https://www.youtube.com/watch?v=1xNbjMdbjug&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=7


'''
# Method 1 - brute force, check number % i === 0
'''
Time Complexity: O(num)

Space Complexity: O(num)
'''
def divisors(num):
  divisors_lst = []
  for i in range(1,num):
    if num%i == 0:
      divisors_lst.append(i)
num = 15
print(divisors(num))


# Method 2 - optimized approch, using math.sqrt()
'''
Time Complexity: O(âˆšnum)

Space Complexity: O(âˆšnum)

for example, num = 12
range(1,int(math.sqrt(num))+1) -> range(1, 4) -> 1,2,3
i * other_number will be appended the result but other number should not be already present in the result !

'''
import math
def divisors(num):
  divisors_lst = []
  for i in range(1,int(math.sqrt(num))+1):
    if(num%i == 0):
      divisors_lst.append(i)
      if(num//i != i):
        divisors_lst.append(num//i)
  return divisors_lst

num = 15
print(divisors(num))

# 6 Check for prime (having exactly two factors, 1 and itself)

'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢
â­â­â­

https://takeuforward.org/data-structure/check-if-a-number-is-prime-or-not/

https://practice.geeksforgeeks.org/problems/minimum-number-of-jumps-1587115620/1

https://www.youtube.com/watch?v=1xNbjMdbjug&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=7


'''
# Method 1 - brute force
'''
Time Complexity: O((n))

Space Complexity: O(1)
'''
def checkPrime(num):
  divisors_lst = []
  for i in range(1,num+1):
    if(num%i == 0):
      divisors_lst.append(i)
  print(divisors_lst)
  if len(divisors_lst) == 2:
    return True
  else:
    return False
num = 15
print(checkPrime(num))

# Method 2 - optimal approch
'''
Time Complexity: O(âˆšnum)

Space Complexity: O(1)

number of divisors must be 2 only !
'''
def checkPrime(num):
  divisors_lst = []
  for i in range(1,int(math.sqrt(num))+1):
    if(num%i == 0):
      divisors_lst.append(i)
      if num//i != i:
        divisors_lst.append(num//i)
  print(divisors_lst)
  if len(divisors_lst) == 2:
    return True
  else:
    return False
num = 15
print(checkPrime(num))

# 7 GCD or HCF (Greatest Common Divisor / Highest Common Factor)

'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢
â­â­â­

https://takeuforward.org/data-structure/find-gcd-of-two-numbers/

https://practice.geeksforgeeks.org/problems/lcm-and-gcd4516/1

https://www.youtube.com/watch?v=1xNbjMdbjug&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=7
'''
# Method 1 - brute force, using maths
'''
Time Complexity: O(min(num_1, num_2))

Space Complexity: O(1)
'''
def find_hcf(num_1, num_2):
  hcf = 1
  for i in range(1, min(num_1, num_2)):
    if num_1%i == 0 and num_2%i == 0:
      hcf = i
  return hcf
num_1 = 18
num_2 = 12
print(find_hcf(num_1,num_2))

# Method 2 : optimal approch, Euclidian algo
'''
Time Complexity : O(logÏ•(min(a, b))), where Ï• may be any number.

Space Complexity : O(1)

ğŸ˜ğŸ˜ğŸ˜
Euclidian algo,
GCD(a, b) = GCD(a-b, b) if a > b
=>  GCD(a, b) = GCD(a % b, b) if a > b
'''
def find_gcd(a, b):
    while a > 0 and b > 0:
        if a > b:
            a = a % b
        else:
            b = b % a
    if a==0:
        return b
    else:
        return a
print(find_gcd(8, 12))


# endregion





# region 1.5 RECURSION PROBLEM
# ----------------------------
# 1 Introduction
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/recursion/introduction-to-recursion-understand-recursion-by-printing-something-n-times/

https://bit.ly/3K2epHv

https://www.youtube.com/watch?v=6IIgSFBPQ0U (Recommended, Love Babbar)
https://www.youtube.com/watch?v=yVdKa8dnKiE&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=8

''' 

# 2 print name N times using recursion 
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/recursion/print-name-n-times-using-recursion/

https://bit.ly/3y2BiWz

Time Complexity (TC): O(N)

Space Complexity (SC): O(N)

'''
def recursive_call_1(N):
  if N == 0:
    return 
  print("Himanshu")
  recursive_call_1(N-1)
recursive_call_1(5)


# 3 print 1 to N using recursion
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/recursion/print-1-to-n-using-recursion/

https://practice.geeksforgeeks.org/problems/print-1-to-n-without-using-loops-1587115620/1

Time Complexity (TC): O(N)

Space Complexity (SC): O(N)
'''
def recursive_call_2(N):
  if N == 0:
    return 
  recursive_call_2(N-1)
  print("head recursion => ", N)                # ---> head recursion => 1 2 3 4 5
recursive_call_2(5)

# 4 print N to 1 using recursion
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/recursion/print-n-to-1-using-recursion/

https://bit.ly/3LOkcBn

Time Complexity (TC): O(N)

Space Complexity (SC): O(N)

'''
def recursive_call_3(N):
  if N == 0:
    return 
  print("tail recursion => ", N)                # ---> tail recursion => 5 4 3 2 1
  recursive_call_3(N-1)
recursive_call_3(5)

# 5 sum of first N numbers
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/data-structure/sum-of-first-n-natural-numbers/

https://practice.geeksforgeeks.org/problems/sum-of-first-n-terms5843/1

Time Complexity (TC): O(N) (due to the N recursive calls)

Space Complexity (SC): O(N) (due to the call stack)

'''
def sum(N):
  if N == 1:
    return 1
  return N + sum(N-1)
print(sum(3))

# 6 factorial of a numbers
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/data-structure/factorial-of-a-number-iterative-and-recursive/

https://practice.geeksforgeeks.org/problems/find-all-factorial-numbers-less-than-or-equal-to-n3548/0?problemType=functional&difficulty%5B%5D=-1&page=1&query=problemTypefunctionaldifficulty%5B%5D-1page1

Time Complexity (TC): O(N) (due to the N recursive calls)

Space Complexity (SC): O(N) (due to the call stack)

'''
def fact(N):
  if N == 1:
    return 1
  return N * fact(N-1)
print(fact(4))

# TODO : 7 reverse an array
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢
â­â­â­

https://takeuforward.org/data-structure/reverse-a-given-array/

https://practice.geeksforgeeks.org/problems/reverse-an-array/0

https://www.youtube.com/watch?v=twuC1F6gLI8&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=11

'''
# method 1 - using built-in methods
'''
Time Complexity (TC): O(N) (because the function processes each element of the input list once).

Space Complexity (SC): O(N) (due to the call stack and the reversed_arr list).
'''
def rev(arr, reversed_arr):
  if len(arr) == 0:
    return
  reversed_arr.append(arr.pop())
  rev(arr, reversed_arr)
  return reversed_arr
print(rev([3,2,1],[]))

# method 2 - using python swaping technique
'''
Time Complexity (TC): O(N) (since we make N / 2 recursive calls and each call does a constant-time swap).

Space Complexity (SC): O(N) (due to the call stack, as recursion depth is proportional to N).

for arr len 5, len(arr)//2 -> 2 -> indexing starts with 0  and middle one donot need swaping -> (0,1)
for arr len 6  len(arr)//2 -> 3 -> indexing starts with 0 and middle one condition will not arise -> (0,1,2) 
'''
def reverse_arr(arr, start, end):
  if start >= end:
    return
  arr[start], arr[end] = arr[end], arr[start]                           # ---> swaping in python
  reverse_arr(arr, start+1, end-1)
  return arr

array = [1,2,3,4]
print(reverse_arr(array, 0, len(array) - 1))

# method 3 - without using any other variable
'''
Time Complexity (TC): O(N) (because there are N / 2 recursive calls and each call performs a constant-time operation).

Space Complexity (SC): O(N) (due to the recursion depth, which is proportional to N / 2).

for arr len 5, len(arr)//2 -> 2 -> indexing starts with 0  and middle one donot need swaping -> (0,1)
for arr len 6  len(arr)//2 -> 3 -> indexing starts with 0 and middle one condition will not arise -> (0,1,2) 

'''
def reverse_arr(arr, index):
  if index >= len(arr)//2:
    return arr
  arr[index], arr[len(arr) - index - 1] = arr[len(arr) - index - 1], arr[index]      # ---> start = arr[i], end = arr[len(arr) - i - 1]
  return reverse_arr(arr, index + 1)
  
array = [1,2,3,4]
print(reverse_arr(array, 0))

# method 4 - using for loop / extra array
'''
Time Complexity (TC): O(n) (since we iterate over the array once).

Space Complexity (SC): O(n) (due to the additional array reversed_arr created).
'''
def reverse_arr(arr):
  reversed_arr = [0]*len(arr)
  for i in range(n-1, -1, -1):
    reversed_arr[n-i-1] = arr[i]
  return reversed_arr
array = [1,2,3,4]
print(reverse_arr(array, 0))

# method 4 - using while loop/ space optimized meyhod
'''
Time Complexity (TC): O(n) (because the function iterates over half of the array).

Space Complexity (SC): O(1) (due to in-place swapping with only two extra variables).
'''
def reverse_arr(arr, index):
  p1 = 0
  p2 = len(arr) - 1
  while p1 < p2:
    arr[p1], arr[p2] = arr[p2], arr[p1]
    p1 += 1
    p2 -= 1
  return arr
array = [1,2,3,4]
print(reverse_arr(array, 0))

# 8 TODO : check if a string is palindrome or not using recursion
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

https://takeuforward.org/data-structure/check-if-the-given-string-is-palindrome-or-not/

https://leetcode.com/problems/valid-palindrome/


'''
# method 1 : using while loop 
'''
Time Complexity (TC): O(n), where n is the length of the string (due to the while loop iterating over half the string).

Space Complexity (SC): O(1) (since only a few variables are used and no extra data structures are created).
'''
def pallindrome(str, i):
  left = 0
  right = len(str) - 1
  while left < right:
    if str[left] != str[right]:
      return False
    left += 1
    right -= 1
  return True
print(pallindrome("MADAM", 0))

# method  2 : using recursion  
'''
Time Complexity (TC): O(n), where n is the length of the string.

Space Complexity (SC): O(n), due to the recursion stack.
'''
def pallindrome(str, i):
  if i >= len(str)//2:
    return True
  if str[i] != str[len(str) - i - 1]:
    return False
  return pallindrome(str, i + 1)    
print(pallindrome("MADAM", 0))

# 9 fibonacci number
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/arrays/print-fibonacci-series-up-to-nth-term/

https://leetcode.com/problems/fibonacci-number/

Time Complexity (TC): O(2^n) (due to exponential growth in recursive calls).

Space Complexity (SC): O(n) (due to the depth of recursion in the call stack).
'''
def fibonacci(num):
  if num == 0: return 0
  if num == 1: return 1
  return fibonacci(num-2) + fibonacci(num-1)
  
print(fibonacci(6))

# endregion





# region 1.6 HASHING PROBLEM
# --------------------------

# TODO : 1 introduction
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

https://takeuforward.org/hashing/hashing-maps-time-complexity-collisions-division-rule-of-hashing-strivers-a2z-dsa-course/

# theory - https://www.youtube.com/watch?v=TLk7_Ia3rzQ&t=431s
# practical - https://www.youtube.com/watch?v=KEs5UyBJ39g&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=13

'''



# TODO : 2 counting frequency of array elements 
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢
â­â­â­ using hash table / hash array

https://takeuforward.org/data-structure/count-frequency-of-each-element-in-the-array/

https://practice.geeksforgeeks.org/problems/frequency-of-array-elements-1587115620/0


'''
def frequency_arr(arr):
  freq_arr = [0] * (max(arr) + 1)
  for value in arr:
    freq_arr[value] = freq_arr[value] + 1
  return freq_arr

print(frequency_arr([1,2,4,5,3,2,4,1]))               # ---> [0, 2, 2, 1, 2, 1]

# TODO : 3 find the highest/lowest frequency element in an array
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/arrays/find-the-highest-lowest-frequency-element/

https://leetcode.com/problems/frequency-of-the-most-frequent-element/

'''
def frequency_arr(arr):
  freq_arr = [0] * (max(arr) + 1)
  for value in arr:
    freq_arr[value] = freq_arr[value] + 1

  highest_freq = max(freq_arr)
  lowest_freq = min(f for f in freq_arr if f > 0)

  highest_freq_index = freq_arr.index(highest_freq)
  lowest_freq_index = freq_arr.index(lowest_freq) 
  return {"highest_frequncy => " : highest_freq,
    "highest_frequncy_element => " : arr[highest_freq_index],
    "lowest_frequncy => " : lowest_freq,
    "lowest_frequncy_index => " : arr[lowest_freq_index],
  }

print(frequency_arr([1,2,4,5,3,2,4,1]))  # ---> {'highest_frequncy => ': 2, 'highest_frequncy_element => ': 2, 'lowest_frequncy => ': 1, 'lowest_frequncy_index => ': 5}


# endregion




# region 2.1 SORTING-I
# --------------------
# TODO : 1 selection sort
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢
ğŸ˜ğŸ˜ğŸ˜

https://takeuforward.org/sorting/selection-sort-algorithm/

https://bit.ly/3ppA6YJ

- https://www.youtube.com/watch?v=HGk_ypEuS24&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=14

- https://www.geeksforgeeks.org/selection-sort-algorithm-2/

- select the smallest element and swap

steps
- iterate over the arr till n-1 with i
- take a variable min inside loop and assign i
- again iterate over the array from i+1 to n with j
- if arr[j] < arr[min] then min = j
- after the inner loop is over swap arr[i] and arr[min]

'''
'''
Time Complexity (TC): O(n^2), where n is the size of the input array.

Space Complexity (SC): O(1), since the sorting is done in place with constant extra space.
'''
def selection_sort(arr):
  n = len(arr)
  for i in range(n-1):
    min = i
    for j in range(i+1,n):
      if arr[j] < arr[min]:
        min = j 
    arr[i], arr[min] = arr[min], arr[i]
  return arr  

print(selection_sort([1,2,4,5,3,2,4,1]))


# TODO : 2 bubble sort
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢
ğŸ˜ğŸ˜ğŸ˜

https://takeuforward.org/data-structure/bubble-sort-algorithm/

https://bit.ly/3w6yQx8

https://www.youtube.com/watch?v=HGk_ypEuS24&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=14

https://www.geeksforgeeks.org/bubble-sort/

- swapping the adjacent elements and push the max element in the last

steps
- iterate over the arr till n with i
- iterate over the arr till n-i-1 with j, because for example
for arr len = 4, i => 0 and j => 0 to 4 not till 5 because we need to swap the element with the next element with j+1. It will cause error if we run it till 5
- if arr[j] > arr[j+1] then swap arr[j] and arr[j+1]

'''
'''
Time Complexity (TC): O(n^2), where n is the size of the input array (for worst and average cases). O(n) for best case only.

Space Complexity (SC): O(1), as it sorts in place without using extra space.
'''
def bubble_sort(arr):
  n = len(arr)
  for i in range(n):
    for j in range(n -i -1):
      if arr[j] > arr[j+1]:
        arr[j], arr[j+1] = arr[j+1], arr[j]
  return arr  

print(bubble_sort([1,2,4,5,3,2,4,1]))

# ğŸ‘‰ğŸ‘‰ğŸ‘‰ optimized bubble sort
# def bubble_sort(arr):
#   n = len(arr)
#   for i in range(n):
#     swapped = False  # Flag to check if any swapping happened during this iteration
#     for j in range(n -i -1):
#       if arr[j] > arr[j+1]:
#         arr[j], arr[j+1] = arr[j+1], arr[j]
#         swapped = True
#     # If no elements were swapped in inner loop, then the array is sorted
#     if not swapped:
#       break
#   return arr  

# print(bubble_sort([1,2,4,5,3,2,4,1]))

# TODO : 3 insertion sort
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢
ğŸ˜ğŸ˜ğŸ˜

https://takeuforward.org/data-structure/insertion-sort-algorithm/

https://bit.ly/3JVcqot

- https://www.youtube.com/watch?v=HGk_ypEuS24&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=14

- https://www.geeksforgeeks.org/insertion-sort/
- https://www.youtube.com/watch?v=9j7llneJ77o

- takes an element and place it in the correct position

steps
- iterate over the arr from 1 to n with i
- take a variable key and assign arr[i]
- take a variable j and assign i-1
- while j >= 0 and key < arr[j] if true then arr[j+1] = arr[j] and j = j-1
for example in an arr 40,30,20 if i is at 2 index the j will be at 1 then 0 then -1 then the condition j >=0 will become false and exit from the loop 
- after the inner loop is over arr[j+1] = key

'''
'''
Time Complexity (TC):

Worst case and Average case: O(n^2) (when the array is sorted in reverse order).

Best case: O(n) (when the array is already sorted).

Space Complexity (SC): O(1), as the sorting is done in place with constant extra space.
'''
def insertion_sort(arr):
  n = len(arr)
  for i in range(1,n):
    key = arr[i]
    j= i-1
    while j>=0 and key < arr[j]:
      arr[j+1] = arr[j]
      j = j -1 
    arr[j+1] = key
  return arr  
print(insertion_sort([1,2,4,5,3,2,4,1]))

# endregion




# region 2.2 SORTING-II
# ---------------------

# TODO : 1 merge sort
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡
ğŸ˜ğŸ˜ğŸ˜

https://takeuforward.org/data-structure/merge-sort-algorithm/

https://bit.ly/3A30Anw

- https://www.youtube.com/watch?v=ogjf7ORKfd8&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=15

- https://www.geeksforgeeks.org/merge-sort/ 

- divide array into two parts and sort them


steps
merge_sort
- base condition if low >= high then return
- divide the array into two parts by mid = (low + high)//2
- call the merge_sort function for left part as merge_sort(arr, low, mid)
- call the merge_sort function for right part as merge_sort(arr, mid+1, high)
- call the merge function for merging the two parts as merge(arr, low, mid, high)

merge
- take a temp array as [], low as left and mid+1 as right
- take a while loop for left <= mid and right <= high
- if arr[left] < arr[right] then append arr[left] to temp and left = left + 1 else append arr[right] to temp and right = right + 1
- if left <= mid then append arr[left] to temp and left = left + 1 
- if right<=high then append arr[right] to temp and right = right + 1
- copy the temp array to arr from low to high 

Time Complexity: O(nlog2(n)), log2(n) is for recursive merge_sort calling and divising it by 2 and n because we are merging it n number of time as the length of arr.

Space Complexity: O(n) because we are creating a temp arr in merge section.

'''
def merge_sort(arr, low, high):
  if low >= high:
    return
  
  mid = (low + high) // 2
  merge_sort(arr, low, mid)
  merge_sort(arr, mid + 1, high)
  merge(arr, low, mid, high)
  return arr

def merge(arr, low, mid, high):
  temp = []
  left = low
  right = mid + 1
  
  while left <= mid and right <= high:
    if arr[left] < arr[right]:
      temp.append(arr[left])
      left += 1
    else:
      temp.append(arr[right])
      right += 1
          
  # Append remaining elements from the left half
  while left <= mid:
    temp.append(arr[left])
    left += 1
  
  # Append remaining elements from the right half
  while right <= high:
    temp.append(arr[right])
    right += 1
  
  # Copy the sorted temp array back to the original arr
  for i in range(len(temp)):
    arr[low + i] = temp[i]

arr = [1, 2, 4, 5, 3, 2, 4, 1]
print(merge_sort(arr, 0, len(arr) - 1))


# TODO : 2 recursive bubble sort
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/arrays/recursive-bubble-sort-algorithm/

https://bit.ly/3QV65vI

'''
'''
Time Complexity (TC):

In the worst case, we need to perform n passes through the array, where n is the length of the array. In each pass, we make n-1, n-2, ..., 1 comparisons.
Therefore, the time complexity is O(nÂ²), just like the iterative bubble sort.

Space Complexity (SC):

The space complexity of this recursive bubble sort is O(n) due to the recursion stack. Each recursive call adds a layer to the call stack, and in the worst case, there are n recursive calls.

'''
def recursive_bubble_sort(arr, n=None):
    # If n is None, initialize it to the length of the array
    if n is None:
        n = len(arr)

    # Base case: If the array has one or no elements, return the array (sorted)
    if n <= 1:
        return arr
    
    # Perform a single pass of bubble sort (bubble the largest element to the end)
    for i in range(n - 1):
        if arr[i] > arr[i + 1]:
            # Swap the elements if they are in the wrong order
            arr[i], arr[i + 1] = arr[i + 1], arr[i]
    
    # Recursively call the function on the array excluding the last sorted element
    return recursive_bubble_sort(arr, n - 1)

# Example usage:
arr = [64, 34, 25, 12, 22, 11, 90]
sorted_arr = recursive_bubble_sort(arr)
print("Sorted array:", sorted_arr)

# TODO : 3 recursive insertion sort
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/arrays/recursive-insertion-sort-algorithm/

https://bit.ly/3PxAWx1

'''
'''
Time Complexity (TC):

The recursive call sorts the first n-1 elements. For each element, the worst-case scenario involves shifting all previously sorted elements, which takes O(n) time.
Therefore, the time complexity is O(nÂ²), similar to the iterative insertion sort.

Space Complexity (SC):

The space complexity is O(n) due to the recursive call stack. In the worst case, there will be n recursive calls (one for each element), so the space complexity is linear in the size of the array.
'''
def recursive_insertion_sort(arr, n=None):
    # If n is None, initialize it to the length of the array
    if n is None:
        n = len(arr)

    # Base case: If array size is 1 or 0, it is already sorted
    if n <= 1:
        return arr
    
    # Recursively sort the first n-1 elements
    recursive_insertion_sort(arr, n - 1)
    
    # Insert the nth element into the sorted portion of the array
    last = arr[n - 1]
    j = n - 2

    # Shift elements of the sorted portion to the right to make space for last
    while j >= 0 and arr[j] > last:
        arr[j + 1] = arr[j]
        j -= 1
    
    # Place the nth element at its correct position
    arr[j + 1] = last

    return arr

# Example usage:
arr = [12, 11, 13, 5, 6]
sorted_arr = recursive_insertion_sort(arr)
print("Sorted array:", sorted_arr)

# TODO : 4 quick sort
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢
ğŸ˜ğŸ˜ğŸ˜

https://takeuforward.org/data-structure/quick-sort-algorithm/

https://bit.ly/3dsEbIK

https://www.youtube.com/watch?v=WIrA4YexLRQ&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=16

https://www.youtube.com/watch?v=UjdyhNkaO9k

- pick a pivot and place it in the correct place to the sorted array

steps
âŒâŒâŒâŒâŒâŒ NOT UNDERSTAND âŒâŒâŒâŒâŒâŒ

Time Complexity:
Best and Average Time Complexity: 
O(n logn)
Worst Time Complexity: 
O(n^2)

Space Complexity:
O(log n ) for best and average case
O(n) for worst case
'''
def quick_sort(arr, low, high):
  if low < high:
    partition_index = find_right_place(arr, low, high)
    quick_sort(arr, low, partition_index - 1)
    quick_sort(arr, partition_index + 1, high)
  return arr

def find_right_place(arr, low, high):
  # Choose the pivot element (typically the first element in this implementation)
  pivot = arr[low]
  # i will track the index for the left side (elements greater than pivot)
  # j will track the index for the right side (elements smaller than pivot)
  i = low
  j = high
  
  # Continue until i and j cross each other
  while i < j:
    # Find an element greater than the pivot (i starts from the left and moves right)
    while i <= high and arr[i] <= pivot:
      i += 1
    # Find an element smaller than the pivot (j starts from the right and moves left)
    while j >= low and arr[j] > pivot:
      j -= 1
    # If i < j, swap the elements at i and j because they're out of place
    if i < j:
      arr[i], arr[j] = arr[j], arr[i]
  # After i and j cross, place the pivot in its correct sorted position (swap it with arr[j])
  arr[low], arr[j] = arr[j], arr[low]
  
  # Return the index of the pivot, which is now in the correct place
  return j

arr = [1,2,4,5,3,2,4,1]
print(quick_sort(arr, 0, len(arr)-1))

# endregion




# region 3.1 ARRAYS - EASY
# ------------------------

# TODO : 1 largest element in an array 
"""
[using two nested for loops, 
using builtin methods, 
using one for loop]
"""
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/data-structure/find-the-largest-element-in-an-array/

https://www.youtube.com/watch?v=wvcQg43_V8U&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=17

https://bit.ly/3Pld280

'''
# - method 1 : brute force, using sort 
'''

steps
- iterate the outer loop with i till n-1
- take a variable max and initialize it with i
- iterate the inner loop with j from i+1 to n
- check if arr[j] > arr[max] if true them make max = j
- after the inner loop ends swap arr[i] with arr[max]

TC - O(N^2)
SC - O(N)
'''
def largest_element_2(arr):
  n = len(arr)
  for i in range(n-1):
    max = i
    for j in range(i+1, n):
      if arr[j] < arr[max]:
        max = j
    arr[i], arr[max] = arr[max], arr[i]
  return arr  
arr = [1,2,4,7,7,5]
largest_element_2(arr)
print("largest element => ", arr[len(arr) - 1])

# - method 2 : brute force, using sort() buit-in
'''
TC - O(n logn) depends on which sorting is used internally
SC - O(1)
'''
def largest_element_2(arr):
  arr.sort()
  return arr[-1]  
arr = [1,2,4,7,7,5]
print(largest_element_2(arr))

# - method 3 : brute force, using max() built-in method
'''
TC - O(n)
SC - O(1)
'''
print(max([1,2,4,7,7,5]))

# - method 4 : using loop, 
'''

steps
- initialize largest = arr[0]
- iterate over the array with i on the array
- check if i > largest then largest = 1

TC - O(N)
SC - O(1) 
'''
def largest_element_1(arr):
  largest = arr[0]
  for i in arr:
    if i > largest:
      largest = i
  return largest
print(largest_element_1([1,2,4,7,7,5]))

# 2 TODO : find smallest/largest and second largest/second largest element in an array
"""
[
using built-in method (max, min) and for loop,
using for loop only 
]
"""
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢
â­â­â­

https://takeuforward.org/data-structure/find-second-smallest-and-second-largest-element-in-an-array/

https://www.youtube.com/watch?v=wvcQg43_V8U&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=17

https://bit.ly/3pFvBcN

'''
# method 1: brute force using sort
# NOTE : ONLY WORK IF ARRAY DOESNOT CONTAIN DUPLICATES
'''

TC - O(N log(N))

SC - O(1)

'''
def second_largest_element_2(arr):
  arr.sort()
  return {
    "smallest": arr[0],
    "second_largest": arr[len(arr)-2]
  }
arr = [1,2,4,7,7,5]
print(second_largest_element_2(arr))

# method 2: better approch, using loop
'''

steps
- initialize smallest = float("inf"), second_smallest = float("inf"), largest = float("-inf"), second_largest = float("-inf")
- iterate over the array with i on the array and find small and large using min() and max() methods with the current element
- again iterate over the array with i on the array and find second_small and second_large by comparing small and large element 

Time Complexity - O(N)
Space Complexity - O(1)
'''
def largest_smallest(arr):
  n = len(arr)
  if n == 0 and n==1:
    print(-1, -1)
  small = float("inf")
  second_small = float("inf")
  large = float("-inf")
  second_large = float("-inf")
  for i in range(n):
    small = min(small,arr[i])
    large = max(large,arr[i])
  for i in range(n):
    if arr[i] < second_small and arr[i] != small:
      second_small = arr[i]
    if arr[i] > second_large and arr[i] != large:
      second_large = arr[i]
  return {
    "smallest": small,
    "second_small": second_small,
    "large": large,
    "second_largest": second_large
  }
arr = [1,3,6,6,2,6]
print(largest_smallest(arr))

# method 3: optimal approch
'''
steps
- initialize largest = float("-inf") and second_largest = float("-inf")
- iterate over the array with i 
- if arr[i] > largest then second_largest = largest and largest = arr[i], elseif arr[i] > second_largest and arr[i] != largest then second_largest = arr[i]

Time Complexity - O(N)
Space Complexity - O(1)

'''
def second_smallest(arr):
  if len(arr) < 2:
    return -1
  smallest_item = float("inf")
  second_smallest = float("inf")
  
  for i in range(len(arr)):
    if arr[i] < smallest_item:
      second_smallest = smallest_item
      smallest_item = arr[i]
    elif arr[i] < second_smallest and arr[i] != smallest_item:
      second_smallest = arr[i]
  return {"second_largest_item = " : second_smallest, "largest_item = " : smallest_item}

def second_largest(arr):
  if len(arr) < 2:
    return -1
  largest_item = float("-inf")
  second_largest_item = float("-inf")
  
  for i in range(len(arr)):
    if arr[i] > largest_item:
      second_largest_item = largest_item
      largest_item = arr[i]
    elif arr[i] > second_largest_item and arr[i] != largest_item:
      second_largest_item = arr[i]
  return {"second_largest_item = " : second_largest_item, "largest_item = " : largest_item}
  
arr = [1,3,6,6,2,6]
print(second_largest(arr))
print(second_smallest(arr))


# 3 TODO : check if array is sorted
"""
[
using two for loops, 
using only one for loop
]
"""
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/data-structure/check-if-an-array-is-sorted/

https://www.youtube.com/watch?v=wvcQg43_V8U&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=17

https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/#:~:text=Input%3A%20nums%20%3D%20%5B2%2C,no%20rotation)%20to%20make%20nums.

'''
# method 1 : brute force, 
'''

steps
- iterate the outer array with i 
- iterate the inner array with j
- check arr[i] > arr[j] if true then return false


TC - O(n^2), where n is the number of elements in the array. The nested loops lead to quadratic time complexity.

SC - O(1) as only a constant amount of extra space is used (no additional arrays or data structures are created).

'''
def arr_sorted(arr):
  n = len(arr)
  for i in range(n):
    for j in range(i+1, n):
      if arr[i] > arr[j]:
        return False 
  return True
arr = [1,2,2,3,3,4]
print(arr_sorted(arr))

# method 2 : optimal approch
'''
steps
- iterate the array with i from 1 till n
- check arr[i-1] > arr[i] if true then return false

TC - O(n), where n is the number of elements in the input array. The function checks each element once.

SC - O(1), since the function uses a constant amount of space and does not require additional storage.

'''
def arr_sorted(arr):
  for i in range(1,len(arr)):
    if arr[i-1] > arr[i]:
      return False
  return True
arr = [1,2,2,3,3,4]
print(arr_sorted(arr))

# 

# 4 TODO : remove duplicate from sorted array
"""
[
using set, 
using return list(set(arr)) + ["_"]*(len(arr) - len(list(set(arr)))), 
using one pointer i and a for loop with j
]
"""
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/data-structure/remove-duplicates-in-place-from-sorted-array/

https://www.youtube.com/watch?v=wvcQg43_V8U&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=17

https://leetcode.com/problems/remove-duplicates-from-sorted-array/#:~:text=Input%3A%20nums%20%3D%20%5B0%2C,%2C%203%2C%20and%204%20respectively.

'''
# - method 1: brute force, using set()
'''

steps
- create a set
- iterate the array with i and add them in the set


TC - O(n),  where n is the number of elements in the input array. This accounts for iterating through the array and adding each element to the set.

SC - O(n), where n is the number of unique elements in the array. In the worst case (when there are no duplicates), this is O(n).
'''
def remove_duplicates(arr):
  my_set = set()
  for i in arr:
    my_set.add(i)
  return my_set
arr = [1,2,2,3,3,4]
print(remove_duplicates(arr))             # Output - 1, 2, 3, 4

# ğŸ‘‰ğŸ‘‰ğŸ‘‰ replacing with "_"
# return list(set(arr)) + ["_"]*(len(arr) - len(list(set(arr))))


# - method 2: optimal approch, using two pointers
'''
steps
- take the first index 0 in i
- iterate over the array with j from 1 till end
- check arr[i] != arr[j] if true increate i by 1 and assign arr[i] with arr[j]
- return i+1 and arr[:i+1]

TC - O(n), where n is the number of elements in the input array. The function iterates through the array once.

SC - O(k), where k is the number of unique elements in the array. In the worst case (when there are no duplicates), this is O(n).
'''
def remove_duplicates(arr):
  i = 0
  for j in range(1, len(arr)):  # Loop through the array starting from the second element
    if arr[i] != arr[j]:  # If the current element is not equal to the previous one
      i += 1  # Move i forward to a new unique position
      arr[i] = arr[j]  # Assign the current element to the new unique position
      
  return i + 1, arr[:i + 1]  # Return the number of unique elements and the unique sub-array

arr = [1, 2, 2, 3, 3, 4]
k, unique_arr = remove_duplicates(arr)        # ---> k = 4, unique_arr = [1, 2, 3, 4]

# 

# 5 TODO : left rotate an array by one place
"""
[
using temp array and for loop, 
using slicing,
using temp variable and for loop
]
"""
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/data-structure/left-rotate-the-array-by-one/

https://www.youtube.com/watch?v=wvcQg43_V8U&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=18

https://leetcode.com/problems/rotate-array/

'''
# method 1: brute force, 
'''
steps
- create a temp array of length of the given array and initialize it with 0
- iterate on the given array with i from 1 till n
- assign temp[i-1] with arr[i]
- after loop ends assign temp[len(arr) - 1] with arr[0]
- return temp

TC - O(N)

SC - O(N), temp is of same size as given array

'''
def rotate_arr(arr):
  temp  = [0]*len(arr)
  for i in range(1, len(arr)):
    temp[i-1] = arr[i]
  temp[len(arr) - 1] = arr[0]
  return temp

arr = [1, 2, 2, 3, 3, 4]
print(rotate_arr(arr))            # Output - [2, 2, 3, 3, 4, 1]

# ğŸ‘‰ğŸ‘‰ğŸ‘‰ using array slicing 
# return arr[:len(arr)] + arr[:1]

# - method 2: optimal approch
'''
steps
- take the first element and assign it to temp variable
- iterate on the given array with i from 1 till n
- assign arr[i-1] with arr[i]
- after loop ends assign arr[len(arr) - 1] with temp
- return arr

TC - O(N)

SC - O(1), using only temp to store extra element
'''
def rotate_arr(arr):
  temp = arr[0]
  for i in range(1, len(arr)):
    arr[i-1] = arr[i]
  arr[len(arr)-1] = temp
  return arr

arr = [1, 2, 2, 3, 3, 4]
print(rotate_arr(arr))                    # Output - [2, 2, 3, 3, 4, 1]


# 6 TODO : left rotate an array by d places
"""
[
using slicing and return new array,
using slicing and swapping with same array, 
using reversed() three times,

]
"""
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢
â­â­â­

https://takeuforward.org/data-structure/rotate-array-by-k-elements/

https://www.youtube.com/watch?v=wvcQg43_V8U&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=18

https://leetcode.com/problems/rotate-array/

'''
# - method 1: brute force, using temp arr
'''
steps
- find the rotation_number by rotation % len(arr)
- create a temp array of length from 0 till rotation number
- iterate on the given array with i from rotation number till n
- assign arr[i-rotation_number] with arr[i]
- after loop ends assign arr[rotation_number : ] with temp
- return arr

TC - O(N), in the worst case when rotation number is 0

SC - O(N), using temp in the worst case temp have to store whole array
'''
def rotate_arr(arr, rotation):
    if len(arr) == 0:
        return 
    rotation_number = rotation % len(arr)
    temp = arr[:rotation_number]
    for i in range(rotation_number, len(arr)):
      arr[i-rotation_number] = arr[i]
    arr[rotation_number : ] = temp
    return arr
arr = [1, 2, 2, 3, 3, 4]
print(rotate_arr(arr, 9))

# ğŸ‘‰ğŸ‘‰ğŸ‘‰ using array slicing 
# return arr[k:len(arr)] + arr[:k]

# - method 2: better approch, using slicing
'''
steps
- find the rotation_number by rotation % len(arr)
- swap arr[:rotation_number] and arr[rotation_number : ]
- return arr

TC - O(1), no iteration is done

SC - O(1), no extra variable is used except rotation_number
'''
def rotate_arr(arr, rotation):
    if len(arr) == 0:
      return 
    rotation_number = rotation % len(arr)
    arr[:rotation_number],arr[rotation_number : ] = arr[rotation_number : ],arr[:rotation_number] 
    return arr
arr = [1, 2, 2, 3, 3, 4]
print(rotate_arr(arr, 9))

# - method 3: better approch, using built-in reverse() and reversed() methods
'''
steps
- find the rotation_number d by rotation % len(arr)
- reverse the whole array using reverse()
- reverse the array from 0 to d using reversed()
- reverse the array from d to n using reversed()
- return arr

TC - O(1), no iteration is done

SC - O(1), no extra variable is used except rotation_number
'''
def left_rotate(arr, d):
    n = len(arr)    
    d = d % n    
    arr.reverse()
    arr[:d] = reversed(arr[:d])    
    arr[d:] = reversed(arr[d:])
    return arr

arr = [1, 2, 3, 4, 5]
d = 2
rotated_arr = left_rotate(arr, d)

# - method 4: optimal approch, using reversal algorithm,ğŸ¤¯ğŸ¤¯ğŸ¤¯
'''

steps
- find the rotation_number d by rotation % len(arr)
- reverse the array from 0 to d-1
- reverse the array from d to n-1
- reverse the whole array

TC - O(n), where n is the length of the array.

SC - O(1), because the algorithm operates in place and only uses a constant amount of extra space.
'''
def reverse_arr(arr, start, end):
  # reverse the array from start to end using temp variable
  while start <= end:
    temp = arr[start]
    arr[start] = arr[end]
    arr[end] = temp
    start += 1
    end -= 1

def left_rotate(arr, d):
    n = len(arr)
    d = d % n
    reverse_arr(arr, 0, d - 1)
    reverse_arr(arr, d, n - 1)
    reverse_arr(arr, 0, n-1)

arr = [1, 2, 3, 4, 5]
d = 2
rotated_arr = left_rotate(arr, d)

# ğŸ‘‰ğŸ‘‰ TODO : right rotate an array by d places


# 7 TODO : move all zeros to the end of the array
"""
[
using two temp arrays,
using one pointer and for loop
]
"""
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/data-structure/rotate-array-by-k-elements/

https://www.youtube.com/watch?v=wvcQg43_V8U&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=18

https://leetcode.com/problems/move-zeroes/
'''
# - method 1: brute force
'''
steps
- take two variable temp and temp2 to store zero and non-zero values
- iterate on the given array with i from 0 till n
- if arr[i] is not zero then append it to temp else append it to temp2
- return temp + temp2

TC - O(N), iterating over the whole array

SC - ~O(2N), using two temp array different sizes

'''
def move_zeros(arr):
    temp = []
    temp2 = []
    for i in arr:
      if i != 0:
        temp.append(i)
      else:
        temp2.append(i)
    return temp + temp2
        
arr = [1, 0, 2, 3, 0, 4]
print(move_zeros(arr))                    # Output - [1, 2, 3, 4, 0, 0]

# method 2: optimal approch, using two pointers
'''
steps
- take a variable j ans assign it with -1
- iterate on the given array with i from 0 till n to find the first 0 in the array. if found the assign the index to j 
- check if j == -1 if true retuen the same array
- iterate the array with i from j+1 till n
- check if arr[i] is not zero then swap arr[i] with arr[j] and increment j by 1
- return arr


TC - O(N), iterating over the array

SC - O(1), swapping is done in the same array
'''
def move_zeros(arr):
  j = -1
  for i in range(len(arr)):
    if arr[i] == 0:
      j = i
      break
  if j == -1:
    return arr 
  for i in range(j+1, len(arr)):
    if arr[i] != 0:
      arr[i], arr[j] = arr[j], arr[i]
      j = j+1
  return arr    

arr = [1, 0, 2, 3, 0, 4]
print(move_zeros(arr))                       # Output - [1, 2, 3, 4, 0, 0]


# 8 TODO : linear search
"""
[
using simple for loop
]
"""
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/data-structure/linear-search-in-c/

https://www.youtube.com/watch?v=wvcQg43_V8U&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=18


https://bit.ly/3KcpHcB

steps
- iterate on the given array with i from 0 till n
- check if arr[i] is equal to target if true return i

Time Complexity: O(n), number may not exists

Space Complexity: O(1), no extra varible is use only returned the index

'''
def linear_search(arr, target):
  for i in range(len(arr)):
    if arr[i] == target:
      return i
  return -1


# 9 TODO : find the union of sorted arrays
"""
[
using frequency object, 
using set, 
using two pointer
]
"""
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡
â­â­â­


https://takeuforward.org/data-structure/union-of-two-sorted-arrays/

https://www.youtube.com/watch?v=wvcQg43_V8U&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=18

https://bit.ly/3Ap7Onp

'''
# - method 1: brute force, using map,
'''
steps
- create an empty map
- iterate over the arr_1and add the elements in the map with 0, increment the value by 1 if the same number arises.
- iterate over the arr_2and add the elements in the map with 0, increment the value by 1 if the same number arises.
- return the list of keys of the map

Time Complexity: O(n + m)

Space Complexity: O(n + m)
'''
def union(arr1, arr2):
  freq = {}
  for i in arr1:
    freq[i] = freq.get(i, 0) + 1
  for i in arr2:
    freq[i] = freq.get(i, 0) + 1
  return list(freq.keys())
arr1 = [0, 1, 2, 3, 4]
arr2 = [1,4,5,7]
print(union(arr1, arr2))                          # Output - [0, 1, 2, 3, 4, 5, 7]

# - method 2: better approch, using set
'''
steps
- create a set
- iterate over the array_1 and add the value into the set
- iterate over the array_2 and add the value into the set
- return list(set)


Time Complexity: O(n + m)

Space Complexity: O(n + m)
'''

def union(arr1, arr2):
  s1 = set()
  for i in arr1:
    s1.add(i)
  for i in arr2:
    s1.add(i)
  return list(s1)
arr1 = [0, 1, 2, 3, 4]
arr2 = [1,4,5,7]
print(union(arr1, arr2))                          # Output - [0, 1, 2, 3, 4, 5, 7]


# method 3: optimal approch, using two pointersğŸ¤¯ğŸ¤¯ğŸ¤¯
'''
steps
- create two pointers i and j and initialize them with 0 and a variable union = []
- - iterate over the array_1 and array_2 using while loop till i < len(arr1) and j < len(arr2)
- check if arr1[i] <= arr2[j] if true then check if union is empty or union[-1] != arr1[i] if true then append arr1[i] to union and increment i by 1 else check if union is empty or union[-1] != arr2[j] if true then append arr2[j] to union and increment j by 1
- iterate over the array_1 till i < len(arr1) and check if union[-1] != arr1[i] if true then append arr1[i] to union and increment i by 1
- iterate over the array_2 till j < len(arr2) and check if union[-1] != arr2[j] if true then append arr2[j] to union and increment j by 1
- return union

Time Complexity: O(m + n)

Space Complexity: O(m + n) (due to the result list)
'''
def union(arr1, arr2):
  i,j = 0,0
  union = []
  while i < len(arr1) and j < len(arr2):
    if arr1[i] <= arr2[j]:
      # union[-1] gets the last element that was added to union
      if len(union) == 0 or union[-1] != arr1[i]:
        union.append(arr1[i])
      i += 1
    else:
      if len(union) == 0 or union[-1] != arr2[j]:
        union.append(arr2[j])
      j += 1
  while i < len(arr1):
    if union[-1] != arr1[i]:
      union.append(arr1[i])
    i += 1
  while j < len(arr2):
    if union[-1] != arr2[j]:
      union.append(arr2[j])
    j += 1
  return union

arr1 = [0, 1, 2, 3, 4]
arr2 = [1,4,5,7]
print(union(arr1, arr2))                          # Output - [0, 1, 2, 3, 4, 5, 7]


# ğŸ‘‰ğŸ‘‰ğŸ‘‰ TODO : find the intersection of sorted arrays 
"""
[
using two nested for loops,
using two pointers
]
"""
'''
https://www.youtube.com/watch?v=wvcQg43_V8U&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=19
'''
# method 1: Brute force
'''
steps
- create an empty list as result
- iterate over the arr1 with i from 0 till n
- iterate over the arr2
- check if arr1[i] == arr2[j] and arr[i] is not in the result if true then append arr1[i] to result and break the loop
- return result

Time Complexity: O(m * n) â†’ nested loop over both arrays.

Space Complexity: O(k) â†’ for storing result.
'''
def intersection(arr1, arr2):
  result = []
  for i in range(len(arr1)):
    for j in range(len(arr2)):
      if arr1[i] == arr2[j]:
        if arr1[i] not in result:  # Avoid duplicates in result
          result.append(arr1[i])
        break  # Once matched, move to next element in arr1
  return result

# Example usage
arr1 = [0, 1, 2, 2, 3, 4]
arr2 = [1, 2, 2, 4, 5, 7]
print(intersection(arr1, arr2))  # Output: [1, 2, 4]

# method 2: Optimal approch using two pointer
'''
steps
- create two pointers i and j and initialize them with 0 and a variable result = []
- iterate over the arr1 and arr2 using while loop till i < len(arr1) and j < len(arr2)
- check if arr1[i] == arr2[j] then again check if result is empty or result[-1] != arr1[i] if true then append arr1[i] to result and increment i and j by 1
- check if arr1[i] < arr2[j] if true then increment i by 1 else increment j by 1
- return result

Time Complexity: O(m + n) where m and n are lengths of the two arrays.

Space Complexity: O(k) for the result list (k = size of intersection).
'''
def intersection(arr1, arr2):
  i, j = 0, 0
  result = []

  while i < len(arr1) and j < len(arr2):
    # If both elements are equal, and not already added to result
    if arr1[i] == arr2[j]:
      if len(result) == 0 or result[-1] != arr1[i]:  # avoid duplicates
        result.append(arr1[i])
      i += 1
      j += 1
    elif arr1[i] < arr2[j]:
      i += 1  # move pointer in arr1
    else:
      j += 1  # move pointer in arr2

  return result


# Example usage
arr1 = [0, 1, 2, 2, 3, 4]
arr2 = [1, 2, 2, 4, 5, 7]
print(intersection(arr1, arr2))  # Output: [1, 2, 4]



# 10 TODO : find missing number in an array
"""
[
using for loop,
using hash array, 
using sum of all numbers,
using xor,
]
"""
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢
â­â­â­


https://takeuforward.org/arrays/find-the-missing-number-in-an-array/

https://www.youtube.com/watch?v=bYWLJb3vCWY&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=19


https://leetcode.com/problems/missing-number/

'''
# method 1 : brute force
'''
steps
- iterate over the array from 1 to n+1
- take variable flag = 0
- iterate over the array with j till n
- check if arr[j] == i if true then flag = 1 and break the loop
- when the inner loop is complete check if flag == 0 then return i

TC - O(N^2), iteration is nested

SC - O(1)
'''
def missing_num(arr, n):
  for i in range(1, n +1):
    flag = 0
    for j in range(len(arr)):
      if arr[j] == i:
        flag = 1
        break
    if flag == 0:
      return i
  return -1
print(missing_num([1,2,4,5], 5))                        # Output - 3


# method 2 : better solution, using hashing
'''
steps
- take a hash array hash = [0]*(n+1)
- iterate over the array till n-1 and increment the hash[arr[i]] by 1
- iterate over again the array from 1 till n+1
- check if hash[i] == 0 if true return i

TC - O(2*N), iteration is one after another

SC - O(N), taking hash of same length of array
'''
def missing_num(arr, n):
  hash = [0]*(n+1)
  for i in range(n-1):
    hash[arr[i]] += 1
  for i in range(1, n+1):
    if hash[i] == 0:
      return i
  return -1
print(missing_num([1,2,4,5], 5))                        # Output - 3


# method 3 : optimal solution, summation approch
'''
steps
- find the sum of numbers from 1 to n using n*(n+1)//2
- find the sum of all the numbers present the array using sum()
- return the difference between them

TC - O(N)

SC - O(1)

'''
def missing_num(arr, n):
  summation = (n*(n+1))//2
  s2 = sum(arr)
  return summation - s2
print(missing_num([1,2,4,5], 5))                        # Output - 3

# method 4 : optimal solution, using XOR
'''
NOTE: xor solution is better than sum solution because the sum of 10^5+10^4 etc values will go beyond int range but xor can handle them.

Time Complexity: O(n)

Space Complexity: O(1), Only a few variables used (xor1, xor2), no extra data structures.

'''
def missing_num(arr, n):
  xor1 = 0  # XOR of all elements in the array
  xor2 = 0  # XOR of all numbers from 1 to n

  for i in range(n):
    if i < len(arr):
      xor1 ^= arr[i]  # XOR element from array
    xor2 ^= (i + 1)      # XOR number from 1 to n

  return xor1 ^ xor2

# Test case
print(missing_num([1, 2, 4, 5], 5))  # Output: 3

'''
OR
'''

def missing_num(arr, n):
    xor1 = 0  # Will store XOR of all elements in the input array
    xor2 = 0  # Will store XOR of all numbers from 1 to n

    # XOR all elements in the given array
    for i in range(len(arr)):
        xor1 ^= arr[i]

    # XOR all numbers from 1 to n
    for i in range(1, n + 1):
        xor2 ^= i

    # XOR of xor1 and xor2 gives the missing number
    # Why? Because all numbers that are present will cancel out, only the missing one remains
    return xor1 ^ xor2

# Test case
print(missing_num([1, 2, 4, 5], 5))  # Output: 3



# 11 TODO : maximum consecutive ones
"""
[
using for loop,
]
"""
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/data-structure/count-maximum-consecutive-ones-in-the-array/

https://www.youtube.com/watch?v=bYWLJb3vCWY&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=19

https://leetcode.com/problems/max-consecutive-ones/

'''
# method 1 : brute force
'''
steps
- take two variables maximum and counter and assign 0 to both
- iterate over the array with i till n
- check if arr[i] == 1 if true then increment counter by 1 else make counter = 0
- update maximum with max(maximum, counter)
- return maximum

TC - O(N)

SC - O(1)

'''
def maximum_consecutive(arr):
  maximum = 0
  counter = 0
  for i in range(len(arr)):
    if arr[i] == 1:
      counter = counter + 1 
    else: 
      counter = 0
    maximum = max(maximum, counter)
  return maximum

print(maximum_consecutive([1,1,0,1,1,1,3,1,1]))      # Output - 3

# method 2 : optimal solution 


# 12 TODO : find the number that appears once and other number twice
"""
[
using two nested for loops,
using hash array,
using unordered map,
using xor
]
"""
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

https://takeuforward.org/arrays/find-the-number-that-appears-once-and-the-other-numbers-twice/

https://www.youtube.com/watch?v=bYWLJb3vCWY&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=19

https://leetcode.com/problems/single-number/

'''
# method 1 : brute force,
'''
steps
- iterate over the array with i till n
- take a variable count and assign 0 to it and a variable num = arr[i]
- iterate over the array with j till n
- check if arr[j] == num if true then increment count by 1 
- after the inner loop ends check if count == 1 if true return num

TC - O(N^2)

SC - O(1)
'''
def appear_once(arr):
  for i in range(len(arr)):
    num = arr[i]
    count = 0
    for j in range(len(arr)):
      if arr[j] == num:
        count = count+1 
    if count == 1:
      return arr[i]

print(appear_once([1,1,3,3,2,4,4]))

# method 2 : better solution, using hash array, 
'''
steps
- take a hash array hash = [0]*n
- iterate the array with i till n and increment the values inside the hash array by 1
- iterate over the hash array with i till n
- check if hash[i] == 1 if true return i
- at the end of the loop return -1

TC - O(N) + O(N)

SC - O(maxElement + 1)

'''
def appear_once(arr):
  hash_arr = [0] * len(arr)
  for i in range(len(arr)):
    hash_arr[arr[i]] = hash_arr[arr[i]] + 1
  for i in range(len(hash_arr)):
    if hash_arr[i] == 1:
      return i
  return -1
print(appear_once([1,1,3,3,2,4,4]))
  
# method 3 : better solution, using unorderd_map
'''
steps
- take an empty hash map  {}
- iterate over the array with i till n and increment the values inside the hash map by 1
- iterate over the hash array map with i and check if anyone value is 1. if true return the key


TC - 

SC - 
'''
def appear_once(arr):
  unordered_map = {}
  for i in range(len(arr)):
    unordered_map[arr[i]] = unordered_map.get(arr[i],0) + 1
  for k,v in unordered_map.items():
    if v == 1:
      return k  
  return -1
print(appear_once([1,1,3,3,2,4,4]))

# method 4 : optimal solution, using XOR, 
'''
steps
- take a variable xor = 0
- iterate over the array with i till n and xor = xor ^ arr[i]
- return xor

TC - O(N)

SC - O(1)
'''
def appear_once(arr):
  xor = 0
  for i in range(len(arr)):
    xor = xor ^ arr[i]
  return xor
print(appear_once([1,1,3,3,2,4,4]))

# 13 TODO : longest subarray with given sum K (positives) ğŸ¤¯ğŸ¤¯ğŸ¤¯
"""
[
using three for loops,
using two for loops,
using prefix sum, 
using two pointers
]
"""
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡
â­â­â­
ğŸ˜ğŸ˜ğŸ˜

https://takeuforward.org/data-structure/longest-subarray-with-given-sum-k/

https://www.youtube.com/watch?v=frf7qxiN2qU&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=20
https://www.youtube.com/watch?v=KDH4mhFVvHw

https://practice.geeksforgeeks.org/problems/longest-sub-array-with-sum-k0809/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=longest-sub-array-with-sum-k

NOTE:
subarray - contigious part of the array

''' 
# method 1 : brute force
'''
steps
- take a variable length = 0
- iterate over the array with i till n
- iterate an inner loop with j from i till n
- take total_sum = 0
- iterate over the array with k from i till j and add all elements in each iteration and assign it to total_sum
- check if total_sum == target if true then update length = max(length, j-i+1)
- return length

TC - O(N^3)

SC - O(1)

'''
def sub_array(arr, target):
  length = 0
  for i in range(len(arr)):
    for j in range(i,len(arr)):
      total_sum = 0
      for k in range(i, j+1):
        total_sum = total_sum + arr[k]
      if total_sum == target:
        length = max(length, j-i+1)
  return length
print(sub_array([1,2,3,1,1,1,1,4,2,3], 3))              # Output - 3

# method 2 : brute force solution
'''
steps
- take a variable length = 0
- iterate over the array with i till n
- take total_sum = 0
- iterate an inner loop with j from i till n and add all elements in each iteration and assign it to total_sum
- check if total_sum == target if true then update length = max(length, j-i+1)
- return length

TC - O(N^2)

SC - O(i)
'''
def sub_array(arr, target):
  length = 0
  for i in range(len(arr)):
    total_sum = 0
    for j in range(i,len(arr)):
      total_sum = total_sum + arr[j]
      if total_sum == target:
        length = max(length, j-i+1)
  return length
print(sub_array([1,2,3,1,1,1,1,4,2,3], 3))              # Output - 3

# - method 3 : better solution, using prefix sum 
'''
steps

âŒâŒâŒâŒ NOT UNDERSTAND âŒâŒâŒâŒâŒ

TC - O(N)

SC - O(N)
'''
def sub_array(arr, target):
  n = len(arr)
  preSumMap = {}  # Dictionary to store the first occurrence index of each prefix sum {sum, index}
  curr_sum = 0    # Current prefix sum
  maxLen = 0      # Maximum length of subarray found

  for i in range(n):
    curr_sum += arr[i]

    # Case 1: If current sum is equal to the target, update maxLen
    if curr_sum == target:
      maxLen = i + 1

    # Case 2: Check if there is a subarray (ending at i) with the required sum
    remainder = curr_sum - target
    if remainder in preSumMap:
      length = i - preSumMap[remainder]
      maxLen = max(maxLen, length)

    # Store current sum only if it's not already in map (to keep the earliest index)
    if curr_sum not in preSumMap:
      preSumMap[curr_sum] = i

  return maxLen

# Test the function
print(sub_array([1, 2, 3, 1, 1, 1, 1, 4, 2, 3], 3))           # Output - 3


# - method 4 : optimal solution, using two pointers ğŸ¤¯ğŸ¤¯ğŸ¤¯ğŸ¤¯
'''
steps
- take a variable left = 0, right = 0, sum = 0, maxLen = 0
- iterate over the array with right till n
- check if sum > target then sum = sum - arr[left] and left = left + 1
- check if sum == target then maxLen = max(maxLen, right-left+1)
- right = right + 1
- check if right < n then sum
- return maxLen

TC - O(2*N), outer while will iterate for N times, but the inner loop doesnot run every time for each outer iteration. Some times it will iterate 2,3,or 4 times but sometime it will not run. so the inner iterations will will be added not multiplied.

SC - O(1)

'''
def sub_array(arr, target):
  n  = len(arr)
  left, right = 0,0
  sum = 0
  maxLen = 0
  while right < n:
    # Shrink the window from the left if the sum exceeds the target
    while sum > target:
      sum -= arr[left]
      left += 1
    # Check if the current sum matches the target, update maxLen if so
    if sum == target:
      maxLen = max(maxLen, right-left+1)
    right += 1          # Expand the window by moving right pointer to the right
    # Add the new right element to sum if right pointer is still inside the array
    if right < n:
      sum += arr[right]
  return maxLen
print(sub_array([1,2,3,1,1,1,1,4,2,3], 3))                # Output - 3

# 

# 14 TODO : longest subarray with given sum K (positives and negatives)
"""
[
using three nested for loops,
using two nested for loops,
using prefix sum
]
"""
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ 


https://takeuforward.org/arrays/longest-subarray-with-sum-k-postives-and-negatives/

https://www.youtube.com/watch?v=frf7qxiN2qU&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=20
https://www.youtube.com/watch?v=KDH4mhFVvHw

https://practice.geeksforgeeks.org/problems/longest-sub-array-with-sum-k0809/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=longest-sub-array-with-sum-k

'''
# method 1 : brute force
'''
TC - O(N^3)

SC - O(1)

'''
def sub_array(arr, target):
  length = 0
  for i in range(len(arr)):
    for j in range(i,len(arr)):
      total_sum = 0
      for k in range(i, j+1):
        total_sum = total_sum + arr[k]
      if total_sum == target:
        length = max(length, j-i+1)
  return length
print(sub_array([1,-2,-3,1,1,-1,1,4,2,3], 3))                 # Output - 8

# method 2 : better approch
'''
TC - O(N^2)

SC - O(1)
'''
def sub_array(arr, target):
  length = 0
  for i in range(len(arr)):
    for j in range(i,len(arr)):
      total_sum = 0
      for k in range(i, j+1):
        total_sum = total_sum + arr[k]
      if total_sum == target:
        length = max(length, j-i+1)
  return length
print(sub_array([1,-2,-3,1,1,-1,1,4,2,3], 3))                 # Output - 8

# method 3 : optimal approch, using hashing
'''

TC - O(N)

SC - O(N)
'''
def sub_array(arr, target):
  n  = len(arr)
  preSumMap = {}
  sum = 0
  maxLen = 0
  for i in range(n):
    sum += arr[i]
    if sum == target:
      maxLen = max(maxLen, i+1)
    rem  = sum - target
    if rem in preSumMap:
      length = i - preSumMap[rem]
      maxLen = max(maxLen, length)
    if sum not in preSumMap:
      preSumMap[sum] = i
  return maxLen
print(sub_array([1,-2,-3,1,1,-1,1,4,2,3], 3))                 # Output - 8


# endregion




# region 3.2 ARRAYS - MEDIUM
# --------------------------

# 1 TODO : two sum problem : check if a pair with given sum exists in Array
"""
[
using two nested for loops,
using a hash map,
using two pointers
]
"""
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

https://takeuforward.org/data-structure/two-sum-check-if-a-pair-with-given-sum-exists-in-array/

https://www.youtube.com/watch?v=UXDSeD9mN-k&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=21

https://leetcode.com/problems/two-sum/

'''
# - method 1 : brute force, 
'''
steps
- iterate over the array with i till n
- iterate an inner loop with j from i till n
- check if arr[i]+arr[j] == target if true then return [i,j]
- return [-1,-1]

TC - O(N^2)

SC - O(1)
'''
def two_sum(arr, target):
  for i in range(len(arr)):
    for j in range(i,len(arr)):
      if arr[i]+arr[j] == target:
        return [i,j]
  return [-1,-1]
print(two_sum([2,6,5,8,11], 14))                  # Output - [1, 3]


# method 2 : better solution, using hash map, 
''' 
steps
- create a empty hash map
- iterate over the array with i till n
- check if target - arr[i] in hash map if true then return [hash[target-arr[i]], i]
- hash[arr[i]] = i


TC - O(N*log(N)), using iteration and hash map

SC - O(N), storing elements in the map
'''
def two_sum(arr, target):
    hash = {}
    for i in range(len(arr)):
        num = arr[i]
        more_needed = target - num
        if more_needed in hash:
            return [hash[more_needed], i]
        hash[num] = i 
    return [-1, -1]

print(two_sum([2, 7, 11, 15], 9))  # Output: [0, 1]


# method 3 : optimal solution, using two pointer, 
'''
steps
- take two pointers left_ptr = 0, right_ptr = n-1
- sort the array
- iterate over the array with i till n using while loop
- check if arr[left_ptr] + arr[right_ptr] == target if true then return [left_ptr, right_ptr]
- check if arr[left_ptr] + arr[right_ptr] < target if true then left_ptr = left_ptr + 1
- check if arr[left_ptr] + arr[right_ptr] > target if true then right_ptr = right_ptr - 1
- return [-1,-1]

TC - O(N) + O(N*log(N)), iteration + sorting

SC - O(1)
'''
def two_sum(arr, target):
  left_ptr = 0
  right_ptr = len(arr) -1
  arr.sort()
  while left_ptr < right_ptr:
    total_sum = arr[left_ptr] + arr[right_ptr] 
    if total_sum == target:
      return [left_ptr, right_ptr]
    if total_sum < target:
      left_ptr= left_ptr + 1
    else:
      right_ptr = right_ptr - 1 
    
print(two_sum([2,6,5,8,11], 14))

# 


# 2 TODO : sort an array of 0's, 1's and 2's
"""
[
using built-in method sort(), 
using counters and for loop,
using object with key 0,1,2,
using dutch national flag algorithm
]
"""
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡
ğŸ˜ğŸ˜ğŸ˜
â­â­â­


https://takeuforward.org/data-structure/sort-an-array-of-0s-1s-and-2s/

https://www.youtube.com/watch?v=tp8JIuCXBaU&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=22


https://leetcode.com/problems/sort-colors/

'''
# - method 1 : brute force, using any sorting technique, TC - O(N*log(N)), SC - O(1)

# - method 2 : better approch
'''
steps
- take variables count0, count1, count2
- iterate over the array with i
- check if arr[i] == 0 then count0 = count0 + 1
- check if arr[i] == 1 then count1 = count1 + 1
- check if arr[i] == 2 then count
- return [0]*count0 + [1]*count1 + [2]*count2

TC - O(N) 

SC - O(1)  
'''
def sort(arr):
  count0 = 0
  count1 = 0
  count2 = 0
  for i in arr:
    if i == 0:
      count0 = count0 + 1 
    elif i == 1:
      count1 = count1 + 1
    else:
      count2 = count2 + 1
  return [0]*count0 + [1]*count1 + [2]*count2
print(sort([0,1,2,0,0,2,2,0,1,1,1,0]))                          # Output - [0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2]

# method 3 : better approch
'''
steps
- take an empty dict
- iterate over the array with i
- check if arr[i] == 0 then dict[0] = dict.get(0, 0) + 1
- check if arr[i] == 1 then dict[1] = dict.get(1, 0) + 1
- check if arr[i] == 2 then dict[2] = dict.get(2, 0) + 1
- return [0]*dict[0] + [1]*dict[1] + [2]*dict[2]

'''
def sort(arr):
  dict = {}
  for i in arr:
    if i == 0:
      dict[0] = dict.get(0, 0) + 1
    elif i == 1:
      dict[1] = dict.get(1, 0) + 1
    else:
      dict[2] = dict.get(2, 0) + 1
  return [0]*dict[0] + [1]*dict[1] + [2]*dict[2]
print(sort([0,1,2,0,0,2,2,0,1,1,1,0]))                          # Output - [0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2]

# - method 4 : optimal solution, Dutch National flag algorithm, TC - O(N), SC - (1) ğŸ¤¯ğŸ¤¯ğŸ¤¯
'''
steps
- take three pointers low = 0, mid = 0, high = n-1
- iterate over the array using while where mid <= high
- check if arr[mid] == 0 then swap arr[low] and arr[mid] and increment low and mid
- check if arr[mid] == 1 then increment mid
- check if arr[mid] == 2 then swap arr[high] and arr[mid] and decrement high
- return arr


RULES OF DUTCH NATIONAL FLAG ALGORITHM
1. All elements < pivot must be in the left partition. O -> low-1 => 0
2. All elements > pivot must be in the right partition. low -> mid-1 => 1
3. Elements equal to pivot can go either way. mid+1 -> high => 2



Time Complexity: O(n)

Space Complexity: O(1)
'''
def sort(arr):
    low = 0
    mid = 0
    high = len(arr) - 1
    while mid <= high:
        if arr[mid] == 0:
            arr[low], arr[mid] = arr[mid], arr[low] 
            low += 1
            mid += 1
        elif arr[mid] == 1:
            mid += 1  
        else:  
            arr[high], arr[mid] = arr[mid], arr[high] 
            high -= 1 
    return arr
print(sort([0,1,2,0,0,2,2,0,1,1,1,0]))                          # Output - [0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2]

# 

# 3 TODO : find the majority element that occurs more than >n/2 times
"""
[
using nested for loops,
using hash map,
using Moore's Voting Algorithm
]
"""
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢
ğŸ˜ğŸ˜ğŸ˜
â­â­â­

https://takeuforward.org/data-structure/find-the-majority-element-that-occurs-more-than-n-2-times/

https://www.youtube.com/watch?v=nP_ns3uSh80&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=23


https://leetcode.com/problems/majority-element/

'''
# - method 1 : brute force, 
'''
steps
- iterate over the array with i
- take a variable count = 0
- iterate over the array with j
- check if arr[i] == arr[j] then count = count + 1
- check if count > n/2 then return count
- return -1

TC - O(N)

SC - O(1)
'''
def sort(arr):
  for i in range(len(arr)):
    count = 0
    for j in range(len(arr)):
      if arr[i] == arr[j]:
        count +=1
    if count > (len(arr)/2):
      return count
  return -1
print(sort([2,2,1,4,2,2,3]))            # Output - 2

# - method 2 : better solution, using hashing, 
'''
steps
- take an empty dict
- iterate over the dict  with k, v
- check if v > n/2 then return v
- return -1

TC - O(N*log(N)) + O(N)

SC - O(N)
'''
def sort(arr):
  dict = {}
  for i in arr:
    dict[i] = dict.get(i,0) + 1
  for k,v in dict.items():
    if v > (len(arr)//2):
      return v 
  return -1
print(sort([2,2,1,4,2,2,3]))            # Output - 2

# - method 3 : better solution, using Counter, TC - O(N*log(N)) + O(N), SC - O(N)
# from collections import Counter
# def sort(arr):
#   counter = Counter(arr)
#   for k,v in dict.items():
#     if v > (len(arr)//2):
#       return v 
#   return -1
# print(sort([2,2,1,4,2,2,3]))

# - method 3 : optimal solution, using Moore's voting algorithm,
'''
steps
- take a variable el = None and count = 0
- iterate over the array with i
- check if count == 0 then el = arr[i] and count = 1
- check if el == arr[i] then count = count + 1
- else count = count - 1
- count = arr.count(el)
- check if count > n/2 then return el
- return -1


MOORE's VOTING ALGORITHM, it states that if an element occurs more than n/2 times in the array then it is the majority element.

NOTE: increment the counter if the same number arises again, decrement if another number arises. If the counter becomes 0, again increment counter for the current number.

TC: O(N)

SC: O(1)

'''
def moores_voting_algorithm(arr):
    el = None
    count = 0
    for i in range(len(arr)):
        if count == 0:
            el = arr[i]
            count = 1
        elif el == arr[i]:
            count += 1
        else:
            count -= 1
    count = arr.count(el)
    if count > len(arr) // 2:
        return el
    return None
arr = [2, 2, 1, 4, 2, 2, 3]
print(moores_voting_algorithm(arr))               # Output - 2

# 

# 4 TODO : Kadane's algorithm, find mximum subarray sum in an array
"""
[
using three nested for loops, 
using two nested for loops,
using kadane's algorithm,
]
"""
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/data-structure/kadanes-algorithm-maximum-subarray-sum-in-an-array/

https://www.youtube.com/watch?v=AHZpyENo7k4&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=24

https://leetcode.com/problems/maximum-subarray/


KANDANE's ALGORITHM - it states that if the sum of the array is negative then we will not consider the sum of the array and will start the sum from the next element.
- 
'''
# - method 1 : brute force, 
'''
steps
- take a variable previous_sum = -infinity
- iterate over the array with i
- iterate inner loop over the array with j
- take a variable sum = 0
- iterate another inner loop over the array with k from i to j
- sum = sum + arr[k]
- previous_sum = max(previous_sum,sum)
- return previous_sum

TC - O(N^3)

SC - O(1)
'''
def kandane_algo(arr):
  previous_sum = float('-inf')
  for i in range(len(arr)):
    for j in range(i, len(arr)):
      sum = 0
      for k in range(i,j):
        sum +=arr[k]
        previous_sum = max(previous_sum,sum)
  return previous_sum
arr = [2, -3, 4, -1, -2, 1, 5, -3]
print(kandane_algo(arr))                             # Output - 7


# - method 2 : better solution, 
'''
steps
- take a variable previous_sum = -infinity
- iterate over the array with i
- take a variable sum = 0
- iterate inner loop over the array with j
- sum = sum + arr[j]
- previous_sum = max(previous_sum
- return previous_sum

time complexity O(n)
'''
def kandane_algo(arr):
  previous_sum = float('-inf')
  for i in range(len(arr)):
    sum = 0
    for j in range(i, len(arr)):
      sum +=arr[j]
      previous_sum = max(previous_sum,sum)
  return previous_sum
arr = [2, -3, 4, -1, -2, 1, 5, -3]
print(kandane_algo(arr))                             # Output - 7

# - method 3 : optimal solution, using Kandane's algo
'''

steps
- take a variable current_max = float('-inf')
- take a variable max_sum = 0
- iterate over the array with i till n
- current_max = max(current_max, current_max + arr[i])
- max_sum = max(max_sum, current_max)
- return max_sum

KADANE'S ALORITHM - it states that if the sum of the array is negative then we will not consider the sum of the array and will start the sum from the next element.

TC: O(n)

SC: O(1)

'''
# below function is also right using chatgpt
# def kadane_algorithm(arr):
#     current_max = float('-inf')
#     max_sum = 0
#     for i in range(len(arr)):
#         current_max = max(current_max, current_max + arr[i])        
#         max_sum = max(max_sum, current_max)
#     return max_sum

def kadane_algorithm(arr):
  maxi = float('-inf')
  sum = 0
  for i in range(len(arr)):
    sum += arr[i]
    # if the sum is positive, update maxi
    if sum > maxi:
      maxi = sum
    # if the sum is negative, reset it to 0
    if sum < 0:
      sum = 0
  return maxi
arr = [2, -3, 4, -1, -2, 1, 5, -3]
print(kadane_algorithm(arr))                               # Output - 7

# 

# 5 TODO : print subarray with maximum sum (extended version of kadane's algorithm, for printing and finding the sub array)
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡
â­â­â­
ğŸ˜ğŸ˜ğŸ˜

https://takeuforward.org/data-structure/kadanes-algorithm-maximum-subarray-sum-in-an-array/

https://www.youtube.com/watch?v=AHZpyENo7k4&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=24

https://bit.ly/3SLFFhs

'''
# - method 1 : brute force,

# - method 2 : better solution, 

# - method 3 : optimal solution, using Kandane'algo, 
'''
steps
- take a variable maxi = float('-inf')
- take a variable sum = 0, start = 0, ansStart = -1, ansEnd = -1
- iterate over the array with i till n
- if sum == 0 then start = i
- sum = sum + arr[i] 
- if sum > maxi then maxi = sum, ansStart = start, ansEnd = i
- if sum < 0 then sum = 0
- print the subarray from ansStart to ansEnd
- return maxi

TC -O(N) 

SC - (1)
'''
def kadane_algorithm(arr):
    maxi = float('-inf')
    sum = 0
    start = 0
    ansStart, ansEnd = -1, -1
    for i in range(len(arr)):
        if sum == 0:
            start = i
        sum += arr[i]
        if sum > maxi:
            maxi = sum
            ansStart = start
            ansEnd = i
        if sum < 0:
          sum = 0
    for i in range(ansStart, ansEnd + 1):
      print(arr[i], end=" ")
    return maxi
arr = [-2,1,-3,4,-1,2,1,-5,4]
print(kadane_algorithm(arr))                            # Output = 7


# 6 TODO : stock buy and sell
"""
[
using two for loops,
using one for loop,
]
"""
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢
ğŸ˜ğŸ˜ğŸ˜

https://takeuforward.org/data-structure/stock-buy-and-sell/

https://www.youtube.com/watch?v=excAOvwF_Wk&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=25

https://leetcode.com/problems/best-time-to-buy-and-sell-stock/

'''
# - method 1 : brute force
'''

TC - O(N^2)

SC - (1)

'''
def buy_sell(arr):
  max_profit = 0  # Initialize max profit

  # Check all pairs (i < j) where we buy at i and sell at j
  for i in range(len(arr)):
    for j in range(i + 1, len(arr)):
      if arr[j] > arr[i]:  # Only consider if selling price is higher
        profit = arr[j] - arr[i]  # Calculate profit
        max_profit = max(max_profit, profit)  # Update max profit if this is better

  return max_profit

arr = [7, 1, 5, 3, 6, 4]
print(buy_sell(arr))  # Output: 5 (Buy at 1, sell at 6)


# - method 2 : better solution, 



# - method 3 : optimal solution
'''

TC: O(n)

SC: O(1)

'''
def buy_sell(arr):
  min_price = arr[0]  # Start by assuming the first day's price is the minimum
  profit = 0          # Max profit found so far

  # Start from the second day (index 1) because we already took day 0 as min_price
  for i in range(1, len(arr)):
    cost = arr[i] - min_price          # Profit if we bought at min_price and sold today
    profit = max(profit, cost)         # Update max profit if today's profit is better
    min_price = min(min_price, arr[i]) # Update min_price if today's price is lower
  return profit

arr = [7, 1, 5, 3, 6, 4]
print(buy_sell(arr))  # Output: 5 (Buy at 1, sell at 6)

# 7 TODO : rearrange the array in alternating positive and negative items
"""
[
using two arrays and some for loops,
using one for loop,
]
"""
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

https://www.youtube.com/watch?v=h4aBagy4Uok&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=26

https://leetcode.com/problems/rearrange-array-elements-by-sign/

'''
# - method 1 : brute force
'''
steps
- take two empty array pos and neg
- iterate over the array with i till n
- if arr[i] >= 0 then append in pos array else append in neg array
- create an array result with same as given array length with zeros
- iterate over the positive array with i till n and append the values in result array with even indexes
- iterate over the negative array with i till n and append the values in result array with odd indexes
- return result


TC - O(N + N/2)

SC - O(N + N/2)

'''
def rearrange(arr):
  pos,neg = [],[]
  
  for i in arr:
    if i >= 0:
      pos.append(i)
    else:
      neg.append(i)
  result = [0] * len(arr)
  for i in range(len(pos)):
    result[2*i] = pos[i]
  for i in range(len(neg)):
    result[2*i+1] = neg[i]
  # for i in range(len(arr)//2):
  #   result[2*i] = pos[i]
  #   result[2*i+1] = neg[i]
  return result
arr = [3,1,-2,-5,2,-4]
print(rearrange(arr))                           # Output - [3, -2, 1, -5, 2, -4]

# - method 2 : better solution, time complexity O(n)

# - method 3 : optimal solution
'''
steps
- take two pointers posIndex and negIndex and assign 0 to both.
- create a hash array with the same length of the given array.
- iterate over the array with i till n
- if arr[i] >= 0 then hash[posIndex] = arr[i] and posIndex += 2
- else hash[negIndex] = arr[i] and negIndex += 2
- return hash


TC - O(N), iteration is done on the whole array

SC - (N), using an extra array

'''
def rearrange(arr):
  posIndex = 0
  negIndex=1
  res = [0]*len(arr)
  for i in range(len(arr)):
    if arr[i] < 0:
      res[negIndex] = arr[i]
      negIndex += 2 
    else:
      res[posIndex] = arr[i]
      posIndex +=2
  return res
arr = [3,1,-2,-5,2,-4]
print(rearrange(arr))                           # Output - [3, -2, 1, -5, 2, -4]


# ğŸ‘‰ğŸ‘‰ğŸ‘‰ TODO : rearrange the array in alternating positive and negative items (number of positives and negatives are not equal)
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

https://www.youtube.com/watch?v=h4aBagy4Uok&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=26

https://leetcode.com/problems/rearrange-array-elements-by-sign/

TC: O(n)m O(max(ps, neg)) = O(leftovers)

SC: (N), using an extra array

'''
# - method 1 : brute force, 
def rearrange(arr):
  pos, neg = [], []  # Separate arrays for positive and negative numbers

  # Split the original array into positives and negatives
  for i in arr:
    if i >= 0:
      pos.append(i)
    else:
      neg.append(i)

  res = [0] * len(arr)  # Final result array of the same length

  # Choose the smaller of the two to alternate first
  if len(pos) > len(neg):
    # Fill alternating positions with pos and neg
    for i in range(len(neg)):
      res[2 * i] = pos[i]
      res[2 * i + 1] = neg[i]
    # Add remaining positive elements at the end
    index = len(neg) * 2
    for i in range(len(neg), len(pos)):
      res[index] = pos[i]
      index += 1
  else:
    for i in range(len(pos)):
      res[2 * i] = pos[i]
      res[2 * i + 1] = neg[i]
    # Add remaining negative elements at the end
    index = len(pos) * 2
    for i in range(len(pos), len(neg)):
      res[index] = neg[i]
      index += 1

  return res

# Test case
arr = [3, 1, -2, -5, 2, -4, 4, 7]
print(rearrange(arr))



# - method 2 : better solution, 

# - method 3 : optimal solution,



# 8 TODO : next permutation - find the next lexiographically greater permutation 
"""
[
using recursion,
using two separate for loops
]
"""
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡
ğŸ˜ğŸ˜ğŸ˜
â­â­â­

https://www.youtube.com/watch?v=JDOXKqF60RQ&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=27

https://leetcode.com/problems/next-permutation/


'''
# - method 1 : brute force, 
'''
generate all permutations using recursion
linear search on that 
get the arrays

TC - O(N! * N)

SC - O(N)
'''
def linear_search(permutations, target):
    for i, perm in enumerate(permutations):
        if perm == target:
            return i  # return index if found
    return -1  # not found

def generate_permutations(arr):
    results = []
    def helper(start):
        # Base case: if start reaches the end, save a copy of arr
        if start == len(arr):
            results.append(arr.copy())
            return
        # Recursive case: swap each element from start to end and recurse
        for i in range(start, len(arr)):
            arr[start], arr[i] = arr[i], arr[start]  # swap
            helper(start + 1)                        # recurse for next position
            arr[start], arr[i] = arr[i], arr[start]  # swap back (backtrack)
    helper(0)  # start recursion from index 0
    return results
# - method 2 : better solution, using built in function



# - method 3 : optimal solution, 
'''
steps


TC - O(3*N)

SC - O(1)
'''
def next_permutation(arr):
  n = len(arr)
  ind = -1  # Index of the first element from the end where arr[i] < arr[i + 1]

  # Step 1: Find the first decreasing element from the right
  for i in range(n - 2, -1, -1):
    if arr[i] < arr[i + 1]:
      ind = i
      break

  # Step 2: If no such element is found, the array is in descending order
  if ind == -1:
    arr.reverse()  # So we just return the lowest possible order
    return arr

  # Step 3: Find the next bigger element from the right to swap with arr[ind]
  for i in range(n - 1, ind, -1):
    if arr[i] > arr[ind]:
      arr[i], arr[ind] = arr[ind], arr[i]
      break

  # Step 4: Reverse the subarray to the right of ind to get the smallest suffix
  arr[ind + 1:] = reversed(arr[ind + 1:])
  return arr

arr = [1, 3, 2]
print(next_permutation(arr))  # Output: [2, 1, 3]


# 9 TODO : leaders in array problem (every thing in the right should be smaller)
"""
[
using two nested for loops,
using one for loop
]

"""
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://www.youtube.com/watch?v=cHrH9CQ8pmY&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=28


https://bit.ly/3bZqbGc

leaders -> every item after that item in the right is smaller so that item is a leader

'''
# - method 1 : brute force, 
'''
steps
- take an empty array leaders
- iterate outer loop over the array with i till n
- take a variable leader and assign true to it
- iterate inner loop over the array with j from i+1 till n
- if arr[j] > arr[i] then leader = false
- if leader is true then append arr[i] to leaders
- return leaders

TC - O(N^2)

SC - O(N)
'''
def leaders(arr):
  leaders = []
  for i in range(len(arr)):
    leader = True
    for j in range(i+1,len(arr)):
      if arr[j] >arr[i]:
        leader = False
    if leader:
      leaders.append(arr[i])
  return leaders
arr = [10,22, 12,3,0,6]
print(leaders(arr))                         # Output - [22, 12, 6]


# - method 2 : better solution, time complexity O(n)

# - method 3 : optimal solution, 
'''
steps
- take an empty array leaders
- take a variable maximum and assign -inf to it
- iterate over the array with i from n-1 till 0
- if arr[i] > maximum then append arr[i] to leaders and assign arr[i] to maximum
- return leaders

TC - (N)

SC - (N)
'''
def leaders(arr):
  leaders = []
  maximum = float("-inf")
  for i in range(len(arr)-1, 0, -1):
    if arr[i] > maximum:
      maximum = arr[i]
      leaders.append(arr[i])
  return leaders
arr = [10,22, 12,3,0,6]
print(leaders(arr))                         # Output - [22, 12, 6]


# 10 TODO : longest consecutive sequence in an array
"""
[

]
"""
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

https://www.youtube.com/watch?v=oO5uLE7EUlM&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=29

https://leetcode.com/problems/longest-consecutive-sequence/solution/

'''

# - method 1 : brute force, 
'''
steps
linerar_search(arr, num) 
return true if value found in the arr else false
longest_consecutive_length(arr)
- take a variable longest_len and assign 1 to it
- iterate outer loop over the array with i till n
- take a variable x and assign arr[i] to it and a variable count and assign 1 to it
- take a while loop with condition linerar_search(arr, num), in each iteration increment x and count by 1
- update longest_len with max(longest_len, count)
- return longest_len


TC - O(N^2)

SC - O(1)
'''
def linear_search(arr, num):
  for i in range(len(arr)):
    if arr[i] == num:
      return True
  return False
def longest_consecutive_length(arr):
  longest_len = 1
  for i in range(len(arr)):
    x = arr[i]
    count = 1
    while linear_search(arr, x+1):
      x += 1
      count += 1
    longest_len = max(longest_len, count)
  return longest_len

arr = [100, 4, 200, 1, 3, 2]
print(longest_consecutive_length(arr))                # Output - 4

# - method 2 : better solution, using sorting
'''
steps
- check if it's not an empty array if so return 0
- sort the array using arr.sort()
- take 3 variable lastSmaller = float("-inf"), longest = 1, count = 0
- iterate over the array with i till n
- if arr[i] - 1 == lastSmaller then increment count by 1 and update lastSmaller to arr[i]
- if arr[i] != lastSmaller then assign count to 1 and update lastSmaller to arr[i]
- update longest with max(longest, count)
- return longest

TC - O(N*log(N)) + O(N), sorting + iteration

SC - O(1)
'''
def longest_consecutive_length(arr):
  if len(arr) == 0:
    return 0
  arr.sort()
  lastSmaller = float("-inf")
  longest = 1
  count = 0
  for i in range(len(arr)):
    if arr[i] - 1 == lastSmaller:
      count += 1
      lastSmaller = arr[i]
    elif arr[i] != lastSmaller:
      count = 1
      lastSmaller = arr[i]
    longest = max(longest, count)
  return longest
arr = [100, 4, 200, 1, 3, 2]
print(longest_consecutive_length(arr))

# ğŸ‘‰ğŸ‘‰ğŸ‘‰ using chatgpt
# '''
# steps
# - check if it's not an empty array if so return 0
# - first create set with the array and sort it using sorted(set(arr))
# - take 2 variables longest and  and assign 1 to both
# - iterate over the array with i from 1 till n
# - if arr[i] == arr[i-1] + 1 then increment count by 1 and longest with max(longest, count)
# - else assign count
# - return longest
# '''
# def longest_consecutive_length(arr):
#   if not arr:
#     return 0
#   arr = sorted(set(arr))  # Remove duplicates and sort
#   longest = 1
#   count = 1
#   for i in range(1, len(arr)):
#     if arr[i] == arr[i - 1] + 1:
#       count += 1
#       longest = max(longest, count)
#     else:
#       count = 1
#   return longest
# arr = [100, 4, 200, 1, 3, 2]
# print(longest_consecutive_length(arr))  # Output should be 4 (1, 2, 3, 4)

# - method 3 : optimal solution, using set()
'''
steps
- check if it's not an empty array if so return 0
- create a set with the given array
- take a variable longest_len and assign 0 to it
- iterate over the set
- if num - 1 not in set then start counting from the beginning of a sequence
- take a variable current_num and assign num to it and current_len and assign 1 to it
- while current num + 1 in set then increment current_num and current_len by 1
- update longest_len with max(longest_len, current_len)
- return longest_len

TC - O(N) + O(2*N) ~ O(3*N), for the set + iteration + while is not running full for all items

SC - O(N), for set
'''
def longest_consecutive_length(arr):
  if not arr:
    return 0
  num_set = set(arr)
  longest_len = 0
  for num in num_set:  # Slight optimization: iterate over set
    # Check if the current number is the start of a sequence
    # Only begin counting if num-1 is not in the set (i.e., it's the start)
    if num - 1 not in num_set: 
      current_num = num  # Start of a new sequence
      current_len = 1  # Current sequence length starts at 1
      # Continue checking for the next consecutive numbers
      while current_num + 1 in num_set:
        current_num += 1
        current_len += 1
      # Update the longest sequence length if the current one is longer
      longest_len = max(longest_len, current_len)
  return longest_len

# Example usage
arr = [100, 4, 200, 1, 3, 2]
print(longest_consecutive_length(arr))  # Output: 4

# 11 TODO : set matrix zeros vertically and horizontally of a 0
"""
[
making row and columnwith -1,
using extra row and column array and mark them.
using the first row and columnof same matrix
]
"""
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

https://www.youtube.com/watch?v=N0MgLvceX7M&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=30


https://leetcode.com/problems/set-matrix-zeroes/

'''
# - method 1 : brute force
'''
steps
- iterate over the 2D matrix with i and j till n and m
- if matrix[i][j] == 0 then mark_row(matrix, n, m, i) and mark_col(matrix, n, m, j) with -1
- iterate over the 2D matrix with i and j till n and m and change -1 to 0

TC - O((N*M)*(M*N)) +O(N*M), mark_row + mark_col + extra_iteration

SC - O(1)
'''

def set_zeros(matrix, n, m):
  for i in range(n):
    for j in range(m):
      if matrix[i][j] == 0:
        mark_row(matrix, n, m, i)
        mark_col(matrix, n, m, j)

  for i in range(n):
    for j in range(m):
      if matrix[i][j] == -1:
        matrix[i][j] = 0

  return matrix

def mark_row(matrix, n, m, i):
  for j in range(m):
    if matrix[i][j] != 0:
      matrix[i][j] = -1

def mark_col(matrix, n, m, j):
  for i in range(n):
    if matrix[i][j] != 0:
      matrix[i][j] = -1

# Test
arr = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]
n, m = len(arr), len(arr[0])
for row in set_zeros(arr, n, m):
  print(row)

# Output
# [1, 0, 1]
# [0, 0, 0]
# [1, 0, 1]



# - method 2 : better solution
'''
steps
- create 2 arrays row and col of size n and m and initialize with empty array of size n and m with 0's
- iterate over the 2D matrix with i and j till n and m
- if matrix[i][j] == 0 then mark row[i] = 1 and col[j] = 1
- iterate over the 2D matrix with i and j till n and m
- if row[i] or col[j] == 1 then matrix[i][j] = 0
- return matrix

TC - O(2*(N*M)), two separate iteration

SC - O(N) + O(M), rows arr + cols array
'''
def set_zeros(matrix, n,m):
  row = [0]*n
  col = [0]*m

  for i in range(n):
    for j in range(m):
      if matrix[i][j] == 0:
        row[i] = 1
        col[j] = 1
  for i in range(n):
    for j in range(m):
      if row[i] or col[j]:
        matrix[i][j] = 0
  return matrix

arr = [[1,1,1], [1,0,1], [1,1,1]]
n, m = len(arr), len(arr[0])
for i in set_zeros(arr, n, m) :
  print(i) 

# - method 3 : optimal solution,
'''
TC - O(2*(N*M))

SC - O(1)
'''
def set_zeros(matrix, n,m):
  # row = [0]*n  --> matrix[0][...]
  # col = [0]*m  --> matrix[...][0]
  col0 = 1
  for i in range(n):
    for j in range(m):
      if matrix[i][j] == 0:
        # mark the ith row
        matrix[i][0] = 0
        # mark the jth col
        if j != 0:
          matrix[0][j] = 0
        else:
          col0 = 0  # for 0th col
  for i in range(1, n):  # Skip row 0 (used for markers)
    for j in range(1, m):  # Skip col 0 (used for markers)
      if matrix[i][j] != 0:
        if matrix[i][0] == 0 or matrix[0][j] == 0:
          matrix[i][j] = 0  # Zero the cell if its row or col was marked
  # Check if the first row needs to be set to zero
  if matrix[0][0] == 0:
    for j in range(m):
      matrix[0][j] = 0
  # Check if the first column needs to be set to zero
  if col0 == 0:
    for i in range(n):
      matrix[i][0] = 0
  return matrix

arr = [[1,1,1], [1,0,1], [1,1,1]]
n, m = len(arr), len(arr[0])
for i in set_zeros(arr, n, m) :
  print(i) 


# 12 TODO : rotate matrix by 90 degrees
"""
using relation between i and j with matrix and rotated matrix,
first transpose the same matrix then reverse each row
"""
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://www.youtube.com/watch?v=Z0R2u6gd3GU&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=31

https://leetcode.com/problems/rotate-image/

'''
# - method 1 : brute force 
'''
steps
- create a new matrix of m*n size
- iterate over the matrix with i and j till n and m
- assign matrix[j][n-i-1] = matrix[i][j]
- return rotated

TC - O(N*N)

SC - O(N*N)
'''
def rotate_90(matrix, n,m):
  # creating a mtrix with 0 entries
  rotated = [[0 for _ in range(n)] for _ in range(m)]
  for i in range(n):
    for j in range(m):
      rotated[j][n-i-1] = matrix[i][j]
  return rotated

arr = [[1,1,1], [1,0,1], [1,1,1]]
n, m = len(arr), len(arr[0])
for i in rotate_90(arr, n, m) :
  print(i)                                                # Output - [[1, 1, 1],[1, 0, 1],[1, 1, 1]]

# - method 2 : better solution, time complexity O(n)

# - method 3 : optimal solution
'''
steps
- create a new matrix of n*m size
- iterate over the matrix with i and j till n and m
- swap the values matrix[i][j] with matrix[j][i]
- reverse the matrix with n (each row) axis
- return rotated

TC - O(N*N) + O(N*N)

SC - O(1))
'''
def rotate_90(matrix, n, m):
  # Step 1: Transpose the matrix (swap rows and columns)
  for i in range(n):
    for j in range(i + 1, m):  # j > i to avoid repeating swaps or hitting diagonal
      matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
  # Step 2: Reverse each row
  for i in range(n):
    matrix[i].reverse()
  return matrix

arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
n, m = len(arr), len(arr[0])
for row in rotate_90(arr, n, m):
  print(row)                                                 # Output - [[1, 1, 1],[1, 0, 1],[1, 1, 1]]

# 13 TODO : print the matrix in spiral manner
"""
using top, bottom, left, right variable and while loop and for loop
"""
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

https://www.youtube.com/watch?v=3Zv-s9UUrFM&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=32

https://takeuforward.org/data-structure/spiral-traversal-of-matrix/

https://leetcode.com/problems/spiral-matrix/

'''
# - method 1 : brute force
'''
steps
- take 5 variables top, bottom, left, right, and ans = []
- iterate using while loop till top <= bottom and left <= right
- iterate from left to right and append matrix[top][i] to ans
- increment top by 1
- iterate from top to bottom and append matrix[i][right] to ans
- decrement right by 1
- iterate from right to left and append matrix[bottom][i] to ans
- decrement bottom by 1
- iterate from bottom to top and append matrix[i][left] to ans
- increment left by 1
- return ans

TC - O(N*M)

SC - O(N*M)
'''
def spiral_matrix(matrix, n,m):
  ans = []
  top = 0
  bottom = n-1
  left = 0
  right = m-1
  while top <= bottom and left <= right:
    for i in range(left, right+1):
      ans.append(matrix[top][i])
    top += 1
    for i in range(top, bottom+1):
      ans.append(matrix[i][right])
    right -= 1
    if top <= bottom:  # Check if there are more rows to process
      for i in range(right, left-1, -1):
        ans.append(matrix[bottom][i])
      bottom -= 1
    if left <= right:  # Check if there are more columns to process
      for i in range(bottom, top-1, -1):
        ans.append(matrix[i][left])
      left += 1
    return ans

arr = [[1,2,3], [4,5,6], [7,8,9]]
n, m = len(arr), len(arr[0])
print(spiral_matrix(arr, n, m))                           # Output - [1, 2, 3, 6, 9, 8, 7, 4]

# - method 2 : better solution, time complexity O(n)

# - method 3 : optimal solution, time complexity O(n)


# 14 TODO : count subarrays with given sum
"""
using three for loops,
using two for loops,
using prefix sum
"""
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/arrays/count-subarray-sum-equals-k/

https://www.youtube.com/watch?v=xvNwoz-ufXA&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=33

https://leetcode.com/problems/subarray-sum-equals-k/

'''

# - method 1 : brute force
'''
steps
- take a variable count = 0
- iterate over the array with i till n
- iterate inner loop with j from i till n
- take a variable subarray_sum = sum(arr[i:j+1])
- if subarray_sum == sum increment count by 1
- return count

TC - O(N*N), two nested for loops and builtin sum()

SC - O(1)
'''
def find_subarrays(arr, target_sum):
  count = 0
  n = len(arr)
  for i in range(n):
    for j in range(i, n):
      subarray_sum = 0
      for k in range(i, j + 1):
        subarray_sum += arr[k]
      if subarray_sum == target_sum:
        count += 1
  return count

arr = [3, 1, 2, 4]
target_sum = 6
print(find_subarrays(arr, target_sum))  # Output: 2

# - method 2 : better solution
'''
steps
- take a variable count = 0
- iterate over the array with i till n
- take a variable subarray_sum = 0
- iterate inner loop with j from i till n
- take a variable subarray_sum = subarray_sum + arr[j]
- check if subarray_sum == sum increment count by 1
- return count

TC - O(N*N)

C - O(1)
'''
def find_subarrays(arr, sum):
  count = 0
  for i in range(len(arr)):
    subarray_sum = 0
    for j in range(i, len(arr)):
      subarray_sum += arr[j]
      if subarray_sum == sum:
        count += 1
  return count

arr = [3,1,2,4]
sum = 6
print(find_subarrays(arr, sum))

# - method 3 : optimal solution
'''
steps


TC - O(N) or O(N*log(N))

SC - O(N)
'''
from collections import defaultdict
def find_subarrays(arr, target):
  n = len(arr)
  prefix_sum_map = defaultdict(int)  # Stores frequency of prefix sums {current_sum,  count}
  current_sum = 0                    # Running prefix sum
  count = 0                          # Count of valid subarrays found
  prefix_sum_map[0] = 1  # Base case: one way to have a zero prefix sum

  for i in range(n):
      current_sum += arr[i]  # Update running prefix sum
      # Check if there's a prefix sum that when subtracted gives the target
      remainder = current_sum - target
      count += prefix_sum_map[remainder]  # Add number of times that remainder has occurred
      # Record the current prefix sum for future subarrays
      prefix_sum_map[current_sum] += 1

  return count

arr = [1,2,3,-3, 1,1,1,4,2,-3]
# arr = [3,-3,1,1,1]
sum = 3
print(find_subarrays(arr, sum))

# endregion




# region 3.1 ARRAYS - HARD
# ------------------------

# 1 TODO : pascal's triangle
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡
ğŸ˜ğŸ˜ğŸ˜

https://takeuforward.org/data-structure/program-to-generate-pascals-triangle/

https://www.youtube.com/watch?v=bR7mQgwQ_o8&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=34

https://leetcode.com/problems/pascals-triangle/

'''
'''
PASCAL's Triangle - A triangular array of the binomial coefficients.
eg -   1
      1 1
     1 2 1
    1 3 3 1
   1 4 6 4 1
  1 5 10 10 5 1
'''

'''
METHODS :
using formulae nCr = n! / (r! * (n-r)!),
optimizing factorial calculation,




VARIATION 1 : In this case, we are given row number r and column number c, and we need to find the element at position (r, c).
'''
# - method 1 : brute force
'''
formulae, nCr = n! / (r! * (n-r)!)
where n is the row number and r is the column number.

steps
- create a function for calculating factorial of a number
- create a function to implement the above formulae
- return the answer

TC: 

SC: 

'''
def nCr(n,r):
  res = factorial(n) // (factorial(r) * factorial(n-r))
  return res

def factorial(n):
  if n == 0:
    return 1
  return n * factorial(n-1)

def pascal_triangle(r,c):
  element = nCr(r-1,c-1)
  return element

r,c = 5,3
print(pascal_triangle(r,c))                     # Output - 6


# - method 2 : better solution, 

# - method 3 : optimal solution
'''
7C2 -> (7*6)/(2*1)  -> (7//1)*(6//2) -> 21
10C3 -> (10*9*8)/(3*2*1) -> (10//1)*(9//2)*(8//3) -> 120

TC - O(r)

SC - O(1)
'''
def nCr(n,r):
  res = 1
  for i in range(r):
    res = res * (n-i)   # i starts from 0, (n-i)-> 4, 3, 2
    res = res // (i+1)    # i starts from 0, (i+1) -> 1, 2, 3
  return res
def pascal_triangle(r,c):
  element = nCr(r-1,c-1) # indexing starts from 0 so decremented by 1
  return element

r,c = 5,3
print(pascal_triangle(r,c))                     # Output - 6

'''
METHODS :
using formulae nCr = n! / (r! * (n-r)!) as separate nested for loop,
using formulae nCr = n! / (r! * (n-r)!) an a for loop,



VARIATION 2 : Given the row number, print the n-th row of Pascalâ€™s triangle.
'''
# - method 1 : brute force
'''
- use function nCr(n,r) and iterate it inside for loop from 1 till n+1

TC - O(n*r)

SC - O(1)
'''
def nCr(n,r):
  res = 1
  for i in range(r):
    res = res * (n-i)
    res = res // (i+1)
  return res

def pascal_triangle(n):
  for c in range(1,n+1):    # 1 based indexing is important to follow for symmetry and understanding
    print(nCr(n-1,c-1), end=" ")
  print()

n = 5
print(pascal_triangle(n))                                 # Output - 1 4 6 4 1 

# - method 2 : better solution, time complexity O(n)

# - method 3 : optimal solution
'''
ans = ans * ((row - col) / col)


TC - O(N)

SC - O(1)
'''
def pascal_triangle(n):
  ans = 1
  print(ans, end=" ")
  for i in range(1,n):
    ans = ans * (n - i)
    ans = ans // i
    print(ans, end=" ")

n = 5
print(pascal_triangle(n))                                 # Output - 1 4 6 4 1 

'''
METHODS :
using formulae nCr = n! / (r! * (n-r)!) in three for loops,
using previous optimized solution,




VARIATION 3 : Given the row number, print the whole pascal triangle
'''
# - method 1 : brute force
'''
- use the function nCr(n, r) in pascal_triangle(n)
pascal_triangle(n)
- create an empty array ans = []
- iterate with row from 1 till n+1
- create an empty array tenpList = []
- iterate with col from 1 till row+1
- append nCr(row-1,col-1) to tempList
- append tempList to ans
- return ans


TC - O(n*n*r) ~O(N*N*N)

SC - O(1)
'''
from typing import *

def nCr(n,r):
  res = 1
  for i in range(r):
    res = res * (n-i)
    res = res // (i+1)
  return int(res)

def pascal_triangle(n):
  ans =[]
  for row in range(1,n+1):
    tempList = []
    for col in range(1,row+1):
      tempList.append(nCr(row-1,col-1))
    ans.append(tempList)
  return ans

n = 5
print(pascal_triangle(n))                      # Output - [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]

# - method 2 : better solution, time complexity O(n)

# - method 3 : optimal solution, 
'''
- use previous variation of creating row and iterate it from i till n+1

TC - O(N*N)

SC - O(1)
'''
from typing import *
def generateRow(row):
  ans = 1
  ansRow = [1]
  for col in range(1, row):
    ans = ans * (row - col)
    ans = ans // col
    ansRow.append(ans)
  return ansRow

def pascal_triangle(n):
  ans =[]
  for row in range(1,n+1):
    ans.append(generateRow(row))
  return ans

n = 5
print(pascal_triangle(n))                    # Output - [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]

# 

# 2 TODO : majority element (>n/3 times)
"""
using two for loops,
using hash map and one for loop,
using Boyer Moore's majority voting algorithm
"""
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://takeuforward.org/data-structure/majority-elementsn-3-times-find-the-elements-that-appears-more-than-n-3-times-in-the-array/

https://www.youtube.com/watch?v=vwZj1K0e9U8&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=35

https://leetcode.com/problems/majority-element-ii/


'''

# - method 1 : brute force
'''
steps
- take an empty array ls = []
- iterate over the array till n
- if ls is empty or ls[0] value is not equal to arr[i], then proceed inside the condition
- take a cnt variable and initialize it to 0
- iterate over the array till n
- if arr[i] == arr[j], then increment the cnt
- if cnt > n/3, then append arr[i] to ls
- if len(ls) == 2, then break
- return ls

TC -O(N^2)

SC - O(1)
'''
def majority_element(arr):
  n = len(arr)
  ls = []
  for i in range(n):
    # Only check frequency if ls is empty or the current element is different from the first element in ls
    if len(ls) == 0 or ls[0] != arr[i]:
      cnt = 0   # Initialize counter for current element
      # Count how many times arr[i] appears in the array
      for j in range(n):
        if arr[i] == arr[j]:
          cnt += 1
      # If the count is greater than n//3, consider it a majority element and add to result list
      if cnt > (n//3):
        ls.append(arr[i])
    # At most two elements can appear more than n//3 times in an array
    if len(ls) == 2:
      break
  return ls

arr = [1,3,3,1,3,1,2,2]
print(majority_element(arr))                  # Output - [1, 3]

# - method 2 : better solution, using hashing
# from collections import Counter
# def majority_element(arr):
#   n = len(arr)
#   counter = Counter(arr)
#   for num,count in counter.items():
#     if count > (n//3):
#       return num
#   return -1

# - method 3 : better solution, using hashing
'''
steps
- take minimum count as n/3 + 1
- take a map mpp to store the count of element and lst to store the majority elements
- iterate over the array and store the count of each element in mpp
- check if the count of element is greater than the minimum count, if true then insert into the list
- return ls

TC - O(N*log(N))

SC - O(N)
'''
def majority_element(arr):
  min = len(arr)//3 + 1
  ls  = []
  mpp = {}
  for i in range(len(arr)):
    mpp[arr[i]] = mpp.get(arr[i], 0) + 1
    if mpp[arr[i]] == min:
      ls.append(arr[i])
  return ls

arr = [1,3,3,1,3,1]
print(majority_element(arr))

# - method 3 : optimal solution, using Boyer Moore's majority voting algorithm
'''
steps
- take cnt1, cnt2, el1, el2
- iterate over the array till n
- if cnt1 == 0 and el2 != arr[i], then cnt1 = 1, el1 = arr[i]
- elif cnt2 == 0 and el1 != arr[i], then cnt2 = 1, el2 = arr[i]
- elif arr[i] == el1, then cnt1 += 1
- elif arr[i] == el2, then cnt2 += 1
- else, cnt1 -= 1, cnt2 -= 1

# for manual check
- take cnt1, cnt2, ls = []
- iterate over the array till n
- if arr[i] == el1, then cnt1 += 1
- if arr[i] == el2, then cnt2 += 1
- mini = int(n/3) + 1
- if cnt1 >= mini, then append el1 to ls
- if cnt2 >= mini, then append el2 to ls
- return ls



TC - O(N) + O(N)

SC - O(1)
'''
from collections import Counter
def majority_element(arr):
  n = len(arr)
  cnt1,cnt2 = 0,0
  el1,el2 = float('-inf'),float('-inf')
  for i in range(n):
    if cnt1 == 0 and el2 != arr[i]:
      cnt1 = 1
      el1 = arr[i]
    elif cnt2 == 0 and el1 != arr[i]:
      cnt2 = 1
      el2 = arr[i]
    elif arr[i] == el1:
      cnt1 += 1
    elif arr[i] == el2:
      cnt2 += 1
    else:
      cnt1 -= 1
      cnt2 -= 1

  # manual check weather the values are correct or not
  ls = []
  cnt1,cnt2 = 0,0
  for i in range(n):
    if arr[i] == el1:
      cnt1 += 1
    if arr[i] == el2:
      cnt2 += 1
  mini = int(n/3) + 1
  if cnt1 >= mini:
    ls.append(el1)
  if cnt2 >= mini:
    ls.append(el2)
  return ls

arr = [1,3,3,1,3,1]
print(majority_element(arr))

# 


# 3 TODO : 3-sum problem - find triplets that add up to a zero, (arr[i] + arr[j] + arr[k] == 0) and (i != j != k)
"""
using three for loops and set,
using two for loops and a set,
using one for loop and a while loop and two pointers
"""
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://takeuforward.org/data-structure/3-sum-find-triplets-that-add-up-to-a-zero/

https://www.youtube.com/watch?v=DhFh8Kw7ymk&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=36

https://leetcode.com/problems/3sum/


'''
# - method 1 : brute force
'''
steps
- take a set st
- iterate over the array with i till n
- iterate over the array with j from i+1 till n
- iterate over the array with k from j+1 till n
- if arr[i] + arr[j] + arr[k] == 0, then append the values to the set (after sort)
- return the list of set

TC - O(N*N*N*log(nos of unique triplets))

SC - O(2*nos of unique triplets)
'''
def triplet(n, arr):
  st = set()
  for i in range(n):
    for j in range(i+1,n):
      for k in range(j+1,n):      
        sum = arr[i] + arr[j] + arr[k]
        if sum == 0:
          temp = [arr[i],arr[j],arr[k]]
          temp.sort()
          st.add(tuple(temp))
  ans = [list(item) for item in st]
  return ans

arr = [-1,0,1,2,-1,-4]
n = len(arr)
print(triplet(n, arr))

# - method 2 : better solution, using hashing
'''
steps
- take a set st
- iterate over the array with i till n
- take a hashset = set()
- iterate over the array with j from i+1 till n
- take a third variable as third = -(arr[i] + arr[j])
- if third in hashset, then append the values to the set (after sort)
- add arr[j] to hashset
- return the list(st)

why wer using sort() we can easily compare arr[i] != arr[j] != arr[k] ??

TC - O(N*N*log(nos of unique triplets))

SC - O(2*nos of unique triplets)
'''
def triplet(n, arr):
  st = set()
  for i in range(n):
    hashset = set()
    for j in range(i+1,n):
      third = -(arr[i] + arr[j])
      if third in hashset:
        temp = [arr[i],arr[j],third]
        temp.sort()
        st.add(tuple(temp))
      hashset.add(arr[j])
  ans = list(st)
  return ans

arr = [-1,0,1,2,-1,-4]
n = len(arr)
print(triplet(n, arr))

# - method 3 : optimal solution using two pointers 
'''
steps
- take an empty arr ans = []
- sort the given array using sort()
- iterate over the arr with i till n
- check for i continue if it is the same element like i!=0 and arr[i]==arr[i-1]
- take two variables j = i+1 and k = n-1
- iterate using while loop with condition j < k
- take the sum = arr[i] + arr[j] + arr[k]
- if sum < 0 then j = j+1 else if sum > 0 k= k-1 else append (arr[i] + arr[j] + arr[k]) in ans increment j and decrement k by 1
- in the same else use while loops for j and k top point another value which is not same as previous

TC - O(N*log(N)) + O(N*N), sort() + for()*while()

SC - O(nos of triplets)
'''
def triplet(n, arr):
  # st = set()
  ans = []
  arr.sort()
  for i in range(n):
    # Skip duplicates for the first element of the triplet
    if i != 0 and arr[i] == arr[i-1]:
      continue

    # Two pointers
    j = i + 1  # Start pointer just after i
    k = n - 1  # End pointer at the last element
    while j < k:
      total = arr[i] + arr[j] + arr[k]  # Calculate the sum of the triplet
      if total < 0:
        j += 1  # Move the left pointer right to increase the sum
      elif total > 0:
        k -= 1  # Move the right pointer left to decrease the sum
      else:
        # Found a triplet with sum == 0
        temp = [arr[i], arr[j], arr[k]]
        ans.append(temp)
        # Move both pointers to look for new pairs
        j += 1
        k -= 1
        # Skip duplicates for the second number
        while j < k and arr[j] == arr[j - 1]:
          j += 1
        # Skip duplicates for the third number
        while j < k and arr[k] == arr[k + 1]:
          k -= 1
  return ans

arr = [-1,0,1,2,-1,-4]
n = len(arr)
print(triplet(n, arr))

# 


# 4 TODO : 4-sum problem, quardupulets that add up to a k, (arr[i] + arr[j] + arr[k] + arr[l] == k) and (i != j != k != l)
"""
using four for loops,
using three for loops,
using two for loops and a while loop and two pointers,
"""
'''
ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/data-structure/4-sum-find-quads-that-add-up-to-a-target-value/

https://www.youtube.com/watch?v=DhFh8Kw7ymk&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=37

https://leetcode.com/problems/4sum/

'''
# - method 1 : brute force
'''
steps
- take a set st
- iterate over the array with i till n
- iterate over the array with j from i+1 till n
- iterate over the array with k from j+1 till n
-  iterate over the array with l from k+1 till n
- if arr[i] + arr[j] + arr[k] + arr[l] == 0, then append the values to the set (after sort)
- return the list of set

TC - O(N*N*N*N)

SC - O(2*nos of quadruplets)
'''
from collections import deque
def fourSum(nums, target):
  n = len(nums)
  st = set()
  for i in range(n):
    for j in range(i+1,n):
      for k in range(j+1,n):
        for l in range(k+1,n):
          sum = num[i] + sum[j] + sum[k] + sum[l]
          if sum == target:
            temp = [num[i],num[j],num[k],num[l]]
            temp.sort()
            st.add(tuple(temp))
  ans = [list(item) for item in st]
  return ans

arr = [4,3,3,4,4,2,1,2,1,1]
target = 9
print(fourSum(arr, target))

# - method 2 : better solution, using hashing
'''
steps
- take a set st
- iterate over the array with i till n
- iterate over the array with j from i+1 till n
- take a hashset = set()
- iterate over the array with k from j+1 till n
- take a forth variable as fourth = target - (nums[i] + nums[j] + nums[k])
- if fourth in hashset, then append the values to the set (after sort)
- add arr[k] to hashset
- return the [list(item) for item in st]


TC - O(N*N*log(nos of unique triplets))

SC - O(2*nos of unique triplets) + O(N)
'''
import itertools
def fourSum(nums, target):
  n = len(nums)
  st = set()
  for i in range(n):
    for j in range(i+1,n):
      hashset = set()
      for k in range(j+1,n):
        sum_ = nums[i] + nums[j] + nums[k]
        fourth = target - sum_
        if fourth in hashset:
          temp = [nums[i],nums[j],nums[k],fourth]
          temp.sort()
          st.add(tuple(temp))
        hashset.add(nums[k])
  ans = [list(item) for item in st]
  return ans

arr = [4,3,3,4,4,2,1,2,1,1]
target = 9
print(fourSum(arr, target))

# - method 3 : optimal solution
'''
steps
- take an empty arr ans = []
- sort the given array using sort()
- iterate over the arr with i till n
- check for i continue if it is the same element like i!=0 and arr[i]==arr[i-1]
- iterate over the arr with j till n
- check for j continue if it is the same element like j!=0 and arr[j]==arr[j-1]
- take two variables k = j+1 and l = n-1
- iterate using while loop with condition k < l
- take the sum = nums[i] + nums[j] + nums[k] + nums[l]
- if sum < target then k = k+1 else if sum > 0 l = l-1 else append (arr[i] + arr[j] + arr[k]) in ans increment k and decrement l by 1
- in the same else use while loops for k and l to point another value which is not same as previous
- return ans

TC - O(N*N*N)

SC - O(nos of quadruplets)
'''
def fourSum(nums, target):
  n = len(nums)
  ans = []
  nums.sort()
  for i in range(n):
    if i > 0 and nums[i] == nums[i-1]:
      continue
    for j in range(i+1,n):
      if j > i+1 and nums[j] == nums[j-1]:
        continue
      k = j+1
      l = n-1
      while k < l:
        _sum = nums[i] + nums[j] + nums[k] + nums[l]
        if _sum < target:
          k += 1
        elif _sum > target:
          l -= 1
        else:
          temp = [nums[i],nums[j],nums[k],nums[l]]
          ans.append(temp)
          k += 1
          l -= 1
          while k < l and nums[k] == nums[k-1]:
            k += 1
          while k < l and nums[l] == nums[l+1]:
            l -= 1
  return ans

arr = [4,3,3,4,4,2,1,2,1,1]
target = 9
print(fourSum(arr, target))



# 5 TODO : largest subarray with sum = 0
"""
using two nested for loops,
using prefix sum
"""
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

https://takeuforward.org/data-structure/length-of-the-longest-subarray-with-zero-sum/


https://bit.ly/3w5QSzC

'''
# - method 1 : brute force
'''
- take maxi = 0
- iterate over the arr with i till n
- take sum = 0
- iterate over the arr with j from i till n
- add arr[j] to sum
- if sum == 0, then maxi = max(maxi, j-i+1)
- return maxi

TC - O(n^2)

SC - O(1)
'''
def solve(arr):
  n = len(arr)
  maxi = 0
  for i in range(n):
    sum = 0
    for j in range(i,n):
      sum += arr[j]
      if sum == 0:
        maxi = max(maxi, j-i+1)
  return maxi
arr = [9,-3,3,-1,6,-5]
print(solve(arr))

# - method 2 : better solution, time complexity O(n)

# - method 3 : optimal solution, using prefix sum
'''
steps
- take variables sum = 0, maxi = 0 and mpp = {}
- iterate over the arr with i till n
- add arr[i] to sum
- if sum == 0, then maxi = max(maxi, i+1)
- if sum in mpp, then maxi = max(maxi, i-mpp[sum]) else mpp[sum] = i
- return maxi


TC - O(n)

SC - O(n)
'''
def solve(arr):
  # Dictionary to store the first occurrence of each prefix sum {prefix_sum, index}
  mpp = {}
  # Variable to store the prefix sum while traversing the array
  sum = 0
  # Variable to keep track of the maximum length of subarray with 0 sum
  maxi = 0
  # Loop through the array
  for i in range(len(arr)):
    sum += arr[i]  # Update the prefix sum up to index i
    # If the prefix sum is 0, it means the subarray from index 0 to i has a sum of 0
    if sum == 0:
      maxi = i + 1  # Update the max length
    # If this prefix sum has been seen before
    else:
      if sum in mpp:
        # The subarray from the previous index+1 to current index has a sum of 0
        maxi = max(maxi, i - mpp[sum])  # Update max length if this subarray is longer
      else:
        # Store the index of the first occurrence of this prefix sum
        mpp[sum] = i
  return maxi  # Return the length of the longest subarray with 0 sum
arr = [9,-3,3,-1,6,-5]
print(solve(arr))                  # Output - 5


# 6 TODO : count number of subarrays with given xor k
"""
using three for loops
using two for loops
using hashing

"""
'''
ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´
ğŸ˜ğŸ˜ğŸ˜
â­â­â­


https://takeuforward.org/data-structure/count-the-number-of-subarrays-with-given-xor-k/

https://www.youtube.com/watch?v=eZr-6p0B7ME&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=38

https://www.interviewbit.com/problems/subarray-with-given-xor/


'''
# - method 1 : brute force
'''
0^4 --> 4
4^2 --> 6
4^2^2 --> 4 because 2 and 2 will be 0


steps
- take a variable cnt = 0
- iterate over the array with i till n
- iterate over the array with j from i till n
- take a variable xor = 0
- iterate over the array with k from i till j
- take xor = xor ^ arr[k]
- if xor == k, then increment cnt by 1
- return cnt

TC - O(n^3)

SC - O(1)
'''
def subarray(a,b):
  n = len(a)
  cnt = 0
  for i in range(n):
    for j in range(i,n):
      xor = 0
      for k in range(i,j+1):
        xor = xor ^ a[k]
      if xor == b:
        cnt += 1
  return cnt

a = [4,2,2,6,4]
k = 6
print(subarray(a,k))                                # Output - 4

# - method 2 : better solution
'''
steps
- take a variable cnt = 0
- iterate over the array with i till n
- take a variable xor = 0
- iterate over the array with j from i till n
- take xor = xor ^ arr[j]
- if xor == b, then increment cnt by 1
- return cnt

TC - O(n^2)

SC - O(1)
'''
def subarray(a,b):
  n = len(a)
  cnt = 0
  for i in range(n):
    xor = 0
    for j in range(i,n):
      xor = xor ^ a[j]
      if xor == b:
        cnt += 1
  return cnt

a = [4,2,2,6,4]
k = 6
print(subarray(a,k))                                # Output - 4


# - method 3 : optimal solution, using hashing
'''
x^k = XR
(x^k)^k = XR^k
x = XR^k

steps
- take a variable cnt = 0, xr = 0, mpp = defaultdict(int)
- initializ dict mpp[xr] = 1
- iterate over the array with i till n
- take xr = xr ^ arr[i]
- take x = xr ^ b
- take cnt += mpp[x]
- increment mpp[xr] by 1
- return cnt

TC - O(n*log(n))

SC - O(N)
'''
from collections import defaultdict
def subarray(a,b):
  n = len(a)
  xr = 0
  mpp = defaultdict(int)
  mpp[xr] = 1 # {0 : 1}
  cnt = 0
  for i in range(n):
    xr = xr ^ a[i] # xor with current element
    x = xr ^ b # xor with the target
    cnt += mpp[x] # if mpp has x, if automatically works here
    mpp[xr] += 1 # if mpp has x, if automatically works here
  return cnt

a = [4,2,2,6,4]
k = 6
print(subarray(a,k))                                # Output - 4


# 7 TODO : merge overlapping subintervals
"""
using two for loops
using one for loop
"""
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡
ğŸ˜ğŸ˜ğŸ˜
â­â­â­

https://takeuforward.org/data-structure/merge-overlapping-sub-intervals/

https://www.youtube.com/watch?v=IexN60k62jo&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=39

https://leetcode.com/problems/merge-intervals/

'''
# - method 1 : brute force
'''
steps
- sort the array based on the 1st element of each array
- take an empty array ans = []
- iterate over the array with i till n
- take start = arr[i][0], end = arr[i][1] 
- check if ans is empty or start is greater than ans[-1][1]
- iterate over the array with j from i+1 till n
- check if arr[j][0] <= end if true then end = max(end, arr[j][1]) else break
- append start and end to ans
- return ans

TC - O(nlogn)+O(2n), 

SC - O(n)
'''
def merge(arr):
  n = len(arr)
  # Sort intervals based on the start time
  arr.sort()
  # List to store the merged intervals
  ans = []
  # Loop over each interval
  for i in range(n):
    # Extract the start and end of the current interval
    start, end = arr[i][0], arr[i][1]
    # Skip this interval if it is already merged in a previous step
    # This condition works because merged intervals may overlap with upcoming ones,
    # and we're handling merging inside the inner loop below.
    if ans and start <= ans[-1][1]:
      continue
    # Try to merge with subsequent intervals if they overlap
    for j in range(i + 1, n):
      # If the next interval starts before or at the current 'end',
      # it overlaps with the current interval
      if arr[j][0] <= end:
        # Update the end to the furthest end of the overlapping intervals
        end = max(end, arr[j][1])
      else:
        # No more overlapping intervals, break out of the loop
        break
    # Append the merged interval to the result list
    # (Fix: should be appended as a list, not separate arguments)
    ans.append([start, end])
  # Return the merged list of intervals
  return ans

arr = [[1,3],[2,6],[8,10],[15,18]]
print(merge(arr))                                   # Output - [[1, 6], [8, 10], [15, 18]]

# - method 2 : better solution, time complexity O(n)

# - method 3 : optimal solution
'''
steps
- sort the array based on the 1st element of each array
- take an empty array ans = []
- iterate over the array with i till n
- check if ans is empty or start is greater than ans[-1][1] else update the end with max(end, arr[i][1])
- return ans

TC - O(nlogn)+O(n)

SC - O(n)
'''
def merge(arr):
  n = len(arr)
  arr.sort()
  ans = []
  for i in range(n):
    if not ans or arr[i][0] > ans[-1][1]:
      ans.append(arr[i])
    else:
      ans[-1][1] = max(ans[-1][1], arr[i][1])
  return ans

arr = [[1,3],[2,6],[8,10],[15,18]]
print(merge(arr))                                   # Output - [[1, 6], [8, 10], [15, 18]]

# 

# 8 TODO : merge two sorted arrays without extra space
"""
using two pointers

""""
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡
ğŸ˜ğŸ˜ğŸ˜



https://takeuforward.org/data-structure/merge-two-sorted-arrays-without-extra-space/

https://www.youtube.com/watch?v=n7uwj04E0I4&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=40

https://leetcode.com/problems/merge-sorted-array/

'''
# - method 1 : brute force
'''
steps
- take an empty array arr3 of size n+m
- take variables left = 0, right = 0, index = 0
- use while loop to iterate with condition  left < n and right < m
- check if arr1[left] <= arr2[right] if true then arr3[index] = arr1[left] and left += 1 and index += 1 else arr3[index] = arr2[right] and right += 1 and index += 1
- use while loop to iterate with condition left < n
- arr3[index] = arr1[left] and left += 1 and index += 1
- use while loop to iterate with condition right < m
- arr3[index] = arr2[right] and right += 1 and index += 1
- use for loop to iterate with i till n+m
- check if i < n if true then arr1[i] = arr3[i] else arr2[i-n] = arr3[i]
- return arr3

TC - O(n+m) + O(n+m)

SC - O(n+m)
'''
def merge(arr1, arr2):
  n = len(arr1)
  m = len(arr2)
  arr3 = [] 
  left = 0
  right = 0
  # Merge two sorted arrays into arr3
  while left < n and right < m:
    if arr1[left] <= arr2[right]:
      arr3.append(arr1[left])
      left += 1
    else:
      arr3.append(arr2[right])
      right += 1
  # Append remaining elements
  while left < n:
    arr3.append(arr1[left])
    left += 1
  
  while right < m:
    arr3.append(arr2[right])
    right += 1
  return arr3

arr1 = [1, 4, 8, 10]
arr2 = [2, 3, 9]
print(merge(arr1, arr2))                      # Output - [1, 2, 3, 4, 8, 9, 10]


# - method 2 : better solution, time complexity O(n)

# - method 3 : optimal solution using two pointers
'''
steps
- take variables left = n-1, right = 0
- use while loop to iterate with condition left >= 0 and right < m
- check if arr1[left] > arr2[right] if true then swap arr1[left] and arr2[right] and left -= 1 and right += 1 else break
- sort arr1 and arr2
- return arr1 + arr2

TC - O(min(n,m)) + O(nlogn), while() + 2*sort()

SC - O(1)
'''
def merge(arr1, arr2):
  n = len(arr1)
  m = len(arr2)
  left = n -1
  right = 0
  while left >= 0 and right < m:
    if arr1[left] > arr2[right]:
      arr1[left], arr2[right] = arr2[right], arr1[left]
      left -= 1
      right += 1
    else:
      break
  arr1.sort()
  arr2.sort()
  return arr1 + arr2

arr1 = [1,4,8,10]
arr2 = [2,3,9]
print(merge(arr1, arr2))                      # Output - [1, 2, 3, 4, 8, 9, 10]

# - method 4 : optimal solution, using gap method
'''
taking gap concept from shell sort method

m = 5, n = 3 --> different
m = 5, n = 2 --> same

print(((m+n) // 2) + ((m+n) % 2))
print(((m+n)//2) + 1)

steps
- take variables n = len(arr1), m = len(arr2), max_len = n+m
- take gap = (max_len // 2) + (max_len % 2) 
- use while loop to iterate with condition gap > 0
- take left = 0, right = left + gap
- use while loop to iterate with condition right < max_len
- check if left < n and right >= n if true then swap arr1[left] and arr2[right-n] else if left >= n then swap arr2[left-n] and arr2[right-n] else swap arr1[left] and arr1[right]
- left += 1 and right += 1
- check if gap == 1 if true then break
- gap = (gap // 2) + (gap % 2)
- return arr1 + arr2

TC - O((n+m)*log(n+m))

SC - O(1)
'''
def swapIfGreater(arr1, arr2, ind1, ind2):
  # arr1[ind1] > arr2[ind2]:
  if arr1[ind1] > arr2[ind2]:
    arr1[ind1], arr2[ind2] = arr2[ind2], arr1[ind1]

def merge(arr1, arr2):
  n = len(arr1)
  m = len(arr2)
  max_len = n + m
  gap = (max_len // 2) + (max_len % 2) # take ceil value
  while gap > 0:
    left = 0
    right = left + gap
    while right < max_len:
      # arr1 and arr2
      if left < n and right >= n:  
        swapIfGreater(arr1, arr2, left, right - n)
      # arr2 and arr2
      elif left >= n:  
        swapIfGreater(arr2, arr2, left - n, right - n)
      # arr1 and arr1
      else: 
        swapIfGreater(arr1, arr1, left, right)
      left += 1
      right += 1
    if gap == 1:
      break
    gap = (gap // 2) + (gap % 2)
  return arr1 + arr2

arr1 = [1, 4, 8, 10]
arr2 = [2, 3, 9]
print(merge(arr1, arr2))                      # Output - [1, 2, 3, 4, 8, 9, 10]

# using chatgpt
# def swapIfGreater(arr1, arr2, ind1, ind2):
#     if arr1[ind1] > arr2[ind2]:
#         arr1[ind1], arr2[ind2] = arr2[ind2], arr1[ind1]

# def merge(arr1, arr2):
#     n = len(arr1)
#     m = len(arr2)
#     gap = (n + m + 1) // 2  # Initial gap

#     while gap > 0:
#         i = 0
#         j = gap
#         while j < (n + m):
#             # Get values from appropriate arrays
#             if i < n and j < n:
#                 swapIfGreater(arr1, arr1, i, j)
#             elif i < n and j >= n:
#                 swapIfGreater(arr1, arr2, i, j - n)
#             else:
#                 swapIfGreater(arr2, arr2, i - n, j - n)
#             i += 1
#             j += 1

#         if gap == 1:
#             break
#         gap = (gap + 1) // 2  # Reduce gap like Shell sort

#     return arr1 + arr2

# # Test
# arr1 = [1, 4, 8, 10]
# arr2 = [2, 3, 9]
# print(merge(arr1, arr2))  # Output: [1, 2, 3, 4, 8, 9, 10]


# 9 TODO : find the repeating and missing number
'''
ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´
ğŸ˜ğŸ˜ğŸ˜


https://takeuforward.org/data-structure/find-the-repeating-and-missing-numbers/


https://bit.ly/3zWZoCs



'''
# - method 1 : brute force
'''
steps
- take variables rep = -1, mis = -1
- use for loop to iterate with i from 1 to n+1
- take variable cnt = 0 
- use for loop to iterate with j from 0 to n
- check if a[j] == i if true then cnt += 1
- check if cnt == 2 if true then rep = i else if cnt == 0 then mis = i
- check if rep != -1 and mis != -1 if true then break
- return rep, mis

TC - O(n^2)

SC - O(1)
'''
def solve(a):
  n = len(a)
  rep, mis = -1, -1
  for i in range(1,n+1):
    cnt = 0
    for j in range(n):
      if a[j] == i:
        cnt += 1
    if cnt == 2:
      rep = i
    elif cnt == 0:
      mis = i
    if rep != -1 and mis != -1:
      break
  return rep, mis

a = [3,1,2,5,4,6,7,5]
print(solve(a))

# - method 2 : better solution, using hash array 
'''
steps
- take a hash array hash of size n+1 with 0 filled in it
- use for loop to iterate with i from 0 to n
- hash[a[i]] += 1
- iterate given array with i from 1 to n+1
- check if hash[i] == 2 if true then rep = i else if hash[i] == 0 then mis = i
- check if rep != -1 and mis != -1 if true break
- return rep,mis

TC - O(2N)

SC - O(N)
'''
def solve(a):
  n = len(a)
  hash = [0] * (n+1)
  for i in range(n):
    hash[a[i]] += 1
  rep, mis = -1, -1
  for i in range(1,n+1):
    if hash[i] == 2:
      rep = i
    elif hash[i] == 0:
      mis = i
    if rep != -1 and mis != -1:
      break
  return rep, mis

a = [3,1,2,5,4,6,7,5]
print(solve(a))


# - method 3 : optimal solution, using maths
'''
sum of n natual numbers
sn = (n * (n+1)) 

sum of squares of n natural numbers
s2n = (n * (n+1) * (2*n+1)) // 6



steps
- take variables sn = (n * (n+1)) // 2, s2n = (n * (n+1) * (2*n+1)) // 6
- take variables s = 0, s2 = 0
- sum of n natural numbers sn = (n * (n+1)) 
- sum of squares of n natural numberss2n = (n * (n+1) * (2*n+1))
- iterate given array with i from 0 to n
- s += a[i] and s2 += a[i] * a[i]
- val1 = s - sn
- val2 = s2 - s2n
- val2 = val2 // val1
- mis = (val1 + val2) // 2
- rep = mis - val1
- return rep

TC - O(N)

SC - O(1)
'''
def solve(a):
  n = len(a)
  sn = (n * (n+1)) 
  s2n = (n * (n+1) * (2*n+1)) 
  s, s2 = 0, 0
  for i in range(n):
    s += a[i]
    s2 += a[i] * a[i]
  val1 = s - sn # x - y
  val2 = s2 - s2n  # x^2 - y^2
  val2 = val2 // val1 # x + y
  mis = (val1 + val2) // 2  # x, missing number
  rep = mis - val1  # y, repeating number
  return rep, mis

a = [3,1,2,5,4,6,7,5]
print(solve(a))

# - method 3 : optimal solution, using xor
'''
TC - O(N)

SC - O(1)
'''
def solve(a):
  n = len(a)
  xr = 0

  # Step 1: XOR all elements of the array and numbers from 1 to n
  for i in range(n):
    xr = xr ^ a[i]  # all array elements
    xr = xr ^ (i + 1)  # all natural numbers till n
  
  # Step 2: Get the rightmost set bit (this will help partition the array)
  '''
  number = xr & ~(xr - 1)

  or

  bit = 1
  number = 0
  while xr & bit == 0:  # Keep shifting until we find the first set bit
    bit <<= 1
  number = bit  # The first set bit (rightmost)

  or

  '''
  bit = 0
  while 1:  
    if (xr and 1<<bit) != 0:
      break
    bit = bit + 1

  zero = 0
  one = 0

  # Step 3: Divide the elements into two sets based on the rightmost set bit ie includes in 0s club or 1's club
  for i in range(n):
    if (a[i] & 1<<bit) != 0:
      one = one ^ a[i]
    else:
      zero = zero ^ a[i]
  
  # Step 4: Divide the numbers from 1 to n into two sets based on the rightmost set bit
  for i in range(1, n + 1):
    if (i & 1<<bit) != 0:
      one = one ^ i
    else:
      zero = zero ^ i

  # Step 5: Count occurrences of zero in the array and compare to return the missing numbers
  cnt = 0
  for i in range(n):
    if a[i] == zero:
      cnt += 1
  
  # Step 6: Return the result
  if cnt == 2:
    return one, zero
  else:
    return zero, one

a = [3, 1, 2, 5, 4, 6, 7, 5]
print(solve(a))  # Output should be the two missing numbers

# 10 TODO : count inversions; i<j and a[i] > a[j]
'''
ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/data-structure/count-inversions-in-an-array/

https://www.youtube.com/watch?v=AseUmwVNaoY&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=42

https://bit.ly/3PtLWLM

'''
# - method 1 : brute force
'''
steps
- take variable cnt = 0
- iterate on the array with i from 0 to n
- iterate on the array with j from i+1 to n
- check if a[i] > a[j] if true then cnt += 1
- return cnt

TC - O O(n^2)

SC - O(1)
'''
def solve(a, n):
  cnt = 0
  for i in range(n):
    for j in range(i+1, n):
      if a[i] > a[j]:
        cnt += 1
  return cnt

a = [5,4,3,2,1]
print(solve(a, len(a)))

# - method 2 : better solution, time complexity O(n)

# - method 3 : optimal solution
'''
steps
reference --> merge sort

TC - O(N*log(N))

SC - O(N)
'''
import math 
def solve(a, n):
  return merge_sort(a, 0, n-1)

def merge_sort(a, low, high):
  cnt = 0
  if low >= high:
    return cnt
  mid = (low + high) // 2
  cnt += merge_sort(a, low, mid)
  cnt += merge_sort(a, mid+1, high)
  cnt += merge(a, low, mid, high)
  return cnt

def merge(a, low, mid, high):
  cnt = 0
  temp = []
  left = low
  right = mid+1
  while left <= mid and right <= high:
    if a[left] <= a[right]:
      temp.append(a[left])
      left += 1
    else:
      temp.append(a[right])
      cnt += (mid - left + 1)  # count the pairs
      right += 1
  while left <= mid:
    temp.append(a[left])
    left += 1
  while right <= high:
    temp.append(a[right])
    right += 1
  for i in range(low, high+1):
    a[i] = temp[i - low]
  return cnt

a = [5,4,3,2,1]
print(solve(a, len(a)))


# 11 TODO : reverse pairs; i<j and arr[i] > 2*arr[j]
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/count-reverse-pairs/

https://www.youtube.com/watch?v=0e4bZaP3MDI&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=43

https://leetcode.com/problems/reverse-pairs/

'''
# - method 1 : brute force
'''
steps
- take a variable cnt = 0
- iterate given array with i from 0 to n
- iterate given array with j from i+1 to n
- if a[i] > 2 * a[j] then cnt += 1
- return cnt

TC - O(N^2)

SC - O(1)
'''
def team(skill, n):
  return countPairs(skill, n)
def countPairs(a, n):
  cnt = 0
  for i in range(n):
    for j in range(i+1, n):
      if a[i] > 2 * a[j]:
        cnt += 1
  return cnt

a = [4,1,2,3,1]
n  =  5
print(team(a, n))
# - method 2 : better solution, time complexity O(n)

# - method 3 : optimal solution
'''
referenece --> merge sort


TC - O(2N*log(N))

SC - O(N)
'''
def team(skill, n):
  return merge_sort(skill, 0, n - 1)

def merge_sort(a, low, high):
  cnt = 0
  if low >= high:
    return cnt
  mid = (low + high) // 2
  cnt += merge_sort(a, low, mid)
  cnt += merge_sort(a, mid + 1, high)
  cnt += countPairs(a, low, mid, high) # extra step
  cnt += merge(a, low, mid, high)
  return cnt

def countPairs(a, low, mid, high):
  right = mid + 1
  cnt = 0
  for i in range(low, mid + 1):
    # Ensure right pointer only moves when condition is met
    while right <= high and a[i] > 2 * a[right]:
      right += 1
    cnt += (right - (mid + 1))
  return cnt

def merge(a, low, mid, high):
  temp = []
  left = low
  right = mid + 1
  cnt = 0
  while left <= mid and right <= high:
    if a[left] <= a[right]:
      temp.append(a[left])
      left += 1
    else:
      temp.append(a[right])
      cnt += (mid - left + 1)  # Count all remaining elements in the left half
      right += 1
  while left <= mid:
    temp.append(a[left])
    left += 1
  while right <= high:
    temp.append(a[right])
    right += 1
  for i in range(low, high + 1):
    a[i] = temp[i - low]
  return cnt

# Test case
a = [4, 1, 2, 3, 1]
n = 5
print(team(a, n))  # Output the number of pairs


# 

# 12 TODO : maximum product subarray
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/data-structure/maximum-product-subarray-in-an-array/

https://www.youtube.com/watch?v=hnswaLJvr6g&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=44

https://leetcode.com/problems/maximum-product-subarray/

'''
# - method 1 : brute force
'''
step
- take variable result = float("-inf")
- iterate on the array with i from 0 till n-1
- iterate on the array with j from i+1 till n
- take variable prod = 1
- iterate on the array with k from i till j+1
- prod *= arr[k]
- result = max(result, prod)
- return result

TC - O(n^2)

SC - O(1)
'''
def maxProduct(nums):
  n = len(nums)
  result = float('-inf')
  for i in range(n-1):
    for j in range(i+1, n):
      prod = 1
      for k in range(i, j+1):
        prod *= nums[k]
      result = max(result, prod)
  return result
nums = [1,2,-3,0,-4,-5]
print(maxProduct(nums))

# - method 2 : better solution
'''
steps
- take variable result = nums[0]
- iterate on the array with i from 0 till n-1
- take variable p = 1
- iterate on the array with j from i+1 till n
- result = max(result, p)
- p *= arr[j]
- result = max(result, p)
- return result

TC - time complexity O(n^2)

SC - O(1)
'''
def maxProduct(nums):
  result = nums[0]
  for i in range(len(nums) - 1):
    p = nums[i]
    for j in range(i+1, len(nums)):
      result = max(result, p)
      p *= nums[j]
    result = max(result, p)
  return result
nums = [1,2,-3,0,-4,-5]
print(maxProduct(nums))


# - method 3 : optimal solution using observation
'''
why usinng prefix an suffix both? we can use prefix only!

steps
- take variables pre = 1 and suff = 1 and ans = float('-inf')
- iterate on the array with i from 0 till n
- if pre == 0: pre = 1
- if suff == 0: suff = 1
- pre *= arr[i]
- suff *= arr[n-i-1]
- ans = max(ans, max(pre, suff))
- return ans

TC - O(N)

SC - O(1)
'''
def maxProduct(arr):
  n = len(arr)
  pre, suff = 1,1
  ans = float('-inf')
  for i in range(n):
    if pre == 0:
      pre = 1
    if suff == 0:
      suff = 1
    pre *= arr[i]
    suff *= arr[n-i-1]
    ans = max(ans, max(pre, suff))
  return ans
nums = [1,2,-3,0,-4,-5]
print(maxProduct(nums))

# - method 4 : optimal solution
'''
steps


TC - O(N)

SC - O(1)
'''
def maxProduct(nums):
  prod1 = nums[0]
  prod2 = nums[0]
  result = nums[0]
  for i in range(1, len(nums)):
    temp = max(nums[i], nums[i]*prod1, nums[i]*prod2)
    prod2 = min(nums[i], nums[i]*prod1, nums[i]*prod2)
    prod1 = temp
    result = max(result, prod1)
  return result
nums = [1,2,-3,0,-4,-5]
print(maxProduct(nums))

# endregion





# region 4.1 BINARY SEARCH on 1D ARRAY
# ------------------------------------

# 1 TODO : binary search to find x in the sorted array 
"""

"""
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢
â­â­â­

https://takeuforward.org/data-structure/binary-search-explained/

https://www.youtube.com/watch?v=MHf6awe89xw&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=45

https://leetcode.com/problems/binary-search/

BINARY SEARCH - 
WHEN TO USE - when the search space is sorted
IF low or high - float("inf"), 
mid = (low + (high - low)) // 2
'''
# method 1 : iterative approch
'''
steps
- take variables low = 0, high = len(a) - 1
- use while loop to iterate on condition low <= high
- take mid = (low + high) // 2
- check if a[mid] == target then return mid
- if a[mid] < target then low = mid + 1
- else high = mid - 1
- return -1


TC - o(log2(N)) 

SC -
'''
def binarySearch(a, target):
  low = 0
  high = len(a) - 1
  while low <= high:
    mid = (low + high) // 2
    if a[mid] == target:
      return mid
    elif a[mid] < target:
      low = mid + 1
    else:
      high = mid - 1
  return low

a = [3,4,6,7,9,12,16,17]
target  = 6
print(binarySearch(a, target))

# method 2 : recursive approch
'''
steps
- take parameters nums, low, high, target
- if low > high then return -1
- take mid = (low + high) // 2
- if nums[mid] == target then return mid
- if target > nums[mid] then return binarySearch(nums, mid+1, high, target)
- return binarySearch(nums, low, mid-1, target)


TC - O(log2(N))

SC -
'''
def binarySearch(nums, low, high, target):
  if low > high:
    return -1
  
  mid = (low + high) // 2
  if nums[mid] == target:
    return mid
  elif target > nums[mid]:
    return binarySearch(nums, mid+1, high, target)
  return binarySearch(nums, low,mid-1, target)

def search(nums, target):
  return binarySearch(nums, 0, len(nums) - 1, target)

a = [3,4,6,7,9,12,16,17]
target  = 6
print(search(a, target))


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : implement lower bound, smallest index such that arr[index] >= k
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢
â­â­â­

https://takeuforward.org/arrays/implement-lower-bound-bs-2/

https://www.youtube.com/watch?v=6zhGS79oQ4k&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=46

https://bit.ly/3Cf398N

smallest index such that arr[index] >= k

eg
a = [3,5,8, 15, 19]
x = 8  --> lb = 2
x = 9  --> lb = 3
x = 5  --> lb = 4
x = 20  --> lb = 5

'''
# method 1 : brute force approch
'''
steps
- iterate on the array with i till n
- check if arr[i] >= x then return i
- return n

TC - O(N)

SC - O(1)
'''
def lowerBound(arr, n, x):
  for i in range(n):
    if arr[i] >= x:
      return i
  return n

a = [3,5,8, 15, 19]
n = 5
x = 9
print(lowerBound(a, n, x))


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
steps
- take variables low = 0, high = n-1 and ans = n
- use while loop to iterate on condition low <= high
- take mid = (low + high) // 2
- check if arr[mid] >= x then ans = mid and high = mid - 1
- else low = mid + 1
- return ans

TC - O(log2(N))

SC - O(1)
'''
def lowerBound(arr, n, x):
  low = 0
  high = n - 1
  ans = n
  while low <= high:
    mid = (low + high) // 2
    if arr[mid] >= x:
      ans = mid  
      high = mid - 1        
    else:
      low = mid + 1
  return ans

a = [3,5,8, 15, 19]
n = 5
x = 9
print(lowerBound(a, n, x))


# 3 TODO : implement upper bound; smallest index such that arr[index] > k
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢
â­â­â­

https://takeuforward.org/arrays/implement-upper-bound/

https://www.youtube.com/watch?v=6zhGS79oQ4k&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=46

https://bit.ly/3CgDDjE

smallest index such that arr[index] > k

eg
a = [2,3,6,7,8,8,11,11,11,12]
x = 6  --> lb = 3
x = 11  --> lb = 9
x = 12  --> lb = 10
x = 13  --> lb = 10
x = 0  --> lb = 0
'''
# method 2 : brute force
'''
steps
- iterate on the array with i till n
- check if arr[i] > x then return i
- return n

TC - O(N)

SC - O(1) 
'''
def upperBound(arr, x, n):
  for i in range(n):
    if arr[i] > x:
      return i
  return n

a = [3,5,8, 9, 15, 19]
n = 6
x = 9
print(upperBound(a, x, n))


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
steps
- take variables low = 0, high = n-1 and ans = n
- use while loop to iterate on condition low <= high
- take mid = (low + high) // 2
- check if arr[mid] = x then ans = mid and high = mid - 1
- else low = mid + 1
- return ans

TC - O(log2(N))

SC - O(1)
'''
def upperBound(arr, x, n):
  low = 0
  high = n - 1
  ans = n
  while low <= high:
    mid = (low + high) // 2
    if arr[mid] > x:
      ans = mid
      high = mid - 1
    else:
      low = mid + 1
  return ans

a = [3,5,8, 9, 15, 19]
n = 6
x = 9
print(upperBound(a, x, n))


# 4 TODO : search insert position
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/arrays/search-insert-position/

https://www.youtube.com/watch?v=6zhGS79oQ4k&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=46

https://leetcode.com/problems/search-insert-position/#:~:text=Search%20Insert%20Position%20%2D%20LeetCode&text=Given%20a%20sorted%20array%20of,(log%20n)%20runtime%20complexity.

search insert position --> same as lower bound
'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
steps  reference --> lower bound
- take variables low = 0, high = n-1 and ans = n
- use while loop to iterate on condition low <= high
- take mid = (low + high) // 2
- check if arr[mid] >= x then ans = mid and high = mid - 1
- else low = mid + 1
- return ans

TC - O(log2(N))

SC - O(1)
'''
def searchInsert(arr, x):
  n = len(arr)
  low = 0
  high = n - 1
  ans = n
  while low <= high:
    mid = (low + high) // 2
    if arr[mid] >= x:
      ans = mid
      high = mid - 1
    else:
      low = mid + 1
  return ans

arr = [1,2,4,7]
x  = 6
print(searchInsert(arr, x))


# 5 TODO : floor / ceil in sorted array
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

https://takeuforward.org/arrays/floor-and-ceil-in-sorted-array/

https://www.youtube.com/watch?v=6zhGS79oQ4k&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=46

https://www.codingninjas.com/codestudio/problems/ceiling-in-a-sorted-array_1825401

floor - largest element <= x
ceil - smallest element >= x  --> lower bound
'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
steps
- find floor take 3 parameters arr, n, x
- take 3 variables low = 0, high = n-1 and ans = -1
- use while loop to iterate on condition low <= high
- take mid = (low + high) // 2
- check if arr[mid] <= x then ans = arr[mid] and low = mid + 1
- else high = mid - 1
- return ans

find ceil --> reference --> lower bound


TC     -      
SC     -      
'''
def findFloor(arr, n, x):
  low = 0
  high = n - 1
  ans = -1
  while low <= high:
    mid = (low + high) // 2
    if arr[mid] <= x:
      ans = arr[mid]
      low = mid + 1
    else:
      high = mid - 1
  return ans

def findCeil(arr, n, x):
  low = 0
  high = n - 1
  ans = -1
  while low <= high:
    mid = (low + high) // 2
    if arr[mid] >= x:
      ans = arr[mid]
      high = mid - 1
    else:
      low = mid + 1
  return ans

def getFloorAndCeil(arr, n, x):
  f = findFloor(arr, n, x)
  c = findCeil(arr, n, x)
  return [f, c]


arr = [3, 4,4,7,8,10]
n = 6
x = 5
print(getFloorAndCeil(arr, n, x))


# 


# 6 TODO : find the first or last occurence of a givennumber in sorted array
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢
â­â­â­

https://takeuforward.org/data-structure/last-occurrence-in-a-sorted-array/

https://www.youtube.com/watch?v=hjR1IYVx9lY&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=47

https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/

'''
# method 1 : brute force approch
'''
steps


TC - O(n)

SC - O(1)
'''
def count(n, k, x):
  first = -1
  last = -1
  for i in range(k):
    if arr[i] == x:
      if first == -1:
        first = i
      last = i
  return first, last

arr = [3,4,13,13,13,20,40]
n = 7
x = 13
print(count(arr, n, x))


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
steps
- take 3 variables start = 0, end = n-1 and res = -1
- use while loop to iterate on condition start <= end
- take mid = start + (end - start) // 2
- check if arr[mid] == x then res = mid and start = mid + 1
- else if arr[mid] < x then start = mid + 1
- else end = mid - 1
- return res

TC - O(2*log2(N))

SC - O(N) 
'''
def firstOccurrence(arr, n, k):
  low = 0
  high = n - 1
  first = -1
  while low <= high:
    mid = (low + high) // 2
    if arr[mid] == k:
      first = mid
      high = mid - 1  # Search on left side
    elif arr[mid] < k:
      low = mid + 1
    else:
      high = mid - 1
  return first

def lastOccurrence(arr, n, k):
  low = 0
  high = n - 1
  last = -1
  while low <= high:
    mid = (low + high) // 2
    if arr[mid] == k:
      last = mid
      low = mid + 1  # Search on right side
    elif arr[mid] < k:
      low = mid + 1
    else:
      high = mid - 1
  return last

def firstAndLastPosition(arr, n, x):
  first = firstOccurrence(arr, n, x)
  if first == -1:
    return (-1, -1)
  last = lastOccurrence(arr, n, x)
  return (first, last)

arr = [2, 4, 6, 8, 8, 8, 11, 13]
n = len(arr)
x = 8
print(firstAndLastPosition(arr, n, x))  # Output: 3


# 7 TODO : count occurence of a number in a sorted array with duplicates
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/data-structure/count-occurrences-in-sorted-array/


https://bit.ly/3SVcOqW


'''
# method 1 : brute force approch
'''
steps
- take a variable cnt = 0
- iterate on the array with i till n
- check if arr[i] == x then increment cnt by 1
- return cnt

TC - O(N)

SC - O(1)
'''
def count(arr, n, x):
  cnt = 0
  for i in range(n):
    if arr[i] == x:
      cnt += 1
  return cnt

arr = [2,4,6,8,8,8,11,13]
n = 8 
x = 8
print(count(arr, n, x))


# method 2 : better approch
'''
firstOccurance -> lower bound
lastOccurance -> upper bound


TC     -      
SC     -     
'''

# method 3 : optimal solution, 
'''
TC - O(2*log(N))
SC - O(1)
'''
def firstOccurance(arr, n, k):
  low = 0
  high = n -1
  first = -1
  while low <= high:
    mid = (low + high) // 2
    if arr[mid] == k:
      first = mid
      high = mid - 1    # ---> difference
    elif arr[mid] < k:
      low = mid + 1
    else:
      high = mid - 1
  return first
def lastOccurance(arr, n, k):
  low = 0
  high = n -1
  last = -1
  while low <= high:
    mid = (low + high) // 2
    if  arr[mid] == k:
      last = mid
      low  = mid + 1    # ---> difference
    elif arr[mid] < k:
      low = mid + 1
    else:
      high = mid - 1
  return last

def firstAndLastPosition(arr, n, x):
  first = firstOccurance(arr, n, x)
  if first == -1:
    return (-1, -1)
  last = lastOccurance(arr, n, x)
  return (first, last)

def count(arr, n, x):
  first, last = firstAndLastPosition(arr, n, x)
  if first == -1:
    return 0
  return last - first + 1

arr = [2,4,6,8,8,8,11,13]
n = 8 
x = 8
print(count(arr, n, x))



# 8 TODO : search in rotated array I
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡
â­â­â­

https://takeuforward.org/data-structure/search-element-in-a-rotated-sorted-array/

https://www.youtube.com/watch?v=hjR1IYVx9lY&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=48

https://leetcode.com/problems/search-in-rotated-sorted-array/

'''
# method 1 : brute force approch
'''
steps
- iterate on the array with i till n
- check if arr[i] == k then return i
- return -1

TC - O(N)

SC - O(1)
'''

def search(arr, n, k):
  for i in range(n):
    if arr[i] == k:
      return i
  return -1

arr = [7,8,9,1,2,3,4,5,6]
n = 9
k = 1
print(search(arr, n, k))



# ğŸ‘‰ğŸ‘‰ğŸ‘‰ method 2 : better approch SELF
# def firstTarget(arr, k):
#   ans = -1
#   low = 0 
#   high = len(arr) - 1 
#   while low <= high:
#     mid = (low + high)//2
#     print(low, mid, high)
#     if arr[mid] == k:
#       return mid
#     elif arr[low] == k:
#       return low
#     elif arr[high] == k:
#       return high
#     elif arr[mid]  > k:
#       high = mid - 1
#     else:
#       low = mid + 1 
#   return ans  


# method 3 : optimal solution
'''
steps
- take 2 variables low = 0 and high = n - 1
- use while loop to iterate on condition low <= high
- take mid = (low + high) // 2
- check if arr[mid] == k then return mid
- check if 


TC - O(log(N))

SC - O(1)
'''

def search(arr, n, k):
  low = 0            
  high = n - 1             
  while low <= high:      
    mid = (low + high) // 2  
    if arr[mid] == k:        # If mid element is the target, return its index
      return mid
    # Check if the left half is sorted
    if arr[low] <= arr[mid]:
      # If the target lies within the sorted left half
      if arr[low] <= k and k <= arr[mid]:
        high = mid - 1                     # Search left half
      else:
        low = mid + 1                      # Search right half
    else:
      # Otherwise, the right half must be sorted
      if arr[mid] <= k and k <= arr[high]:
        low = mid + 1                      # Search right half
      else:
        high = mid - 1                     # Search left half
  return -1  # If not found, return -1

# Example usage
arr = [7,8,9,1,2,3,4,5,6]  
n = 9                      
k = 1                    
print(search(arr, n, k))   # Output: 3


# 9 TODO : search in rotated array II
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

https://takeuforward.org/arrays/search-element-in-rotated-sorted-array-ii/

https://www.youtube.com/watch?v=w2G2W8l__pc&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=49

https://leetcode.com/problems/search-in-rotated-sorted-array-ii/

'''
# method 1 : brute force approch
'''
steps
- iterate on the array with i till n
- check if arr[i] == k then return True
- return False

TC - O(N)

SC - O(1)
'''
def search(arr, n, k):
  for i in arr:
    if i == k:
      return True
  return False

arr = [7,8,1,2,3,3,3,4,5,6]
k = 3
print(search(arr, k))



# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
shrink condition, arr[low] == arr[mid] && arr[mid] == arr[high]



TC - O(log(N/2))

SC - O(1)
'''

def search(arr, k):
  n = len(arr)          
  low = 0                    
  high = n - 1               

  while low <= high:         
    mid = (low + high) // 2  
    if arr[mid] == k:        
      return True
    
    # Handle case where low, mid, and high are equal (duplicates!)
    if arr[low] == arr[mid] and arr[mid] == arr[high]:
      # Move both pointers inward to skip duplicates
      low += 1
      high -= 1
      continue               # Restart loop with new bounds

    # If the left half is sorted
    if arr[low] <= arr[mid]:
      # Check if target is within the left sorted range
      if arr[low] <= k and k <= arr[mid]:
        high = mid - 1       # Narrow search to left half
      else:
        low = mid + 1        # Narrow search to right half
    else:
      # Otherwise, the right half must be sorted
      if arr[mid] <= k and k <= arr[high]:
        low = mid + 1        # Narrow search to right half
      else:
        high = mid - 1       # Narrow search to left half

  return False  # Target not found


arr = [7,8,1,2,3,3,3,4,5,6]
k = 3
print(search(arr, k))



# 10 TODO :  find minimum in rotated sorted array
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://takeuforward.org/data-structure/minimum-in-rotated-sorted-array/

https://www.youtube.com/watch?v=nhEMDKMB44g&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=50

https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/

'''
# method 1 : brute force approch
'''
steps
- take a variable mini = float('inf')
- iterate on the array with i till n
- update mini = min(mini, arr[i])
- return mini

TC - O(N)

SC - O(1)
'''
def findMin(arr):
  n = len(arr)
  mini = float('inf')
  for i in range(n):
    mini = min(mini, arr[i])
  return mini

arr = [4,5,6,7,0,1,2,3]
print(findMin(arr))


# method 2 : better approch
'''
TC - O(log(N))

SC - O(1)
'''
def findMin(arr):
  low = 0
  high = len(arr) - 1
  ans = float('inf')
  while low <= high:
    mid = (low + high) // 2
    # Case 1: The left part of the array is sorted
    if arr[low] <= arr[mid]:
      # The minimum could be the leftmost element
      ans = min(ans, arr[low])
      # Move to the right half, as left half is sorted and minimum is already considered
      low = mid + 1
    else: 
      # Case 2: The right part of the array is sorted
      # The minimum could be the middle element
      ans = min(ans, arr[mid])
      # Move to the left half
      high = mid - 1
  return ans

arr = [4,5,6,7,0,1,2,3]
print(findMin(arr))

# method 3 : optimal solution
'''
TC - O(log(N))

SC - O(1) 
'''
def findMin(arr):
  low = 0
  high = len(arr) - 1
  ans = float('inf')
  while low <= high:
    mid = (low + high) // 2
    # If the subarray is already sorted (no rotation in this part)
    if arr[low] <= arr[high]:
      # The smallest element is at 'low'
      ans = min(ans, arr[low])    
      # Since it's sorted, we can break early          
      break
    if arr[low] <= arr[mid]:
      ans = min(ans, arr[low])
      low = mid + 1
    else:
      ans = min(ans, arr[mid])
      high = mid - 1
  return ans

arr = [4,5,6,7,0,1,2,3]
print(findMin(arr))


# 11 TODO : find out how many times has an array been rotated
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/arrays/find-out-how-many-times-the-array-has-been-rotated/

https://www.youtube.com/watch?v=jtSiWTPLwd0&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=51

https://bit.ly/3dEvWJD


find the index where the element is smallest

'''
# method 1 : brute force approch
'''
TC - O(N)

SC - O(1)
'''
def findRotated(arr):
  n = len(arr)
  mini = float('inf')
  index = -1
  for i in range(n):
    if arr[i] < mini:
      mini = arr[i]
      index = i
  return index

arr = [4,5,6,7,0,1,2,3]
print(findRotated(arr))


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution, using binary search
'''
TC - O(log(N))

SC - O(1)
'''
def findRotated(arr):
  low = 0
  high = len(arr) - 1
  ans = float("inf")
  index = -1
  while low <= high:
    mid = (low + high) // 2  # Find the middle index
    # Case 1: If the current subarray is already sorted
    if arr[low] <= arr[high]:
      # The smallest element is at the low index in this sorted subarray
      if arr[low] < ans:          
        ans = arr[low]
        index = low
      break  # Since the subarray is sorted, no need to continue

    # Case 2: Left half is sorted
    if arr[low] <= arr[mid]:
      # Compare and update the smallest value found so far
      if arr[low] < ans:           
        ans = arr[low]
        index = low
      # Move to the right half since the smallest value isn't in the left
      low = mid + 1

    # Case 3: Right half is unsorted, so minimum is in the left half
    else:
      # Compare and update the smallest value found so far
      if arr[mid] < ans:          
        ans = arr[mid]
        index = mid
      # Move to the left half
      high = mid - 1

arr = [4,5,6,7,0,1,2,3]
print(findRotated(arr))



# 12 TODO : single element in a sorted array
'''


ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/data-structure/search-single-element-in-a-sorted-array/

https://www.youtube.com/watch?v=AZOmHuHadxQ&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=52

https://leetcode.com/problems/single-element-in-a-sorted-array/

(even, odd) - element is on right half
(odd, even) - element is on left half

'''
# method 1 : brute force approch
'''
TC - O(N)

SC - O(1)
'''
def singleNonDuplicate(arr):
  n = len(arr) 
  if n == 1:
    return arr[0]

  for i in range(n):
    # Case 1: First element of the array
    if i == 0:
      # If the first element is not equal to the second, it's the unique one
      if arr[i] != arr[i + 1]:
        return arr[i]
    # Case 2: Last element of the array
    elif i == n - 1:
      # If the last element is not equal to the second-last, it's the unique one
      if arr[i] != arr[i - 1]:
        return arr[i]
    # Case 3: Middle elements
    else:
      # If the current element is different from both its neighbors, it's the unique one
      if arr[i] != arr[i - 1] and arr[i] != arr[i + 1]:
        return arr[i]
  return -1

arr = [1, 1, 2, 2, 3, 3, 4, 5, 5, 6, 6]
ans = singleNonDuplicate(arr)
print("The single element is:", ans)

# method 2 : better approch
'''
TC - O(N)

SC - O(1)
'''
def singleNonDuplicate(arr):
  n = len(arr)  # Size of the array
  ans = 0
  # XOR all the elements
  for i in range(n):
    ans = ans ^ arr[i]
  return ans

arr = [1, 1, 2, 2, 3, 3, 4, 5, 5, 6, 6]
ans = singleNonDuplicate(arr)
print("The single element is:", ans)

# method 3 : optimal solution
'''
(even, odd) - element is on right half, eliminate left
(odd, even) - element is on left half, eliminate right


TC - O(log(N))

SC - O(1) 
'''
def singleNonDuplicate(arr):
  n = len(arr)  # Get the length of the array

  # Edge case 1: If there's only one element, it's the unique one
  if n == 1:
      return arr[0]
  
  # Edge case 2: If the first element is not equal to the second, it's unique
  if arr[0] != arr[1]:
      return arr[0]
  
  # Edge case 3: If the last element is not equal to the second last, it's unique
  if arr[n - 1] != arr[n - 2]:
      return arr[n - 1]

  # Initialize binary search boundaries
  low = 1
  high = n - 2

  # Binary search loop
  while low <= high:
    mid = (low + high) // 2  # Calculate middle index

    # Check if the mid element is the unique one
    if arr[mid] != arr[mid + 1] and arr[mid] != arr[mid - 1]:
      return arr[mid]

    # Determine which half of the array to search next:
    # If mid is odd and equals the previous element (pair is on the left)
    # OR mid is even and equals the next element (pair is on the left)
    if (mid % 2 == 1 and arr[mid] == arr[mid - 1]) or (mid % 2 == 0 and arr[mid] == arr[mid + 1]):
      # Move search to the right half
      low = mid + 1
    else:
      # Otherwise, move search to the left half
      high = mid - 1

  # If no unique element found (should not happen with valid input)
  return -1


arr = [1, 1, 2, 2, 3, 3, 4, 5, 5, 6, 6]
ans = singleNonDuplicate(arr)
print("The single element is:", ans)



# 13 TODO : find peak element
'''
ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/data-structure/peak-element-in-array/

https://www.youtube.com/watch?v=cXxmbemS6XM&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=53

https://leetcode.com/problems/find-peak-element/#:~:text=Find%20Peak%20Element%20%2D%20LeetCode&text=A%20peak%20element%20is%20an,to%20any%20of%20the%20peaks.

peak element, arr[i-1] < arr[i] and arr[i] > arr[i+1]
'''
# method 1 : brute force approch
'''
TC - O(N)

SC - O(1)
'''
def findPeakElement(arr):
  n = len(arr)  # Get the size of the input array

  # Iterate through each element in the array
  for i in range(n):
    # Check if the current element is a "peak":
    # A peak is an element that is greater than its neighbors.
    # Special handling for the first and last elements:
    # - If i == 0: only need to check if arr[0] > arr[1]
    # - If i == n - 1: only need to check if arr[n - 1] > arr[n - 2]
    # - Otherwise: arr[i] should be greater than both arr[i - 1] and arr[i + 1]
    if (i == 0 or arr[i - 1] < arr[i]) and (i == n - 1 or arr[i] > arr[i + 1]):
      return i  # Return the index of the peak element

  # This line will rarely execute; it's a fallback in case no peak is found
  # (which shouldn't happen in a valid input with at least one peak)
  return -1

arr = [1, 2, 3, 4, 5, 6, 7, 8, 5, 1]
ans = findPeakElement(arr)
print("The peak is at index:", ans)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
TC - O(log(N))

SC - O(1) 

solution can have one peak or multiple peak or any from multiple peak
[1, 2, 3, 4, 5, 6, 7, 8, 5, 1]  -> 7
[1, 5, 1, 2, 1]  -> 1 or 3 (both are valid peaks)

'''
def findPeakElement(arr):
  n = len(arr) 
  # Handle edge case 1: If there's only one element, it's a peak by default
  if n == 1:
      return 0
  # Edge case 2: If the first element is greater than the second, it's a peak
  if arr[0] > arr[1]:
      return 0
  # Edge case 3: If the last element is greater than the second last, it's a peak
  if arr[n - 1] > arr[n - 2]:
      return n - 1
  # Initialize binary search boundaries, excluding the first and last element
  low = 1
  high = n - 2
  while low <= high:
      mid = (low + high) // 2  
      # Check if the middle element is a peak:
      # A peak is greater than both its left and right neighbors
      if arr[mid - 1] < arr[mid] and arr[mid] > arr[mid + 1]:
          return mid  # Found a peak at index 'mid'
      # If the middle element is increasing (greater than the left neighbor),
      # then a peak must exist on the right side
      elif arr[mid] > arr[mid - 1]:
          low = mid + 1  # Move search space to the right half
      # Otherwise, a peak exists on the left side
      elif arr[mid] > arr[mid + 1]:
          high = mid - 1  # Move search space to the left half
      else:
        low = mid + 1
  # Fallback return; shouldn't happen in a valid input
  return -1

arr = [1, 2, 3, 4, 5, 6, 7, 8, 5, 1]
ans = findPeakElement(arr)
print("The peak is at index:", ans)




# endregion




# region 4.2 BINARY SEARCH on ANSWERS
# -----------------------------------
'''
range of binary search will always be given in the question
'''

# 1 TODO :  find square root of a number in log(n) 
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

https://takeuforward.org/binary-search/finding-sqrt-of-a-number-using-binary-search/

https://www.youtube.com/watch?v=Bsv3FPUX_BA&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=54

https://bit.ly/3JXtGcE

'''
# method 1 : brute force approch
'''
TC - O(N)

SC - O(1)
'''
def floorSqrt(n):
  ans = 0
  # Linear search on the answer space:
  for i in range(1, n+1):
    val = i * i
    if val <= n:
      ans = i
    else:
      break
  return ans

n = 28
ans = floorSqrt(n)
print("The floor of square root of", n, "is:", ans)

# method 2 : better approch
'''
TC - O(log(N))

SC - O(1)
'''
import math
def floorSqrt(n):
    ans = int(math.sqrt(n))
    return ans

n = 28
ans = floorSqrt(n)
print("The floor of square root of", n, "is:", ans)

# method 3 : optimal solution
'''
TC - O(log(N))

SC - O(1)
'''
def floorSqrt(n):
  low = 1
  high = n
  # Binary search on the answers:
  while low <= high:
    mid = (low + high) // 2
    val = mid * mid             # ---> core logic
    if val <= n:
      # Eliminate the left half:
      low = mid + 1
    else:
      # Eliminate the right half:
      high = mid - 1
  return high

n = 28
ans = floorSqrt(n)
print("The floor of square root of", n, "is:", ans)

# 2 TODO : find the Nth root of a number using binary search
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

https://takeuforward.org/data-structure/nth-root-of-a-number-using-binary-search/


https://bit.ly/3zWNyrL

https://www.youtube.com/watch?v=Bsv3FPUX_BA&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=54


'''
# method 1 : brute force approch
'''
TC - O(M)

SC - O(1)
'''
def func(b, exp):
  ans = 1
  base = b
  while exp > 0:
    if exp % 2:
      exp -= 1
      ans = ans * base
    else:
      exp //= 2
      base = base * base
  return ans

def NthRoot(n: int, m: int) -> int:
  for i in range(1, m + 1):
    val = func(i, n)
    if val == m:
      return i
    elif val > m:
      break
  return -1

n = 3
m = 27
ans = NthRoot(n, m)
print("The answer is:", ans)

# ğŸ‘‰ğŸ‘‰ğŸ‘‰method 2 : better approch SELF
# def root(n, m):
#   ans = -1
#   low = 0 
#   high = m  
#   while low <= high:
#     mid = (low + high)//2
#     print(low, mid, high)
#     if (mid**n) == m:
#       ans = mid
#     if (mid**n)  < m:
#       low = mid + 1
#     else:
#       high = mid - 1
#   return ans  

# method 3 : optimal solution
'''
def func(mid, n, m) -> stop from overflow condition ie 10**9

TC - O(log2(N) * log2(M))

SC - O(1) 
'''
def func(mid, n, m):
  ans = 1  # Start with ans = 1
  # Multiply mid, n times to compute mid^n
  for i in range(1, n + 1):
    ans *= mid
    # Early exit if the result exceeds m â€” no need to continue
    if ans > m:
      return 2  # mid^n is greater than m
  # If result exactly equals m, we found the root
  if ans == m:
      return 1  # mid is the nth root of m
  # Otherwise, mid^n is less than m
  return 0

def NthRoot(n: int, m: int) -> int:
  low = 1
  high = m
  while low <= high:
    mid = (low + high) // 2
    midN = func(mid, n, m)  
    if midN == 1:
      return mid  # Found the nth root
    elif midN == 0:
      low = mid + 1  # mid^n is too small; try higher
    else:
      high = mid - 1  # mid^n is too large; try lower
  return -1

n = 3
m = 27
ans = NthRoot(n, m)
print("The answer is:", ans)

# 3 TODO : koko eating bananas, 
'''
ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/binary-search/koko-eating-bananas/

https://leetcode.com/problems/koko-eating-bananas/

https://www.youtube.com/watch?v=rjEJeYCasHs&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=56


Retun the minimum integer k such that she can eat all the bananas within h hours.
'''
# method 1 : brute force approch
'''
TC - O(max(a[]) * N)

SC - O(1)
'''
import math
def findMax(v):
  maxi = float('-inf')
  n = len(v)
  # Find the maximum
  for i in range(n):
    maxi = max(maxi, v[i])
  return maxi

def calculateTotalHours(v, hourly):
  totalH = 0
  n = len(v)
  # Find total hours
  for i in range(n):
    totalH += math.ceil(v[i] / hourly)
  return totalH

def minimumRateToEatBananas(v, h):
  # Find the maximum number
  maxi = findMax(v)

  # Find the minimum value of k
  for i in range(1, maxi+1):
    reqTime = calculateTotalHours(v, i)
    if reqTime <= h:
      return i

  # Dummy return statement
  return maxi

v = [7, 15, 6, 3]
h = 8
ans = minimumRateToEatBananas(v, h)
print("Koko should eat at least", ans, "bananas/hr.")



# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''

TC - O(N * log(max(a[])))

SC - O(1)
'''
import math

def findMax(v):
  maxi = float('-inf')
  n = len(v)
  # Find the maximum
  for i in range(n):
    maxi = max(maxi, v[i])
  return maxi

def calculateTotalHours(v, hourly):
  totalH = 0
  n = len(v)
  # Find total hours
  for i in range(n):
    totalH += math.ceil(v[i] / hourly)
  return totalH

def minimumRateToEatBananas(v, h):
  low = 1
  high = findMax(v)

  # Apply binary search
  while low <= high:
    mid = (low + high) // 2
    totalH = calculateTotalHours(v, mid)
    if totalH <= h:
      high = mid - 1
    else:
      low = mid + 1
  return low

v = [7, 15, 6, 3]
h = 8
ans = minimumRateToEatBananas(v, h)
print("Koko should eat at least", ans, "bananas/hr.")



# â­â­â­ PATTERN CHANGE : find min/max using a helper function
# 4 TODO : minimum days to make M bouquets
'''


ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/arrays/minimum-days-to-make-m-bouquets/

https://www.youtube.com/watch?v=TXAuxeYBTdg&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=57

https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/

'''
# method 1 : brute force approch
'''

Time Complexity: O((max(arr[])-min(arr[])+1) * N), where {max(arr[]) -> maximum element of the array, min(arr[]) -> minimum element of the array, N = size of the array}.
Reason: We are running a loop to check our answers that are in the range of [min(arr[]), max(arr[])]. For every possible answer, we will call the possible() function. Inside the possible() function, we are traversing the entire array, which results in O(N).

Space Complexity: O(1) as we are not using any extra space to solve this problem.  

''' 
def possible(arr, day, m, k):
  n = len(arr)  # Get the total number of flowers
  cnt = 0       # Count of consecutive flowers bloomed by 'day'
  noOfB = 0     # Number of bouquets made so far

  # Traverse through each flower
  for i in range(n):
    if arr[i] <= day:
      # Flower is bloomed by 'day'; increase consecutive count
      cnt += 1
    else:
      # If flower not bloomed, check how many bouquets can be made from previous group
      noOfB += cnt // k  # integer division gives full bouquets
      cnt = 0  # reset the count since this flower breaks the streak

  # After the loop, check leftover consecutive bloomed flowers
  noOfB += cnt // k
  # Return whether we can make at least 'm' bouquets
  return noOfB >= m

def roseGarden(arr, k, m):
  val = m * k  # Total flowers needed to make m bouquets of size k
  n = len(arr)

  # If not enough flowers in total, it's impossible
  if val > n:
    return -1

  # Find the minimum and maximum bloom days in the array
  mini = float('inf')
  maxi = float('-inf')
  for i in range(n):
    mini = min(mini, arr[i])
    maxi = max(maxi, arr[i])

  # Try every day from earliest bloom to latest
  for i in range(mini, maxi + 1):
    if possible(arr, i, m, k):
      return i  # Found the earliest day we can make m bouquets
  # If no such day found, return -1
  return -1

arr = [7, 7, 7, 7, 13, 11, 12, 7]
k = 3
m = 2
ans = roseGarden(arr, k, m)
if ans == -1:
  print("We cannot make m bouquets.")
else:
  print("We can make bouquets on day", ans)





# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(log(max(arr[])-min(arr[])+1) * N), where {max(arr[]) -> maximum element of the array, min(arr[]) -> minimum element of the array, N = size of the array}.
Reason: We are applying binary search on our answers that are in the range of [min(arr[]), max(arr[])]. For every possible answer â€˜midâ€™, we will call the possible() function. Inside the possible() function, we are traversing the entire array, which results in O(N).

Space Complexity: O(1) as we are not using any extra space to solve this problem.
'''
def possible(arr, day, m, k):
  n = len(arr)  # Get the total number of flowers
  cnt = 0       # Count of consecutive flowers bloomed by 'day'
  noOfB = 0     # Number of bouquets made so far

  # Traverse through each flower
  for i in range(n):
    if arr[i] <= day:
      # Flower is bloomed by 'day'; increase consecutive count
      cnt += 1
    else:
      # If flower not bloomed, check how many bouquets can be made from previous group
      noOfB += cnt // k  # integer division gives full bouquets
      cnt = 0  # reset the count since this flower breaks the streak

  # After the loop, check leftover consecutive bloomed flowers
  noOfB += cnt // k
  # Return whether we can make at least 'm' bouquets
  return noOfB >= m

def roseGarden(arr, k, m):
  val = m * k
  n = len(arr)  # size of the array
  if val > n:
    return -1  # impossible case
  # find maximum and minimum
  mini = float('inf')
  maxi = float('-inf')
  for i in range(n):
    mini = min(mini, arr[i])
    maxi = max(maxi, arr[i])

  # apply binary search
  low = mini
  high = maxi
  while low <= high:
    mid = (low + high) // 2
    if possible(arr, mid, m, k):
      high = mid - 1
    else:
      low = mid + 1
  return low

arr = [7, 7, 7, 7, 13, 11, 12, 7]
k = 3
m = 2
ans = roseGarden(arr, k, m)
if ans == -1:
  print("We cannot make m bouquets.")
else:
  print("We can make bouquets on day", ans)


# 5 TODO : find the smallest divisors
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/arrays/find-the-smallest-divisor-given-a-threshold/

https://www.youtube.com/watch?v=UvBKTVaG6U8&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=58

https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/

'''
# method 1 : brute force approch
'''
Time Complexity: O(max(arr[])*N), where max(arr[]) = maximum element in the array, N = size of the array.
Reason: We are using nested loops. The outer loop runs from 1 to max(arr[]) and the inner loop runs for N times.

Space Complexity: O(1) as we are not using any extra space to solve this problem. 
'''

import math
def smallestDivisor(arr, limit):
  n = len(arr)  # size of array
  maxi = max(arr)
  # Find the smallest divisor
  for d in range(1, maxi+1):
    # Find the summation result
    sum = 0
    for i in range(n):
      sum += math.ceil(arr[i] / d)
    if sum <= limit:
      return d
  return -1

arr = [1, 2, 3, 4, 5]
limit = 8
ans = smallestDivisor(arr, limit)
print("The minimum divisor is:", ans)




# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(log(max(arr[]))*N), where max(arr[]) = maximum element in the array, N = size of the array.
Reason: We are applying binary search on our answers that are in the range of [1, max(arr[])]. For every possible divisor â€˜midâ€™, we call the sumByD() function. Inside that function, we are traversing the entire array, which results in O(N).

Space Complexity: O(1) as we are not using any extra space to solve this problem.
'''
import math

def sumByD(arr, div):
  n = len(arr)  # size of array
  # Find the summation of division values
  total_sum = 0
  for i in range(n):
    total_sum += math.ceil(arr[i] / div)
  return total_sum

def smallestDivisor(arr, limit):
  n = len(arr)
  if n > limit:
    return -1
  low = 1
  high = max(arr)

  # Apply binary search
  while low <= high:
    mid = (low + high) // 2
    if sumByD(arr, mid) <= limit:
      high = mid - 1
    else:
      low = mid + 1
  return low

arr = [1, 2, 3, 4, 5]
limit = 8
ans = smallestDivisor(arr, limit)
print("The minimum divisor is:", ans)


# 6 TODO : capacity to ship packages within D days
'''
ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/arrays/capacity-to-ship-packages-within-d-days/

https://www.youtube.com/watch?v=MG-Ac4TAvTY&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=59

https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/

'''
# method 1 : brute force approch
'''
Time Complexity: O(N * (sum(weights[]) - max(weights[]) + 1)), where sum(weights[]) = summation of all the weights, max(weights[]) = maximum of all the weights, N = size of the weights array.
Reason: We are using a loop from max(weights[]) to sum(weights[]) to check all possible weights. Inside the loop, we are calling findDays() function for each weight. Now, inside the findDays() function, we are using a loop that runs for N times.

Space Complexity: O(1) as we are not using any extra space to solve this problem.
'''
def findDays(weights, cap):
  days = 1  # Start with the first day
  load = 0  # Current load for the day
  n = len(weights)  # Total number of packages

  # Go through each package
  for i in range(n):
    # If adding the current weight exceeds capacity,
    # we need to move to the next day
    if load + weights[i] > cap:
      days += 1            # Increment the number of days
      load = weights[i]    # Start the new day with this package
    else:
      # Add the weight to the current day's load
      load += weights[i]
  return days  # Return the total number of days needed for this capacity


def leastWeightCapacity(weights: List[int], d: int) -> int:
  # Find the maximum and the summation
  maxi = max(weights)
  summation = sum(weights)
  for i in range(maxi, summation + 1):
    if findDays(weights, i) <= d:
      return i
  # dummy return statement
  return -1

weights = [5, 4, 5, 2, 3, 4, 5, 6]
d = 5
ans = leastWeightCapacity(weights, d)
print("The minimum capacity should be:", ans)





# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(N * log(sum(weights[]) - max(weights[]) + 1)), where sum(weights[]) = summation of all the weights, max(weights[]) = maximum of all the weights, N = size of the weights array.
Reason: We are applying binary search on the range [max(weights[]), sum(weights[])]. For every possible answer â€˜midâ€™, we are calling findDays() function. Now, inside the findDays() function, we are using a loop that runs for N times.

Space Complexity: O(1) as we are not using any extra space to solve this problem.
'''
def findDays(weights, cap):
  days = 1  # Start with the first day
  load = 0  # Current load for the day
  n = len(weights)  # Total number of packages

  # Go through each package
  for i in range(n):
    # If adding the current weight exceeds capacity,
    # we need to move to the next day
    if load + weights[i] > cap:
      days += 1            # Increment the number of days
      load = weights[i]    # Start the new day with this package
    else:
      # Add the weight to the current day's load
      load += weights[i]
  return days  # Return the total number of days needed for this capacity

def leastWeightCapacity(weights, d):
    # Find the maximum and the summation
    low = max(weights)
    high = sum(weights)
    while low <= high:
        mid = (low + high) // 2
        numberOfDays = findDays(weights, mid)
        if numberOfDays <= d:
            # Eliminate right half
            high = mid - 1
        else:
            # Eliminate left half
            low = mid + 1
    return low

weights = [5, 4, 5, 2, 3, 4, 5, 6]
d = 5
ans = leastWeightCapacity(weights, d)
print("The minimum capacity should be:", ans)


# 7 TODO : ğŸ‘‰ğŸ‘‰ğŸ‘‰ IMPORTANT : Kth missing positive number
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/arrays/kth-missing-positive-number/

https://www.youtube.com/watch?v=uZ0N_hZpyps&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=60

https://leetcode.com/problems/kth-missing-positive-number/#:~:text=Given%20an%20array%20arr%20of,13%2C...%5D.


'''
# method 1 : brute force approch
'''

Time Complexity: O(N), N = size of the given array.
Reason: We are using a loop that traverses the entire given array in the worst case.

Space Complexity: O(1) as we are not using any extra space to solve this problem.
'''

def missingK(vec, n, k):
  # Iterate through the first n elements of the list
  for i in range(n):
    # If the current number in the list is less than or equal to k,
    # it means k is not missing and we need to look further.
    if vec[i] <= k:
      k += 1  # Increment k to check for the next missing number
    else:
      break  # If the current number is greater than k, k is the missing number
  return k  # Return the k-th missing number

vec = [4, 7, 9, 10]
n = 4
k = 4
ans = missingK(vec, n, k)
print("The missing number is:", ans)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
missing = arr[high] - (high + 1)
more = k - missing
ans = arr[high] + more
    = arr[high] + k - missing
    = arr[high] + k - [arr[high] - (high + 1)]
    = arr[high] + k - arr[high] + (high + 1)
    = k + high + 1

OR 
low = high + 1
=> ans = low + k

Time Complexity: O(logN), N = size of the given array.
Reason: We are using the simple binary search algorithm.

Space Complexity: O(1) as we are not using any extra space to solve this problem.
'''
def missingK(vec, n, k):
  low = 0
  high = n - 1
  while low <= high:
    mid = (low + high) // 2  # Find the middle index
    # Calculate how many numbers are missing up to index mid
    # For a perfect sequence (no missing numbers), vec[i] should be i+1
    # So, missing = vec[mid] - (mid + 1)
    missing = vec[mid] - (mid + 1)
    if missing < k:
        # Not enough numbers are missing yet, search in the right half
        low = mid + 1
    else:
        # Enough or too many numbers are missing, search in the left half
        high = mid - 1
  # After the loop, 'high' is the last index where missing < k
  # So, the answer is k more than the number of elements before it (i.e., high + 1)
  return k + high + 1

vec = [4, 7, 9, 10]
n = 4
k = 4
ans = missingK(vec, n, k)
print("The missing number is:", ans)




# â­â­â­ PATTERN CHANGE : min(max) OR max(min)
# 8 TODO : aggressive cows, (minimum distance between the cows) is maximum
'''
ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/data-structure/aggressive-cows-detailed-solution/

https://www.youtube.com/watch?v=R_Mfw4ew-Vo&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=61
https://www.youtube.com/watch?v=7wOzDqsfXy0

https://www.spoj.com/problems/AGGRCOW/

'''
# method 1 : brute force approch
'''
Time Complexity: O(NlogN) + O(N *(max(stalls[])-min(stalls[]))), where N = size of the array, max(stalls[]) = maximum element in stalls[] array, min(stalls[]) = minimum element in stalls[] array.
Reason: O(NlogN) for sorting the array. We are using a loop from 1 to max(stalls[])-min(stalls[]) to check all possible distances. Inside the loop, we are calling canWePlace() function for each distance. Now, inside the canWePlace() function, we are using a loop that runs for N times.

Space Complexity: O(1) as we are not using any extra space to solve this problem.
'''
# Helper function to check if we can place 'cows' cows in stalls such that
# the minimum distance between any two cows is at least 'dist'
def canWePlace(stalls, dist, cows):
  n = len(stalls)  # number of stalls
  cntCows = 1  # we can always place the first cow in the first stall
  last = stalls[0]  # position where the last cow was placed

  # Try placing the rest of the cows
  for i in range(1, n):
    # If the current stall is at least 'dist' away from the last placed cow
    if stalls[i] - last >= dist:
      cntCows += 1  # place another cow
      last = stalls[i]  # update the last placed position
    # If we have placed all cows, return True
    if cntCows >= cows:
      return True
  # Not enough cows could be placed
  return False

# Main function to find the largest minimum distance between cows
def aggressiveCows(stalls, k):
  n = len(stalls)  # number of stalls
  stalls.sort()  # sort the stall positions in ascending order
  limit = stalls[n - 1] - stalls[0]  # maximum possible distance
  # Try all distances from 1 to 'limit'
  for i in range(1, limit + 1):
    # If it's not possible to place all cows with at least 'i' distance
    if not canWePlace(stalls, i, k):
      return i - 1  # return the last successful distance
  # If all distances from 1 to limit worked
  return limit

stalls = [0, 3, 4, 7, 10, 9]
k = 4
ans = aggressiveCows(stalls, k)
print("The maximum possible minimum distance is:", ans)






# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal approch
'''
Time Complexity: O(NlogN) + O(N * log(max(stalls[])-min(stalls[]))), where N = size of the array, max(stalls[]) = maximum element in stalls[] array, min(stalls[]) = minimum element in stalls[] array.
Reason: O(NlogN) for sorting the array. We are applying binary search on [1, max(stalls[])-min(stalls[])]. Inside the loop, we are calling canWePlace() function for each distance, â€˜midâ€™. Now, inside the canWePlace() function, we are using a loop that runs for N times.

Space Complexity: O(1) as we are not using any extra space to solve this problem.
'''
# Helper function to check if we can place 'cows' cows in stalls such that
# the minimum distance between any two cows is at least 'dist'
def canWePlace(stalls, dist, cows):
  n = len(stalls)  # number of stalls
  cntCows = 1  # we can always place the first cow in the first stall
  last = stalls[0]  # position where the last cow was placed

  # Try placing the rest of the cows
  for i in range(1, n):
    # If the current stall is at least 'dist' away from the last placed cow
    if stalls[i] - last >= dist:
      cntCows += 1  # place another cow
      last = stalls[i]  # update the last placed position
    # If we have placed all cows, return True
    if cntCows >= cows:
      return True
  # Not enough cows could be placed
  return False

def aggressiveCows(stalls, k):
  n = len(stalls)  
  stalls.sort()  # sort the stalls                        # ---> remember to sort() the arr
  low = 1
  high = stalls[n - 1] - stalls[0]
  while low <= high:
    mid = (low + high) // 2
    if canWePlace(stalls, mid, k):
      low = mid + 1
    else:
      high = mid - 1
  return high

stalls = [0, 3, 4, 7, 10, 9]
k = 4
ans = aggressiveCows(stalls, k)
print("The maximum possible minimum distance is:", ans)




# 9 TODO : book allocation problem
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/data-structure/allocate-minimum-number-of-pages/

https://www.youtube.com/watch?v=Z0hwjftStI4&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=63

https://bit.ly/3MZQOct


'''
# method 1 : brute force approch
'''
Time Complexity: O(N * (sum(arr[])-max(arr[])+1)), where N = size of the array, sum(arr[]) = sum of all array elements, max(arr[]) = maximum of all array elements.
Reason: We are using a loop from max(arr[]) to sum(arr[]) to check all possible numbers of pages. Inside the loop, we are calling the countStudents() function for each number. Now, inside the countStudents() function, we are using a loop that runs for N times.

Space Complexity:  O(1) as we are not using any extra space to solve this problem.
'''
# Helper function to count how many students are needed if each student gets at most 'pages' pages
def countStudents(arr, pages):
  n = len(arr)  # number of books
  students = 1  # start by assigning books to the first student
  pagesStudent = 0  # pages allocated to the current student
  for i in range(n):
    # If adding this book doesn't exceed the current student's limit
    if pagesStudent + arr[i] <= pages:
      pagesStudent += arr[i]  # assign the book to current student
    else:
      students += 1  # assign the book to a new student
      pagesStudent = arr[i]  # start a new allocation
  return students  # return total students needed with the given 'pages' limit


# Main function to find the minimum number of pages a student has to read
def findPages(arr, n, m):
  if m > n:
    return -1  # Not enough books for each student to get at least one

  low = max(arr)  # A student must be assigned at least the largest single book
  high = sum(arr)  # One student reads all books, the upper bound
  # Brute-force search from the minimum to maximum possible pages
  for pages in range(low, high + 1):
    if countStudents(arr, pages) == m:
      return pages  # found the minimum number of pages per student
  return low  # fallback (shouldnâ€™t usually be hit if input is valid)

arr = [25, 46, 28, 49, 24]
n = 5
m = 4
ans = findPages(arr, n, m)
print("The answer is:", ans)



# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(N * log(sum(arr[])-max(arr[])+1)), where N = size of the array, sum(arr[]) = sum of all array elements, max(arr[]) = maximum of all array elements.
Reason: We are applying binary search on [max(arr[]), sum(arr[])]. Inside the loop, we are calling the countStudents() function for the value of â€˜midâ€™. Now, inside the countStudents() function, we are using a loop that runs for N times.

Space Complexity:  O(1) as we are not using any extra space to solve this problem.
''' 
# Helper function to count how many students are needed if each student gets at most 'pages' pages
def countStudents(arr, pages):
  n = len(arr)  # number of books
  students = 1  # start by assigning books to the first student
  pagesStudent = 0  # pages allocated to the current student
  for i in range(n):
    # If adding this book doesn't exceed the current student's limit
    if pagesStudent + arr[i] <= pages:
      pagesStudent += arr[i]  # assign the book to current student
    else:
      students += 1  # assign the book to a new student
      pagesStudent = arr[i]  # start a new allocation
  return students  # return total students needed with the given 'pages' limit

def findPages(arr, n, m):
  # book allocation impossible
  if m > n:
      return -1
  low = max(arr)
  high = sum(arr)
  while low <= high:
    mid = (low + high) // 2
    students = countStudents(arr, mid)
    if students > m:
      low = mid + 1
    else:
      high = mid - 1
  return low

arr = [25, 46, 28, 49, 24]
n = 5
m = 4
ans = findPages(arr, n, m)
print("The answer is:", ans)



# 10 TODO :  split array - largest sum

'''
ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/arrays/split-array-largest-sum/

https://www.youtube.com/watch?v=thUd_WJn6wk&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=63

https://leetcode.com/problems/split-array-largest-sum/

'''

# method 1 : Brute force method
'''
reference -> same as books allocation problem 

Time Complexity: O(N * (sum(arr[])-max(arr[])+1)), where N = size of the array, sum(arr[]) = sum of all array elements, max(arr[]) = maximum of all array elements.
Reason: We are using a loop from max(arr[]) to sum(arr[]) to check all possible values of time. Inside the loop, we are calling the countPartitions() function for each number. Now, inside the countPartitions() function, we are using a loop that runs for N times.

Space Complexity:  O(1) as we are not using any extra space to solve this problem.
'''



def countPartitions(a, maxSum):
    n = len(a)  # size of array
    partitions = 1
    subarraySum = 0
    for i in range(n):
        if subarraySum + a[i] <= maxSum:
            # insert element to current subarray
            subarraySum += a[i]
        else:
            # insert element to next subarray
            partitions += 1
            subarraySum = a[i]
    return partitions

def largestSubarraySumMinimized(a, k):
    low = max(a)
    high = sum(a)

    for maxSum in range(low, high+1):
        if countPartitions(a, maxSum) == k:
            return maxSum
    return low

a = [10, 20, 30, 40]
k = 2
ans = largestSubarraySumMinimized(a, k)
print("The answer is:", ans)




# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(N * log(sum(arr[])-max(arr[])+1)), where N = size of the array, sum(arr[]) = sum of all array elements, max(arr[]) = maximum of all array elements.
Reason: We are applying binary search on [max(arr[]), sum(arr[])]. Inside the loop, we are calling the countPartitions() function for the value of â€˜midâ€™. Now, inside the countPartitions() function, we are using a loop that runs for N times.

Space Complexity:  O(1) as we are not using any extra space to solve this problem.
'''



def countPartitions(a, maxSum):
    n = len(a)  # size of array
    partitions = 1
    subarraySum = 0
    for i in range(n):
        if subarraySum + a[i] <= maxSum:
            # insert element to current subarray
            subarraySum += a[i]
        else:
            # insert element to next subarray
            partitions += 1
            subarraySum = a[i]
    return partitions

def largestSubarraySumMinimized(a, k):
    low = max(a)
    high = sum(a)
    # Apply binary search
    while low <= high:
        mid = (low + high) // 2
        partitions = countPartitions(a, mid)
        if partitions > k:
            low = mid + 1
        else:
            high = mid - 1
    return low

a = [10, 20, 30, 40]
k = 2
ans = largestSubarraySumMinimized(a, k)
print("The answer is:", ans)




# 11 TODO : painter's partition
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/arrays/painters-partition-problem/


https://www.codingninjas.com/studio/problems/painter-s-partition-problem_1089557?utm_source=striver&utm_medium=website&utm_campaign=a_zcoursetuf



'''
# method 1 : brute force approch
'''
Time Complexity: O(N * (sum(arr[])-max(arr[])+1)), where N = size of the array, sum(arr[]) = sum of all array elements, max(arr[]) = maximum of all array elements.
Reason: We are using a loop from max(arr[]) to sum(arr[]) to check all possible values of time. Inside the loop, we are calling the countPainters() function for each number. Now, inside the countPainters() function, we are using a loop that runs for N times.

Space Complexity:  O(1) as we are not using any extra space to solve this problem.
'''



def countPainters(boards, time):
    n = len(boards)  # size of array
    painters = 1
    boardsPainter = 0
    for i in range(n):
        if boardsPainter + boards[i] <= time:
            # allocate board to current painter
            boardsPainter += boards[i]
        else:
            # allocate board to next painter
            painters += 1
            boardsPainter = boards[i]
    return painters


def findLargestMinDistance(boards, k):
    low = max(boards)
    high = sum(boards)

    for time in range(low, high+1):
        if countPainters(boards, time) <= k:
            return time
    return low


boards = [10, 20, 30, 40]
k = 2
ans = findLargestMinDistance(boards, k)
print("The answer is:", ans)





# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(N * log(sum(arr[])-max(arr[])+1)), where N = size of the array, sum(arr[]) = sum of all array elements, max(arr[]) = maximum of all array elements.
Reason: We are applying binary search on [max(arr[]), sum(arr[])]. Inside the loop, we are calling the countPainters() function for the value of â€˜midâ€™. Now, inside the countPainters() function, we are using a loop that runs for N times.

Space Complexity:  O(1) as we are not using any extra space to solve this problem.
'''



def countPainters(boards, time):
    n = len(boards)  # size of array
    painters = 1
    boardsPainter = 0
    for i in range(n):
        if boardsPainter + boards[i] <= time:
            # allocate board to current painter
            boardsPainter += boards[i]
        else:
            # allocate board to next painter
            painters += 1
            boardsPainter = boards[i]
    return painters

def findLargestMinDistance(boards, k):
    low = max(boards)
    high = sum(boards)
    # Apply binary search
    while low <= high:
        mid = (low + high) // 2
        painters = countPainters(boards, mid)
        if painters > k:
            low = mid + 1
        else:
            high = mid - 1
    return low

boards = [10, 20, 30, 40]
k = 2
ans = findLargestMinDistance(boards, k)
print("The answer is:", ans)





# 12 TODO : minimize max distance in gas station
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/arrays/minimise-maximum-distance-between-gas-stations/


https://leetcode.com/problems/minimize-max-distance-to-gas-station/


'''
# method 1 : brute force approch
'''
Time Complexity: O(k*n) + O(n), n = size of the given array, k = no. of gas stations to be placed.
Reason: O(k*n) to insert k gas stations between the existing stations with maximum distance. Another O(n) for finding the answer i.e. the maximum distance.

Space Complexity: O(n-1) as we are using an array to keep track of placed gas stations.
'''



def minimiseMaxDistance(arr, k):
    n = len(arr)  # size of array
    howMany = [0] * (n - 1)

    # Pick and place k gas stations:
    for gasStations in range(1, k + 1):
        # Find the maximum section and insert the gas station:
        maxSection = -1
        maxInd = -1
        for i in range(n - 1):
            diff = arr[i + 1] - arr[i]
            sectionLength = diff / (howMany[i] + 1)
            if sectionLength > maxSection:
                maxSection = sectionLength
                maxInd = i
        # insert the current gas station:
        howMany[maxInd] += 1

    # Find the maximum distance i.e. the answer:
    maxAns = -1
    for i in range(n - 1):
        diff = arr[i + 1] - arr[i]
        sectionLength = diff / (howMany[i] + 1)
        maxAns = max(maxAns, sectionLength)
    return maxAns

arr = [1, 2, 3, 4, 5]
k = 4
ans = minimiseMaxDistance(arr, k)
print("The answer is:", ans)




# method 2 : better approch
'''
Time Complexity: O(nlogn + klogn),  n = size of the given array, k = no. of gas stations to be placed.
Reason: Insert operation of priority queue takes logn time complexity. O(nlogn) for inserting all the indices with distance values and O(klogn) for placing the gas stations.

Space Complexity: O(n-1)+O(n-1)
Reason: The first O(n-1) is for the array to keep track of placed gas stations and the second one is for the priority queue.
'''



import heapq

def minimiseMaxDistance(arr, k):
    n = len(arr)  # size of array.
    howMany = [0] * (n - 1)
    pq = []

    # insert the first n-1 elements into pq
    # with respective distance values:
    for i in range(n - 1):
        heapq.heappush(pq, ((-1)*(arr[i + 1] - arr[i]), i))

    # Pick and place k gas stations:
    for gasStations in range(1, k + 1):
        # Find the maximum section
        # and insert the gas station:
        tp = heapq.heappop(pq)
        secInd = tp[1]

        # insert the current gas station:
        howMany[secInd] += 1

        inidiff = arr[secInd + 1] - arr[secInd]
        newSecLen = inidiff / (howMany[secInd] + 1)
        heapq.heappush(pq, (newSecLen*(-1), secInd))

    return pq[0][0]*(-1)

arr = [1, 2, 3, 4, 5]
k = 4
ans = minimiseMaxDistance(arr, k)
print("The answer is:", ans)




# method 3 : optimal solution
'''
Time Complexity: O(n*log(Len)) + O(n), n = size of the given array, Len = length of the answer space.
Reason: We are applying binary search on the answer space. For every possible answer, we are calling the function numberOfGasStationsRequired() that takes O(n) time complexity. And another O(n) for finding the maximum distance initially.

Space Complexity: O(1) as we are using no extra space to solve this problem.
'''


def numberOfGasStationsRequired(dist, arr):
    n = len(arr)  # size of the array
    cnt = 0
    for i in range(1, n):
        numberInBetween = ((arr[i] - arr[i - 1]) / dist)
        if (arr[i] - arr[i - 1]) == (dist * numberInBetween):
            numberInBetween -= 1
        cnt += numberInBetween
    return cnt


def minimiseMaxDistance(arr, k):
    n = len(arr)  # size of the array
    low = 0
    high = 0

    # Find the maximum distance:
    for i in range(n - 1):
        high = max(high, arr[i + 1] - arr[i])

    # Apply Binary search:
    diff = 1e-6
    while high - low > diff:
        mid = (low + high) / 2.0
        cnt = numberOfGasStationsRequired(mid, arr)
        if cnt > k:
            low = mid
        else:
            high = mid

    return high


arr = [1, 2, 3, 4, 5]
k = 4
ans = minimiseMaxDistance(arr, k)
print("The answer is:", ans)





# 13 TODO : median of 2 sorted arrays
'''


ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´



https://takeuforward.org/data-structure/median-of-two-sorted-arrays-of-different-sizes/


https://leetcode.com/problems/median-of-two-sorted-arrays/


'''
# method 1 : brute force approch
'''
Time Complexity: O(n1+n2), where  n1 and n2 are the sizes of the given arrays.
Reason: We traverse through both arrays linearly.

Space Complexity: O(n1+n2), where  n1 and n2 are the sizes of the given arrays.
Reason: We are using an extra array of size (n1+n2) to solve this problem.
'''


def median(a, b):
    # size of two given arrays:
    n1, n2 = len(a), len(b)

    arr3 = []
    # apply the merge step:
    i, j = 0, 0
    while i < n1 and j < n2:
        if a[i] < b[j]:
            arr3.append(a[i])
            i += 1
        else:
            arr3.append(b[j])
            j += 1

    # copy the left-out elements:
    arr3.extend(a[i:])
    arr3.extend(b[j:])

    # Find the median:
    n = n1 + n2
    if n % 2 == 1:
        return float(arr3[n // 2])

    median = (arr3[n // 2] + arr3[(n // 2) - 1]) / 2.0
    return median


if __name__ == "__main__":
    a = [1, 4, 7, 10, 12]
    b = [2, 3, 6, 15]
    print("The median of two sorted arrays is", "{:.1f}".format(median(a, b)))




# method 2 : better approch
'''
Time Complexity: O(n1+n2), where  n1 and n2 are the sizes of the given arrays.
Reason: We traverse through both arrays linearly.

Space Complexity: O(1), as we are not using any extra space to solve this problem.
'''



def median(a, b):
    # size of two given arrays:
    n1, n2 = len(a), len(b)
    n = n1 + n2  # total size
    # required indices:
    ind2 = n // 2
    ind1 = ind2 - 1
    cnt = 0
    ind1el, ind2el = -1, -1

    # apply the merge step:
    i, j = 0, 0
    while i < n1 and j < n2:
        if a[i] < b[j]:
            if cnt == ind1:
                ind1el = a[i]
            if cnt == ind2:
                ind2el = a[i]
            cnt += 1
            i += 1
        else:
            if cnt == ind1:
                ind1el = b[j]
            if cnt == ind2:
                ind2el = b[j]
            cnt += 1
            j += 1

    # copy the left-out elements:
    while i < n1:
        if cnt == ind1:
            ind1el = a[i]
        if cnt == ind2:
            ind2el = a[i]
        cnt += 1
        i += 1
    while j < n2:
        if cnt == ind1:
            ind1el = b[j]
        if cnt == ind2:
            ind2el = b[j]
        cnt += 1
        j += 1

    # Find the median:
    if n % 2 == 1:
        return float(ind2el)

    return float(ind1el + ind2el) / 2.0


if __name__ == "__main__":
    a = [1, 4, 7, 10, 12]
    b = [2, 3, 6, 15]
    print("The median of two sorted arrays is", "{:.1f}".format(median(a, b)))




# method 3 : optimal solution
'''
Time Complexity: O(log(min(n1,n2))), where n1 and n2 are the sizes of two given arrays.
Reason: We are applying binary search on the range [0, min(n1, n2)].

Space Complexity: O(1) as no extra space is used.
'''



def median(a, b):
    n1, n2 = len(a), len(b)
    # if n1 is bigger swap the arrays:
    if n1 > n2:
        return median(b, a)

    n = n1 + n2  # total length
    left = (n1 + n2 + 1) // 2  # length of left half
    # apply binary search:
    low, high = 0, n1
    while low <= high:
        mid1 = (low + high) // 2
        mid2 = left - mid1
        # calculate l1, l2, r1, and r2;
        l1, l2, r1, r2 = float('-inf'), float('-inf'), float('inf'), float('inf')
        if mid1 < n1:
            r1 = a[mid1]
        if mid2 < n2:
            r2 = b[mid2]
        if mid1 - 1 >= 0:
            l1 = a[mid1 - 1]
        if mid2 - 1 >= 0:
            l2 = b[mid2 - 1]

        if l1 <= r2 and l2 <= r1:
            if n % 2 == 1:
                return max(l1, l2)
            else:
                return (float(max(l1, l2)) + float(min(r1, r2))) / 2.0

        # eliminate the halves:
        elif l1 > r2:
            high = mid1 - 1
        else:
            low = mid1 + 1
    return 0  # dummy statement


a = [1, 4, 7, 10, 12]
b = [2, 3, 6, 15]
print("The median of two sorted arrays is {:.1f}".format(median(a, b)))





# 14 TODO : Kth element of 2 sorted arrays
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/k-th-element-of-two-sorted-arrays/


https://bit.ly/3Amcomr


'''
'''
Time Complexity: O(m+n), where m and n are the sizes of the given arrays.
Reason: We traverse through both arrays linearly.

Space Complexity: O(m+n), where m and n are the sizes of the given arrays.

Reason: We are using an extra array of size (m+n) to solve this problem.
'''

def kthElement(a, b, m, n, k):
    arr3 = []

    # Apply the merge step:
    i, j = 0, 0
    while i < m and j < n:
        if a[i] < b[j]:
            arr3.append(a[i])
            i += 1
        else:
            arr3.append(b[j])
            j += 1

    # Copy the left-out elements:
    arr3.extend(a[i:])
    arr3.extend(b[j:])
    return arr3[k - 1]

if __name__ == "__main__":
    a = [2, 3, 6, 7, 9]
    b = [1, 4, 8, 10]
    print("The k-th element of two sorted arrays is:", kthElement(a, b, len(a), len(b), 5))




# method 2 : better approch
'''
Time Complexity: O(m+n), where m and n are the sizes of the given arrays.
Reason: We traverse through both arrays linearly.

Space Complexity: O(1), as we are not using any extra space to solve this problem.
'''
def kthElement(a, b, m, n, k):
    ele = -1
    cnt = 0  # counter
    # apply the merge step:
    i, j = 0, 0
    while i < m and j < n:
        if a[i] < b[j]:
            if cnt == k - 1:
                ele = a[i]
            cnt += 1
            i += 1
        else:
            if cnt == k - 1:
                ele = b[j]
            cnt += 1
            j += 1

    # copy the left-out elements:
    while i < m:
        if cnt == k - 1:
            ele = a[i]
        cnt += 1
        i += 1
    while j < n:
        if cnt == k - 1:
            ele = b[j]
        cnt += 1
        j += 1
    return ele
            
a = [2, 3, 6, 7, 9]
b = [1, 4, 8, 10]
print("The k-th element of two sorted arrays is:", kthElement(a, b, len(a), len(b), 5))
        
        


# method 3 : optimal solution
'''
Time Complexity: O(log(min(m, n))), where m and n are the sizes of two given arrays.
Reason: We are applying binary search on the range [max(0, k-n2), min(k, n1)]. The range length <= min(m, n).

Space Complexity: O(1), as we are not using any extra space to solve this problem.
'''


def kthElement(a, b, m, n, k):
    if m > n:
        return kthElement(b, a, n, m, k)

    left = k  # length of left half

    # apply binary search:
    low = max(0, k - n)
    high = min(k, m)
    while low <= high:
        mid1 = (low + high) // 2
        mid2 = left - mid1
        # calculate l1, l2, r1, and r2
        l1 = float('-inf')
        l2 = float('-inf')
        r1 = float('inf')
        r2 = float('inf')
        if mid1 < m:
            r1 = a[mid1]
        if mid2 < n:
            r2 = b[mid2]
        if mid1 - 1 >= 0:
            l1 = a[mid1 - 1]
        if mid2 - 1 >= 0:
            l2 = b[mid2 - 1]

        if l1 <= r2 and l2 <= r1:
            return max(l1, l2)

        # eliminate the halves:
        elif l1 > r2:
            high = mid1 - 1
        else:
            low = mid1 + 1

    return 0  # dummy statement
            
            
a = [2, 3, 6, 7, 9]
b = [1, 4, 8, 10]
print("The k-th element of two sorted arrays is:", kthElement(a, b, len(a), len(b), 5))
        
        



# endregion




# region 4.3 BINARY SEARCH on 2D ARRAY
# ------------------------------------

# 1 TODO :  find the row with maximum number of 1's
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/arrays/find-the-row-with-maximum-number-of-1s/

https://www.youtube.com/watch?v=SCz-1TtYxDI&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=68

https://bit.ly/3QNDw2W

'''
# method 1 : brute force approch
'''
Time Complexity: O(n X m), where n = given row number, m = given column number.
Reason: We are using nested loops running for n and m times respectively.

Space Complexity: O(1) as we are not using any extra space.
'''
def rowWithMax1s(matrix, n, m):
  cnt_max = 0
  index = -1

  # traverse the matrix:
  for i in range(n):
    cnt_ones = sum(matrix[i])
    if cnt_ones > cnt_max:
      cnt_max = cnt_ones
      index = i
  return index

if __name__ == "__main__":
  matrix = [[1, 1, 1], [0, 0, 1], [0, 0, 0]]
  n = 3
  m = 3
  print("The row with maximum no. of 1's is:", rowWithMax1s(matrix, n, m))




# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(n X logm), where n = given row number, m = given column number.
Reason: We are using a loop running for n times to traverse the rows. Then we are applying binary search on each row with m columns.

Space Complexity: O(1) as we are not using any extra space.
'''
# Function to find the first index where the value is >= x in a sorted array
def lowerBound(arr, n, x):
    low = 0
    high = n - 1
    ans = n  # default answer if x is not found (i.e., all elements are < x)
    # Binary search to find the lower bound
    while low <= high:
        mid = (low + high) // 2
        # If current element is greater than or equal to x, it could be a valid answer
        if arr[mid] >= x:
            ans = mid  # store current index as potential answer
            high = mid - 1  # try to find a smaller index on the left
        else:
            low = mid + 1  # search in the right half
    return ans  # returns index of the first element >= x

# Function to find the row with the maximum number of 1s in a binary matrix
def rowWithMax1s(matrix, n, m):
  cnt_max = 0  # to store the maximum count of 1s seen so far
  index = -1   # to store the index of the row with the most 1s
  # Traverse all rows of the matrix
  for i in range(n):
    # Use lowerBound to find the first 1 in the row (since rows are sorted)
    cnt_ones = m - lowerBound(matrix[i], m, 1)  # total 1s = total columns - index of first 1
    # Update max count and row index if this row has more 1s
    if cnt_ones > cnt_max:
      cnt_max = cnt_ones
      index = i
  return index  # returns the index of the row with the maximum 1s

matrix = [[1, 1, 1], [0, 0, 1], [0, 0, 0]]
n = 3
m = 3
print("The row with maximum no. of 1's is:", rowWithMax1s(matrix, n, m))




# 2 TODO : search in a 2 D matrix
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/search-in-a-sorted-2d-matrix/


https://leetcode.com/problems/search-a-2d-matrix/

'''
# method 1 : brute force approch
'''
Time Complexity: O(N X M), where N = given row number, M = given column number.
Reason: In order to traverse the matrix, we are using nested loops running for n and m times respectively.

Space Complexity: O(1) as we are not using any extra space.
'''

def searchMatrix(matrix, target):
    n = len(matrix)
    m = len(matrix[0])

    # traverse the matrix:
    for i in range(n):
        for j in range(m):
            if matrix[i][j] == target:
                return True
    return False

matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
result = searchMatrix(matrix, 8)
print("true" if result else "false")




# method 2 : better approch
'''
Time Complexity: O(N + logM), where N = given row number, M = given column number.
Reason: We are traversing all rows and it takes O(N) time complexity. But for all rows, we are not applying binary search rather we are only applying it once for a particular row. That is why the time complexity is O(N + logM) instead of O(N*logM).

Space Complexity: O(1) as we are not using any extra space.
'''



def binarySearch(nums, target):
    n = len(nums) # size of the array
    low, high = 0, n - 1

    # Perform the steps:
    while low <= high:
        mid = (low + high) // 2
        if nums[mid] == target:
            return True
        elif target > nums[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return False

def searchMatrix(matrix, target):
    n = len(matrix)
    m = len(matrix[0])

    for i in range(n):
        if matrix[i][0] <= target <= matrix[i][m - 1]:
            return binarySearch(matrix[i], target)
    return False

matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
result = searchMatrix(matrix, 8)
print("true" if result else "false")



# method 3 : optimal solution
'''
convert 1D array index into 2D array coordinate
row = index // column_len
col = index % column_len

Time Complexity: O(log(NxM)), where N = given row number, M = given column number.
Reason: We are applying binary search on the imaginary 1D array of size NxM.

Space Complexity: O(1) as we are not using any extra space.
'''


def searchMatrix(matrix, target):
    n = len(matrix)
    m = len(matrix[0])

    # apply binary search:
    low = 0
    high = n * m - 1
    while low <= high:
        mid = (low + high) // 2
        row = mid // m
        col = mid % m
        if matrix[row][col] == target:
            return True
        elif matrix[row][col] < target:
            low = mid + 1
        else:
            high = mid - 1
    return False

matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
result = searchMatrix(matrix, 8)
print("true" if result else "false")





# 3 TODO : search in a row and column wise sorted matrix
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://takeuforward.org/arrays/search-in-a-row-and-column-wise-sorted-matrix/


https://leetcode.com/problems/search-a-2d-matrix-ii/


'''
# method 1 : brute force approch
'''
Time Complexity: O(N X M), where N = given row number, M = given column number.
Reason: In order to traverse the matrix, we are using nested loops running for n and m times respectively.

Space Complexity: O(1) as we are not using any extra space.
'''



def searchElement(matrix, target):
    n = len(matrix)
    m = len(matrix[0])

    # Traverse the matrix:
    for i in range(n):
        for j in range(m):
            if matrix[i][j] == target:
                return True
    return False

matrix = [
    [1, 4, 7, 11, 15],
    [2, 5, 8, 12, 19],
    [3, 6, 9, 16, 22],
    [10, 13, 14, 17, 24],
    [18, 21, 23, 26, 30]
]

result = searchElement(matrix, 8)
print("true" if result else "false")




# method 2 : better approch
'''
Time Complexity: O(N*logM), where N = given row number, M = given column number.
Reason: We are traversing all rows and it takes O(N) time complexity. And for all rows, we are applying binary search. So, the total time complexity is O(N*logM).

Space Complexity: O(1) as we are not using any extra space.
'''



def binarySearch(nums, target):
    n = len(nums) # size of the array
    low, high = 0, n - 1

    # Perform the steps:
    while low <= high:
        mid = (low + high) // 2
        if nums[mid] == target:
            return True
        elif target > nums[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return False

def searchElement(matrix, target):
    n = len(matrix)

    for i in range(n):
        flag = binarySearch(matrix[i], target)
        if flag:
            return True
    return False

matrix = [
    [1, 4, 7, 11, 15],
    [2, 5, 8, 12, 19],
    [3, 6, 9, 16, 22],
    [10, 13, 14, 17, 24],
    [18, 21, 23, 26, 30]
]

result = searchElement(matrix, 8)
print("true" if result else "false")




# method 3 : optimal solution
'''
Time Complexity: O(N+M), where N = given row number, M = given column number.
Reason: We are starting traversal from (0, M-1), and at most, we can end up being in the cell (M-1, 0). So, the total distance can be at most (N+M). So, the time complexity is O(N+M).

Space Complexity: O(1) as we are not using any extra space.
'''



def searchElement(matrix, target):
    n = len(matrix)
    m = len(matrix[0])
    row = 0
    col = m - 1

    # Traverse the matrix from (0, m-1):
    while row < n and col >= 0:
        if matrix[row][col] == target:
            return True
        elif matrix[row][col] < target:
            row += 1
        else:
            col -= 1
    return False

matrix = [
    [1, 4, 7, 11, 15],
    [2, 5, 8, 12, 19],
    [3, 6, 9, 16, 22],
    [10, 13, 14, 17, 24],
    [18, 21, 23, 26, 30]
]

result = searchElement(matrix, 8)
print("true" if result else "false")





# 4 TODO : find peak element in a 2D matrix
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://leetcode.com/problems/find-a-peak-element-ii/


'''
# method 1 : brute force approch
'''
Time Complexity: O(m * n), where m is the number of rows and n is the number of columns. We iterate through every element in the matrix.
Space Complexity: O(1), as we are not using any extra space.

'''
def is_peak(matrix, i, j):
    rows, cols = len(matrix), len(matrix[0])
    val = matrix[i][j]
    if i > 0 and matrix[i - 1][j] > val: return False  # check top neighbor
    if i < rows - 1 and matrix[i + 1][j] > val: return False  # check bottom neighbor
    if j > 0 and matrix[i][j - 1] > val: return False  # check left neighbor
    if j < cols - 1 and matrix[i][j + 1] > val: return False  # check right neighbor
    return True

def find_peak_brute(matrix):
    rows, cols = len(matrix), len(matrix[0])
    for i in range(rows):
        for j in range(cols):
            if is_peak(matrix, i, j):
                return matrix[i][j]
    return None

# Example usage:
matrix = [
    [1, 4, 3],
    [8, 9, 4],
    [3, 2, 1]
]
print("Peak Element (Brute Force):", find_peak_brute(matrix))


# method 2 : better approch
'''
Time Complexity: O(m * log n), where m is the number of rows and n is the number of columns. For each column, we do a binary search, and for each column, we perform a linear scan to find the maximum element in that column.
Space Complexity: O(1), as we are using only a few extra variables for indexing.

'''
def find_peak_column(matrix, mid):
    rows = len(matrix)
    max_row = 0
    for i in range(rows):
        if matrix[i][mid] > matrix[max_row][mid]:
            max_row = i
    return max_row

def find_peak_better(matrix):
    rows, cols = len(matrix), len(matrix[0])
    left, right = 0, cols - 1
    
    while left <= right:
        mid = (left + right) // 2
        max_row = find_peak_column(matrix, mid)
        
        # Check if we are at a peak
        if (mid == 0 or matrix[max_row][mid] >= matrix[max_row][mid - 1]) and \
           (mid == cols - 1 or matrix[max_row][mid] >= matrix[max_row][mid + 1]):
            return matrix[max_row][mid]
        elif mid > 0 and matrix[max_row][mid - 1] > matrix[max_row][mid]:
            right = mid - 1
        else:
            left = mid + 1
    return None

# Example usage:
matrix = [
    [1, 4, 3],
    [8, 9, 4],
    [3, 2, 1]
]
print("Peak Element (Better Approach):", find_peak_better(matrix))


# method 3 : optimal solution
'''
Time Complexity: O(m * log n), where m is the number of rows and n is the number of columns. At each iteration of the binary search, we perform a linear scan over the rows to find the maximum in the middle column.
Space Complexity: O(1), as we are not using any extra space except for a few variables for indexing.


'''
def find_peak_column_opt(matrix, mid):
    rows = len(matrix)
    max_row = 0
    for i in range(rows):
        if matrix[i][mid] > matrix[max_row][mid]:
            max_row = i
    return max_row

def find_peak_optimal(matrix):
    rows, cols = len(matrix), len(matrix[0])
    left, right = 0, cols - 1
    
    while left <= right:
        mid = (left + right) // 2
        max_row = find_peak_column_opt(matrix, mid)
        
        # Check if we are at a peak
        if (mid == 0 or matrix[max_row][mid] >= matrix[max_row][mid - 1]) and \
           (mid == cols - 1 or matrix[max_row][mid] >= matrix[max_row][mid + 1]):
            return matrix[max_row][mid]
        elif mid > 0 and matrix[max_row][mid - 1] > matrix[max_row][mid]:
            right = mid - 1
        else:
            left = mid + 1
    return None

# Example usage:
matrix = [
    [1, 4, 3],
    [8, 9, 4],
    [3, 2, 1]
]
print("Peak Element (Optimal Approach):", find_peak_optimal(matrix))


# 5 TODO : matrix median
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/data-structure/median-of-row-wise-sorted-matrix/


https://bit.ly/3PvwuPk




'''
# method 1 : brute force approch
'''
Time Complexity: O(MXN) + O(MXN(log(MXN))), where M = number of row in the given matrix, N = number of columns in the given matrix

Reason: At first, we are traversing the matrix to copy the elements. This takes O(MXN) time complexity. Then we are sorting the linear array of size (MXN), that takes O(MXN(log(MXN))) time complexity

Space Complexity: O(MXN) as we are using a temporary list to store the elements of the matrix.
'''                                    
def median(matrix, m, n):
    lst = []

    # Traverse the matrix and copy the elements to the list:
    for i in range(m):
        for j in range(n):
            lst.append(matrix[i][j])

    # Sort the list:
    lst.sort()
    return lst[(m * n) // 2]

matrix = [
    [1, 2, 3, 4, 5],
    [8, 9, 11, 12, 13],
    [21, 23, 25, 27, 29]
]
m = len(matrix)
n = len(matrix[0])
ans = median(matrix, m, n)
print("The median element is:", ans)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(log(109)) X O(M(logN)), where M = number of rows in the given matrix, N = number of columns in the given matrix

Reason: Our search space lies between [0, 109] as the min(matrix) can be 0 and the max(matrix) can be 109. We are applying binary search in this search space and it takes O(log(109)) time complexity. Then we call countSmallEqual() function for every â€˜midâ€™ and this function takes O(M(logN)) time complexity.

Space Complexity : O(1) as we are not using any extra space
'''
                                    
                         
def upperBound(arr, x, n):
    low = 0
    high = n - 1
    ans = n

    while low <= high:
        mid = (low + high) // 2
        # maybe an answer
        if arr[mid] > x:
            ans = mid
            # look for a smaller index on the left
            high = mid - 1
        else:
            low = mid + 1  # look on the right

    return ans

def countSmallEqual(matrix, m, n, x):
    cnt = 0
    for i in range(m):
        cnt += upperBound(matrix[i], x, n)
    return cnt

def median(matrix, m, n):
    low = float('inf')
    high = float('-inf')

    # point low and high to the right elements
    for i in range(m):
        low = min(low, matrix[i][0])
        high = max(high, matrix[i][n - 1])

    req = (n * m) // 2
    while low <= high:
        mid = (low + high) // 2
        smallEqual = countSmallEqual(matrix, m, n, mid)
        if smallEqual <= req:
            low = mid + 1
        else:
            high = mid - 1

    return low

if __name__ == "__main__":
    matrix = [
        [1, 2, 3, 4, 5],
        [8, 9, 11, 12, 13],
        [21, 23, 25, 27, 29]
    ]
    m = len(matrix)
    n = len(matrix[0])
    ans = median(matrix, m, n)
    print("The median element is:", ans)


# endregion





# region 5.1 STRINGS - EASY
# -------------------------


# 1 TODO :  remove outermost pareanthesis
"""
using stack, 
using number
"""
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://leetcode.com/problems/remove-outermost-parentheses/


'''
# method 1 : brute force approch
'''
Time Complexity (TC):
O(n): We only iterate through the string once where n is the length of the input string.

Space Complexity (SC):
O(n): We are storing the result string.
'''
# def removeOuterParentheses(s: str) -> str:
#   result = ""
#   open_count = 0

#   for char in s:
#     if char == '(':
#       if open_count > 0:
#         result += char
#       open_count += 1
#     else:  # char == ')'
#       open_count -= 1
#       if open_count > 0:
#         result += char

#   return result

# # Example usage
# s = "(()())"
# print(removeOuterParentheses(s))  # Output: ()()


# method 2 : better approch
'''
Time Complexity (TC):
O(n): We iterate through the string once.
Space Complexity (SC):
O(n): The stack holds a subset of the characters.

'''   
def removeOuterParentheses(s: str) -> str:
  stack = []
  result = []

  for char in s:
    if char == '(':
      # Append '(' only if this is not outermost (stack not empty)
      if stack:
        result.append(char)
      stack.append(char)
    else:  # char == ')'
      stack.pop()  # Remove matching '(' from stack
      # Append ')' only if this is not outermost (stack still not empty)
      if stack:
        result.append(char)
  return ''.join(result)

s = "(()())"
print(removeOuterParentheses(s))  # Output: ()()




# method 3 : optimal solution
'''
Time Complexity (TC):
O(n): We traverse the string once, where n is the length of the string.
Space Complexity (SC):
O(n): We are storing the result in the result list

''' 

def removeOuterParentheses(s: str) -> str:
  result = []
  balance = 0
  
  for char in s:
    if char == '(' and balance > 0:
      result.append(char)
    if char == ')':
      if balance > 1:
        result.append(char)
      balance -= 1
    if char == '(':
      balance += 1
  return ''.join(result)

s = "(()())"
print(removeOuterParentheses(s))  # Output: ()()



# 2 TODO : reverse words in a given string / palindrome check
"""


"""
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/data-structure/reverse-words-in-a-string/

https://leetcode.com/problems/reverse-words-in-a-string/

'''
# method 1 : brute force approch
# TC     -      Reverse Words: O(n) â€” splitting the string and reversing the list of words.
# SC     -     Reverse Words: O(n) â€” due to the extra space used by the list of words.
def reverseWords(s: str) -> str:
  words = s.split()
  words.reverse()
  return " ".join(words)

# Example usage
s = "Hello World"
print(reverseWords(s))  # Output: "World Hello"


# method 2 : better approch
# TC     -     Reverse Words: O(n) â€” processing each character once. 
# SC     -     Reverse Words: O(n) â€” due to the stack holding words.
def reverseWords(s: str) -> str:
  stack = []
  word = ""
  
  # Traverse the string and collect words
  for char in s:
    if char == " ":
      if word:
        stack.append(word)
        word = ""
    else:
      word += char
  
  if word:
    stack.append(word)  # Append the last word
  return " ".join(stack[::-1])

s = "Hello World"
print(reverseWords(s))  # Output: "World Hello"


# method 3 : optimal solution
# TC     -      Reverse Words: O(n) â€” reversing the entire string and reversing individual words.
# SC     -      Reverse Words: O(n) â€” space for the list s.
def reverseWords(s: str) -> str:
  s = list(s)  # Convert to list to mutate string (strings are immutable)
  # Reverse the entire string
  s.reverse()
  
  # Reverse each word in the string
  start = 0
  for end in range(len(s)):
    if s[end] == " " or end == len(s) - 1:
      if end == len(s) - 1:
        end += 1
      s[start:end] = s[start:end][::-1]
      start = end + 1
  
  return "".join(s)

# Example usage
s = "Hello World"
print(reverseWords(s))  # Output: "World Hello"


# 3 TODO : largest odd number in a string
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://leetcode.com/problems/largest-odd-number-in-string/



'''
# method 1 : brute force approch
'''
Time Complexity (TC):
O(n): We iterate through the string once, where n is the length of the string.
Space Complexity (SC):
O(n): We store the current number being built, and the maximum odd number found.
''' 
def largestOddNumber(s: str) -> int:
  largest_odd = -1  # Initialize with an invalid number
  current_number = ""
  for char in s:
    if char.isdigit():
      current_number += char  # Build the current number
    else:
      if current_number and int(current_number) % 2 != 0:
        largest_odd = max(largest_odd, int(current_number))  # Check if it's odd
      current_number = ""  # Reset the current number
  
  # Check the last number (if string ends with a number)
  if current_number and int(current_number) % 2 != 0:
    largest_odd = max(largest_odd, int(current_number))
  
  return largest_odd if largest_odd != -1 else None

s = "abc12345678xyz34569"
print(largestOddNumber(s))  # Output: 34569


# method 2 : better approch


# method 3 : optimal solution


# 4 TODO : largest common prefix
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://leetcode.com/problems/longest-common-prefix/

'''
# method 1 : brute force approch
'''
Time Complexity (TC):
O(n * m): We iterate over all strings (n strings) and for each string, we compare characters up to the length of the shortest string (m).
n = number of strings
m = average length of strings
Space Complexity (SC):
O(1): We only use a few extra variables to store the current prefix.

'''
def longestCommonPrefix(strs):
  if not strs:
    return ""

  prefix = strs[0]  # Start with the first string as the initial prefix
  for string in strs[1:]:
    i = 0
    while i < len(prefix) and i < len(string) and prefix[i] == string[i]:
      i += 1
    prefix = prefix[:i]  # Update the prefix to the common part
    if prefix == "":
      break

  return prefix

strs = ["flower", "flow", "flight"]
print(longestCommonPrefix(strs))  # Output: "fl"


# method 2 : better approch
'''
Time Complexity (TC):
O(n * m): We iterate over the first string and for each character, we compare it with all other strings. In the worst case, this takes n comparisons of length m.
n = number of strings
m = length of the first string
Space Complexity (SC):
O(1): We do not use any extra space apart from a few variables.

'''  
def longestCommonPrefix(strs):
  if not strs:
    return ""

  for i in range(len(strs[0])):
    char = strs[0][i]
    for string in strs[1:]:
      if i == len(string) or string[i] != char:
        return strs[0][:i]

  return strs[0]

strs = ["flower", "flow", "flight"]
print(longestCommonPrefix(strs))  # Output: "fl"


# method 3 : optimal solution
'''
Time Complexity (TC):
O(n * m): In the worst case, each divide-and-conquer step involves comparing characters, similar to the brute-force approach.
n = number of strings
m = length of the first string
Space Complexity (SC):
O(log n): This comes from the recursive stack used by the divide-and-conquer algorithm. In the worst case, this is proportional to the height of the recursion tree.

'''    
def longestCommonPrefix(strs):
  if not strs:
      return ""

  def commonPrefix(left, right):
    min_length = min(len(left), len(right))
    for i in range(min_length):
      if left[i] != right[i]:
        return left[:i]
    return left[:min_length]

  def divideAndConquer(strs, left, right):
    if left == right:
      return strs[left]
    mid = (left + right) // 2
    left_prefix = divideAndConquer(strs, left, mid)
    right_prefix = divideAndConquer(strs, mid + 1, right)
    return commonPrefix(left_prefix, right_prefix)

  return divideAndConquer(strs, 0, len(strs) - 1)

# Example usage
strs = ["flower", "flow", "flight"]
print(longestCommonPrefix(strs))  # Output: "fl"


# 5 TODO : isomorphic string
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

- isomorphic means verifying if the characters in one string can be replaced to get the other string, preserving the order of characters. Each character in the first string maps to a unique character in the second string, and vice versa.

https://leetcode.com/problems/isomorphic-strings/


'''
# method 1 : brute force approch
'''
Time Complexity (TC):
O(n^2): In the worst case, for each character in s1, we scan the entire string s2 to check for the mapping.
Space Complexity (SC):
O(1): We don't use any extra space aside from variables used for iteration.

''' 
def count_char_occurrences(s, char, end):
  count = 0
  for k in range(end):
    if s[k] == char:
      count += 1
  return count

def isIsomorphic(s1, s2):
  if len(s1) != len(s2):
    return False
  
  n = len(s1)
  for i in range(n):
    # Count how many times s1[i] appeared before i (excluding i)
    count_s1 = count_char_occurrences(s1, s1[i], i)
    
    # Count how many times s2[i] appeared before i (excluding i)
    count_s2 = count_char_occurrences(s2, s2[i], i)
    
    # If counts don't match, pattern breaks => not isomorphic
    if count_s1 != count_s2:
      return False
  
  return True

# Example usage
s1 = "egg"
s2 = "add"
print(isIsomorphic(s1, s2))  # Output: True



# method 2 : better approch
'''
Time Complexity (TC):
O(n): We iterate over the strings once, and each dictionary operation (insertion and lookup) is O(1).
Space Complexity (SC):
O(n): We use two dictionaries to store the mappings.

'''   
def isIsomorphic(s1, s2):
  # If lengths differ, they can't be isomorphic
  if len(s1) != len(s2):
    return False
  
  # Maps for characters from s1 to s2 and from s2 to s1
  map_s1_to_s2 = {}
  map_s2_to_s1 = {}
  
  # Check each character pair
  for i in range(len(s1)):
    c1 = s1[i]  # char from s1
    c2 = s2[i]  # char from s2
    
    # Check mapping s1->s2
    if c1 in map_s1_to_s2:
      if map_s1_to_s2[c1] != c2:
        return False
    else:
      map_s1_to_s2[c1] = c2
    
    # Check mapping s2->s1
    if c2 in map_s2_to_s1:
      if map_s2_to_s1[c2] != c1:
        return False
    else:
      map_s2_to_s1[c2] = c1
  
  # All characters mapped correctly
  return True

# Example usage
s1 = "egg"
s2 = "add"
print(isIsomorphic(s1, s2))  # Output: True



# method 3 : optimal solution
'''
Time Complexity (TC):
O(n): We iterate over the strings once, and each dictionary operation (insertion and lookup) is O(1).
Space Complexity (SC):
O(n): We use a single dictionary to store the mappings.

'''  
def isIsomorphic(s1, s2):
  # If lengths differ, they can't be isomorphic
  if len(s1) != len(s2):
    return False

  # Dictionary to map characters from s1 to s2
  map_s1_to_s2 = {}
  # Iterate over each character in s1 and s2 simultaneously
  for i in range(len(s1)):
    c1 = s1[i]  # Current char from s1
    c2 = s2[i]  # Current char from s2

    # If c1 is already mapped, check if it maps to c2
    if c1 in map_s1_to_s2:
      # If mapped char differs from c2, not isomorphic
      if map_s1_to_s2[c1] != c2:
        return False
    else:
      # If c2 is already mapped to some other char in s1, return False
      if c2 in map_s1_to_s2.values():
        return False
      # Create new mapping from c1 to c2
      map_s1_to_s2[c1] = c2

  # All characters mapped correctly without conflicts
  return True


# Example usage
s1 = "egg"
s2 = "add"
print(isIsomorphic(s1, s2))  # Output: True


# 6 TODO : check whether one string is a rotation of another
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

https://leetcode.com/problems/rotate-string/

'''
# method 1 : brute force approch
'''
Time Complexity (TC):
O(n^2): We perform n rotations and for each rotation, we compare the strings, which takes O(n) time.
n is the length of the string.
Space Complexity (SC):
O(1): We only use a few extra variables.

''' 
def isRotation(s1, s2):
  # If lengths are different, s2 cannot be a rotation of s1
  if len(s1) != len(s2):
    return False

  n = len(s1)

  # Try each possible rotation starting point 'i' in s1
  for i in range(n):
    match = True  # Assume s2 matches this rotation until proven otherwise

    # Check all characters one by one
    for j in range(n):
      # Compare character from s1 rotated by 'i' with character from s2
      # Use modulo to wrap around the end of s1
      if s1[(i + j) % n] != s2[j]:
        match = False  # Mismatch found, this rotation doesn't match s2
        break         # Stop checking further characters for this rotation

    # If all characters matched, s2 is a rotation of s1
    if match:
      return True

  # No rotation matched s2
  return False

# Example usage
s1 = "abcde"
s2 = "cdeab"
print(isRotation(s1, s2))  # Output: True


# Example usage
s1 = "abcde"
s2 = "cdeab"
print(isRotation(s1, s2))  # Output: True



# method 2 : better approch


# method 3 : optimal solution
'''
Time Complexity (TC):
O(n): The time complexity is O(n) for checking the substring (s2 in s1 + s1), where n is the length of the string.
Space Complexity (SC):
O(n): The space complexity is O(n) due to the concatenation of s1 with itself.
''' 
def isRotation(s1, s2):
    if len(s1) != len(s2):
        return False
    # Concatenate s1 with itself and check if s2 is a substring
    return s2 in (s1 + s1)

# Example usage
s1 = "abcde"
s2 = "cdeab"
print(isRotation(s1, s2))  # Output: True


# 7 TODO : check if two strings are anagram of each other
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

https://takeuforward.org/data-structure/check-if-two-strings-are-anagrams-of-each-other/

https://leetcode.com/problems/valid-anagram/#:~:text=Given%20two%20strings%20s%20and,the%20original%20letters%20exactly%20once.&text=Constraints%3A,.length%20%3C%3D%205%20*%2010

When two strings are anagrams of each other, it means:
- They have exactly the same characters,
- In the same quantity,
- But possibly in a different order.

'''
# method 1 : brute force approch
'''
Time Complexity (TC):
O(n log n): Sorting both strings takes O(n log n) time, where n is the length of the string.
Space Complexity (SC):
O(n): The space complexity is O(n) because we are storing the sorted strings.

''' 
def areAnagrams(s1, s2):
  if len(s1) != len(s2):
    return False
  return sorted(s1) == sorted(s2)

# Example usage
s1 = "listen"
s2 = "silent"
print(areAnagrams(s1, s2))  # Output: True


# method 2 : better approch
'''
Time Complexity (TC):
O(n): We iterate through both strings once to count the characters, which takes O(n) time, where n is the length of the string.
Space Complexity (SC):
O(k): The space complexity is O(k), where k is the number of unique characters in the strings (in the worst case, k could be O(n) if all characters are unique).

'''    
from collections import Counter

def areAnagrams(s1, s2):
  if len(s1) != len(s2):
    return False
  return Counter(s1) == Counter(s2)

# Example usage
s1 = "listen"
s2 = "silent"
print(areAnagrams(s1, s2))  # Output: True


# method 3 : optimal solution
'''
Time Complexity (TC):
O(n): We iterate over the strings twice (once for s1 and once for s2), each taking O(n) time, where n is the length of the strings.
Space Complexity (SC):
O(1): The space complexity is constant, O(1), because the array size is fixed at 256 regardless of the input size (it depends on the number of possible characters, not the length of the strings).

'''
def areAnagrams(s1, s2):
  if len(s1) != len(s2):
    return False
  
  # Assuming ASCII characters (256 possible characters)
  char_count = [0] * 256  # Array to count character frequencies
  for char in s1:
    char_count[ord(char)] += 1  # Increment count for each character in s1
  for char in s2:
    char_count[ord(char)] -= 1  # Decrement count for each character in s2
  # If all counts are zero, the strings are anagrams
  return all(count == 0 for count in char_count)

# Example usage
s1 = "listen"
s2 = "silent"
print(areAnagrams(s1, s2))  # Output: True





# endregion





# region 5.2 STRINGS - MEDIUM
# ---------------------------

# 1 TODO : sort characters by frequency
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://leetcode.com/problems/sort-characters-by-frequency/


'''
# method 1 : brute force approch
'''
Time Complexity (TC):
O(n log n): Sorting the items takes O(n log n) time where n is the number of unique characters in the string.
Space Complexity (SC):
O(n): We are storing the frequency count, which requires O(n) space, where n is the length of the string.
'''
# 1) Brute force: manual frequency count + bubble sort

def frequency_sort_bruteforce(s):
  freq = {}
  # Initialize frequency dictionary keys to 0
  for ch in s:
    freq[ch] = 0
  # Count frequency of each character
  for ch in s:
    freq[ch] += 1

  # Convert dictionary to list of (char, frequency) tuples
  freq_list = list(freq.items())
  n = len(freq_list)
  # Bubble sort the freq_list by frequency descending (inefficient)
  for i in range(n):
    for j in range(0, n - i - 1):
      if freq_list[j][1] < freq_list[j + 1][1]:
        freq_list[j], freq_list[j + 1] = freq_list[j + 1], freq_list[j]
  result = ""
  for ch, count in freq_list:
    result += ch * count
  return result

# Example usage
print(frequency_sort_bruteforce("tree"))  # Output: "eert" or "eetr"



# method 2 : better approch
'''
Time Complexity (TC):
O(n): Counting the frequencies and constructing the result string both take O(n) time, where n is the length of the string.
Space Complexity (SC):
O(n): The space complexity is O(n) because we use additional space for the frequency count and buckets.

''' 
# 2) Better: frequency dictionary + built-in sorted()

def frequency_sort_better(s):
  freq = {}
  # Count frequencies in one pass
  for ch in s:
    if ch not in freq:
      freq[ch] = 0
    freq[ch] += 1
  # Sort the items by frequency descending using sorted() and a lambda
  freq_list = sorted(freq.items(), key=lambda x: x[1], reverse=True)
  # Build the output string
  result = ""
  for ch, count in freq_list:
    result += ch * count
  return result

# Example usage
print(frequency_sort_better("tree"))  # Output: "eert" or "eetr"



# method 3 : optimal solution
'''
Time Complexity (TC):
O(n log k): Constructing the heap takes O(k log k), where k is the number of unique characters in the string (which is at most 26 for lowercase English letters). We also perform an O(n) operation to build the result string, where n is the length of the string.
In the worst case, k is the length of the string, so the time complexity becomes O(n log n).
Space Complexity (SC):
O(n): The space complexity is O(n) because we store the frequencies and heap elements.
'''
# 3) Optimal: bucket sort by frequency for linear time complexity

def frequency_sort_optimal(s):
  freq = {}
  # Count character frequencies
  for ch in s:
    freq[ch] = freq.get(ch, 0) + 1

  max_freq = len(s)  # Maximum possible frequency

  # Create buckets: index is frequency, value is list of chars with that frequency
  buckets = [[] for _ in range(max_freq + 1)]

  # Place each character in the bucket corresponding to its frequency
  for ch, count in freq.items():
    buckets[count].append(ch)

  result = ""
  # Iterate over buckets from high frequency to low
  for count in range(max_freq, 0, -1):
    for ch in buckets[count]:
      # Append char repeated 'count' times
      result += ch * count

  return result

# Example usage
print(frequency_sort_optimal("tree"))  # Output: "eert" or "eetr"



# 2 TODO : maximum nesting depth of parenthesis
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/


'''
# method 1 : brute force approch
'''
Time Complexity (TC):
O(n): We only iterate over the string once, where n is the length of the string.
Space Complexity (SC):
O(1): We use a constant amount of extra space.
'''
def maxDepth(s):
  max_depth = 0
  current_depth = 0
  # Iterate through each character in the string
  for char in s:
    if char == '(':
      current_depth += 1  # Increase depth for opening parenthesis
      max_depth = max(max_depth, current_depth)  # Update the max depth
    elif char == ')':
      current_depth -= 1  # Decrease depth for closing parenthesis
  return max_depth

# Example usage
s = "(1+(2*3)+((8)/4))+1"
print(maxDepth(s))  # Output: 3


# method 2 : better approch


# method 3 : optimal solution




# 3 TODO : roman number to integer and vice versa
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://leetcode.com/problems/roman-to-integer/



'''
# method 1 : brute force approch
'''
Time Complexity (TC):
O(n): We iterate over the string once where n is the length of the Roman numeral string.
Space Complexity (SC):
O(1): We use a fixed-size dictionary for Roman numeral symbols, so the space complexity is constant.
'''
def romanToInt(s):
  roman_map = {
      'I': 1, 'V': 5, 'X': 10, 'L': 50,
      'C': 100, 'D': 500, 'M': 1000
  }
  total = 0
  for i in range(len(s) - 1):
    if roman_map[s[i]] < roman_map[s[i + 1]]:
      total -= roman_map[s[i]]  # Subtraction case
    else:
      total += roman_map[s[i]]
  
  # Add the value of the last character
  total += roman_map[s[-1]]
  
  return total

# Example usage:
print(romanToInt("MCMXCIV"))  # Output: 1994


# method 2 : better approch
'''
Time Complexity (TC):
O(n): The number of iterations is proportional to the number of symbols in the Roman numeral system (12 in total), and the number of subtractions we make depends on the value of num. For large num, this can be considered a constant factor.
Space Complexity (SC):
O(1): We are using a fixed-size list of Roman symbols and constructing a result string.

'''
def intToRoman(num):
  roman_map = [
      (1000, "M"), (900, "CM"), (500, "D"), (400, "CD"),
      (100, "C"), (90, "XC"), (50, "L"), (40, "XL"),
      (10, "X"), (9, "IX"), (5, "V"), (4, "IV"), (1, "I")
  ]
  
  result = []
  for value, symbol in roman_map:
    while num >= value:
      result.append(symbol)
      num -= value
  
  return ''.join(result)

# Example usage:
print(intToRoman(1994))  # Output: "MCMXCIV"


# method 3 : optimal solution
# TC     -      
# SC     -      


# 4 TODO : implement atoi
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

- The atoi function (which stands for "ASCII to Integer") is used to convert a string to an integer. 

https://leetcode.com/problems/string-to-integer-atoi/



'''
# method 1 : brute force approch
'''
Time Complexity (TC):
O(n): We iterate through the string once, where n is the length of the string. Each character is processed once, and the operations inside the loop are constant time operations.
Space Complexity (SC):
O(1): We only use a constant amount of extra space (for variables like result and sign).

'''
def myAtoi(s):
    # Step 1: Remove leading spaces
    s = s.lstrip()

    # Step 2: Handle signs
    if not s:
        return 0

    sign = 1
    if s[0] == '-':
        sign = -1
        s = s[1:]
    elif s[0] == '+':
        s = s[1:]

    # Step 3: Convert digits to integer
    result = 0
    for char in s:
        if char.isdigit():
            result = result * 10 + int(char)
        else:
            break  # Stop on non-digit characters
    
    # Step 4: Apply sign
    result *= sign

    # Step 5: Handle overflow (32-bit signed integer range)
    INT_MAX = 2**31 - 1
    INT_MIN = -2**31

    if result < INT_MIN:
        return INT_MIN
    elif result > INT_MAX:
        return INT_MAX
    return result

# Example usage:
print(myAtoi("42"))  # Output: 42
print(myAtoi("   -42"))  # Output: -42
print(myAtoi("4193 with words"))  # Output: 4193
print(myAtoi("words and 987"))  # Output: 0


# method 2 : better approch
'''
Time Complexity (TC):
O(n): We process each character once, and each step inside the loop takes constant time. Thus, the overall time complexity is O(n), where n is the length of the string.
Space Complexity (SC):
O(1): We only use a constant amount of extra space to store the sign and the result.

'''
def myAtoi(s):
    # Step 1: Remove leading spaces
    s = s.lstrip()

    # Step 2: Handle empty string
    if not s:
        return 0

    # Step 3: Handle the sign
    sign = 1
    if s[0] == '-':
        sign = -1
        s = s[1:]
    elif s[0] == '+':
        s = s[1:]

    # Step 4: Parse digits
    result = 0
    for char in s:
        if char.isdigit():
            result = result * 10 + int(char)
        else:
            break  # Stop parsing if a non-digit is encountered

    # Step 5: Apply the sign
    result *= sign

    # Step 6: Handle overflow and underflow
    INT_MAX = 2**31 - 1
    INT_MIN = -2**31

    if result < INT_MIN:
        return INT_MIN
    elif result > INT_MAX:
        return INT_MAX
    return result

# Example usage:
print(myAtoi("42"))  # Output: 42
print(myAtoi("   -42"))  # Output: -42
print(myAtoi("4193 with words"))  # Output: 4193
print(myAtoi("words and 987"))  # Output: 0


# method 3 : optimal solution
'''
Time Complexity (TC):
O(n): We process each character once. The overall time complexity is linear with respect to the length of the string, where n is the length of the input string.
Space Complexity (SC):
O(1): We only use a constant amount of space for storing the result and the sign.

'''
def myAtoi(s):
    i, n = 0, len(s)
    # Step 1: Skip leading whitespaces
    while i < n and s[i] == ' ':
        i += 1
    
    # Step 2: Check if the string is empty
    if i == n:
        return 0

    # Step 3: Handle signs
    sign = 1
    if s[i] == '-':
        sign = -1
        i += 1
    elif s[i] == '+':
        i += 1
    
    # Step 4: Convert digits to integer
    result = 0
    while i < n and s[i].isdigit():
        result = result * 10 + int(s[i])
        i += 1
    
    # Step 5: Apply sign
    result *= sign

    # Step 6: Handle overflow and underflow
    INT_MAX = 2**31 - 1
    INT_MIN = -2**31

    if result < INT_MIN:
        return INT_MIN
    elif result > INT_MAX:
        return INT_MAX
    return result

# Example usage:
print(myAtoi("42"))  # Output: 42
print(myAtoi("   -42"))  # Output: -42
print(myAtoi("4193 with words"))  # Output: 4193
print(myAtoi("words and 987"))  # Output: 0


# 5 TODO : count number of substrings
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://bit.ly/3CfQfYi



'''
# method 1 : brute force approch
'''
Time Complexity (TC):
O(n^2): We generate all substrings, where n is the length of the string, and we do this in two nested loops. In the worst case, for each character, we generate O(n) substrings.
Space Complexity (SC):
O(n^2): We store all substrings in a set, and in the worst case, there can be O(n^2) distinct substrings.

'''
def countSubstrings(s):
  n = len(s)
  substrings = set()

  # Generate all substrings
  for i in range(n):
    for j in range(i + 1, n + 1):
      substrings.add(s[i:j])
  
  # Return the number of distinct substrings
  return len(substrings)

# Example usage:
print(countSubstrings("abc"))  # Output: 6


# method 2 : better approch
'''
Time Complexity (TC):
O(n log n): Sorting the suffixes takes O(n log n) time, and building the LCP array also takes O(n).
Space Complexity (SC):
O(n): We store the suffix array, LCP array, and related data structures.

'''
def countSubstrings(s):
    # Helper function to build the suffix array
    def suffix_array(s):
        suffixes = [(s[i:], i) for i in range(len(s))]
        suffixes.sort()
        return [suffix[1] for suffix in suffixes]
    
    # Helper function to build the LCP array
    def lcp_array(s, suffix_arr):
        n = len(s)
        lcp = [0] * (n - 1)
        rank = [0] * n
        for i, suf in enumerate(suffix_arr):
            rank[suf] = i
        
        h = 0
        for i in range(n):
            if rank[i] > 0:
                j = suffix_arr[rank[i] - 1]
                while i + h < n and j + h < n and s[i + h] == s[j + h]:
                    h += 1
                lcp[rank[i] - 1] = h
                if h > 0:
                    h -= 1
        return lcp

    n = len(s)
    suffix_arr = suffix_array(s)
    lcp = lcp_array(s, suffix_arr)
    
    total_substrings = n * (n + 1) // 2  # Total number of substrings for a string of length n
    total_lcp = sum(lcp)  # Total overlap from LCP array
    
    return total_substrings - total_lcp

# Example usage:
print(countSubstrings("abc"))  # Output: 6


# method 3 : optimal solution
'''
Time Complexity (TC):
O(n^2): In the worst case, inserting each suffix takes O(n), and there are O(n) suffixes. Thus, the time complexity is O(n^2).
Space Complexity (SC):
O(n^2): In the worst case, the Trie might store all possible substrings, which is O(n^2) space.

''' 
class TrieNode:
    def __init__(self):
        self.children = {}
        self.count = 0

def countSubstrings(s):
    root = TrieNode()
    total_substrings = 0

    # Insert all suffixes of the string into the Trie
    for i in range(len(s)):
        node = root
        for j in range(i, len(s)):
            if s[j] not in node.children:
                node.children[s[j]] = TrieNode()
            node = node.children[s[j]]
            node.count += 1
            total_substrings += 1
    
    return total_substrings

# Example usage:
print(countSubstrings("abc"))  # Output: 6


# 6 TODO : longest pallindromic substring (without using DP)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://leetcode.com/problems/longest-palindromic-substring/

'''
# method 1 : brute force approch
'''
Time Complexity (TC):
O(n^3): We generate all substrings in O(n^2) time and check if each substring is a palindrome in O(n) time.
Space Complexity (SC):
O(1): The space complexity is constant, as we only use a few variables for tracking substrings and the result.


'''
def is_palindrome(s):
    return s == s[::-1]

def longest_palindromic_substring(s):
    n = len(s)
    longest = ""
    
    # Generate all possible substrings
    for i in range(n):
        for j in range(i+1, n+1):
            substring = s[i:j]
            if is_palindrome(substring) and len(substring) > len(longest):
                longest = substring
    
    return longest

# Example usage:
print(longest_palindromic_substring("babad"))  # Output: "bab" or "aba"


# method 2 : better approch
'''
Time Complexity (TC):
O(n^2): We iterate through each character, and for each character, we expand around it, which takes O(n) time in the worst case.
Space Complexity (SC):
O(1): The space complexity is constant, as we only store a few variables for tracking the longest palindrome and the expansion.


'''
def expand_around_center(s, left, right):
    while left >= 0 and right < len(s) and s[left] == s[right]:
        left -= 1
        right += 1
    return s[left+1:right]

def longest_palindromic_substring(s):
    n = len(s)
    if n == 0:
        return ""
    
    longest = ""
    
    for i in range(n):
        # Odd-length palindromes (single center)
        palindrome1 = expand_around_center(s, i, i)
        # Even-length palindromes (two centers)
        palindrome2 = expand_around_center(s, i, i+1)
        
        # Update the longest palindrome found
        longest = max(longest, palindrome1, palindrome2, key=len)
    
    return longest

# Example usage:
print(longest_palindromic_substring("babad"))  # Output: "bab" or "aba"


# method 3 : optimal solution  (Manacher's Algorithm)
'''
Time Complexity (TC):
O(n): The time complexity of Manacher's algorithm is O(n), where n is the length of the string. The algorithm uses a linear pass through the string with constant time operations to expand and update the palindrome radius array.
Space Complexity (SC):
O(n): We use an array p to store the radius of each palindrome and a transformed version of the string with added # characters.


'''
def manacher(s):
    # Preprocess the string: insert '#' between every character (including ends)
    s = '#' + '#'.join(s) + '#'
    n = len(s)
    p = [0] * n  # Array to store the radius of palindrome centered at each character
    center, right = 0, 0  # Center and right edge of the current palindrome
    
    for i in range(n):
        mirror = 2 * center - i  # Mirror position of 'i' with respect to center
        
        if i < right:
            p[i] = min(right - i, p[mirror])  # Use mirror's palindrome length if possible
        
        # Expand around the current center
        while i + p[i] + 1 < n and i - p[i] - 1 >= 0 and s[i + p[i] + 1] == s[i - p[i] - 1]:
            p[i] += 1
        
        # Update the center and right edge if we have expanded past the current right edge
        if i + p[i] > right:
            center, right = i, i + p[i]
    
    # Find the longest palindrome
    max_len, center_index = max((n, i) for i, n in enumerate(p))
    return s[center_index - max_len + 1: center_index + max_len].replace('#', '')

def longest_palindromic_substring(s):
    return manacher(s)

# Example usage:
print(longest_palindromic_substring("babad"))  # Output: "bab" or "aba"


# 7 TODO : sum of beauty of all substring
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/sum-of-beauty-of-all-substrings/



'''
# method 1 : brute force approch
'''
Time Complexity (TC):
O(n^3): The outer loops generate all substrings, which takes O(n^2) time. For each substring, calculating the beauty (frequency count) takes O(n) time in the worst case.
Space Complexity (SC):
O(n): The space complexity is dominated by the space used for storing the frequency count for each substring.

'''
from collections import Counter

def beauty_of_substring(sub):
    freq = Counter(sub)
    return max(freq.values()) - min(freq.values())

def sum_of_beauty(s):
    n = len(s)
    total_beauty = 0

    # Generate all substrings and calculate beauty for each substring
    for i in range(n):
        for j in range(i+1, n+1):
            substring = s[i:j]
            total_beauty += beauty_of_substring(substring)
    
    return total_beauty

# Example usage:
print(sum_of_beauty("aab"))  # Output: 6


# method 2 : better approch
'''
Time Complexity (TC):
O(n^2): For each starting point i, we expand the substring towards the end of the string. Updating the frequency count for each new character takes constant time.
Space Complexity (SC):
O(n): The space complexity is dominated by the frequency dictionary for each substring, which in the worst case can store the frequency of all characters in the string.
'''
from collections import defaultdict

def beauty_of_substring(sub_freq):
    if not sub_freq:
        return 0
    return max(sub_freq.values()) - min(sub_freq.values())

def sum_of_beauty(s):
    n = len(s)
    total_beauty = 0

    # Traverse all possible starting points for substrings
    for i in range(n):
        sub_freq = defaultdict(int)
        
        # Expand the substring and calculate its beauty
        for j in range(i, n):
            sub_freq[s[j]] += 1
            total_beauty += beauty_of_substring(sub_freq)
    
    return total_beauty

# Example usage:
print(sum_of_beauty("aab"))  # Output: 6


# method 3 : optimal solution
'''
Time Complexity (TC):
O(n^2): The time complexity remains O(n^2) because we still need to explore all possible substrings, but the frequency calculations are optimized by maintaining the current max_freq and min_freq while expanding the substring.
Space Complexity (SC):
O(n): The space complexity is still dominated by the frequency dictionary, which can store up to n unique characters in the worst case.

'''
from collections import defaultdict

def sum_of_beauty(s):
    n = len(s)
    total_beauty = 0

    # Traverse all possible starting points for substrings
    for i in range(n):
        sub_freq = defaultdict(int)
        max_freq = 0
        min_freq = float('inf')

        # Expand the substring and calculate its beauty incrementally
        for j in range(i, n):
            char = s[j]
            sub_freq[char] += 1
            max_freq = max(max_freq, sub_freq[char])
            min_freq = min(min_freq, sub_freq[char])
            
            # Beauty of the current substring
            total_beauty += max_freq - min_freq
    
    return total_beauty

# Example usage:
print(sum_of_beauty("aab"))  # Output: 6


# 8 TODO : reverse every word in a substring
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://leetcode.com/problems/reverse-words-in-a-string/



'''
# method 1 : brute force approch
'''
Time Complexity (TC):
O(n): We iterate over the string once to split it into words, and for each word, we reverse it, which takes O(n) time, where n is the length of the string.
Space Complexity (SC):
O(n): We create a list of words and a list of reversed words, which both take space proportional to the length of the string.
'''
def reverse_words_in_substring(s):
    # Split the string into words by space
    words = s.split()
    
    # Reverse each word and join them back into a string
    reversed_words = [word[::-1] for word in words]
    
    return " ".join(reversed_words)

# Example usage:
input_str = "Hello World"
print(reverse_words_in_substring(input_str))  # Output: "olleH dlroW"


# method 2 : better approch
'''
Time Complexity (TC):
O(n): We still iterate over the string once to split it into words and reverse each word, so the time complexity remains O(n).
Space Complexity (SC):
O(n): The space complexity remains O(n) because we store the words in a list, which takes space proportional to the length of the string.


'''
def reverse_words_in_substring(s):
    # Split the string into words by space
    words = s.split()
    
    # Reverse each word and join them back into a string
    for i in range(len(words)):
        words[i] = words[i][::-1]  # In-place reversal of each word
    
    return " ".join(words)

# Example usage:
input_str = "Hello World"
print(reverse_words_in_substring(input_str))  # Output: "olleH dlroW"


# method 3 : optimal solution
'''
Time Complexity (TC):
O(n): We traverse the string once to find the words, and each word is reversed in constant time due to in-place swapping.
Space Complexity (SC):
O(n): The space complexity is O(n) because we convert the string to a list, which takes space proportional to the string length.


'''
def reverse_words_in_substring(s):
    # Convert string to list to manipulate in-place
    s = list(s)
    n = len(s)
    
    def reverse_range(start, end):
        while start < end:
            s[start], s[end] = s[end], s[start]
            start += 1
            end -= 1
    
    # Reverse individual words in the string
    start = 0
    for i in range(n + 1):
        if i == n or s[i] == ' ':
            reverse_range(start, i - 1)
            start = i + 1
    
    return ''.join(s)

# Example usage:
input_str = "Hello World"
print(reverse_words_in_substring(input_str))  # Output: "olleH dlroW"


# endregion






# region 6.1 LINKED LIST - 1D EASY
# --------------------------------

'''
https://www.youtube.com/watch?v=VaECK03Dz-g&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=237
https://www.youtube.com/watch?v=VaECK03Dz-g&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=238
ğŸ‘‰ğŸ‘‰ğŸ‘‰ Summary of this section
class Node:
    def __init__(self, data, next = None):
        self.data = data
        self.next = next
    
class LinkedList:
  def __init__(self):
    self.head = None
  
  def append(self, data):
    new_node = Node(data)
    if not self.head:      # If the list is empty, the new node becomes the head
      self.head = new_node
    else:
      current = self.head
      while current.next:  # Traverse to the last node
          current = current.next
      current.next = new_node  # Add the new node to the end

  def print_list(self):
    current = self.head
    while current:
        print(current.data, end=" -> ")
        current = current.next
    print("None")
  
  def searchElement(self, target):
    temp = self.head
    while temp.next:
      if temp.data == target:
        return True
      else:
        temp = temp.next
    return False
    
  def delete_head_node(self):
    if self.head:
      # case I : if head is the element 
      current = self.head
      self.head = current.next
      current = None
      return self.head
    else:
      return
  
  def add_head_node(self, val):
    if self.head:
      current = self.head
      new_node = Node(val)
      new_node.next = current
      self.head = new_node
      return self.head
    else:
      new_node = Node(val)
      self.head = new_node
      return self.head
    # temp = Node(val, self.head)
    # return temp
    
  def delete_last_node(self):
    if self.head or self.head.next:
      current = self.head
      while current.next.next:
        current = current.next
      current.next = None
      return self.head
    else:
      return
    
  def add_tail_node(self, val):
    if self.head == None:
      return Node(val)
    temp = self.head
    while temp.next:
      temp = temp.next
    new_node = Node(val)
    temp.next = new_node
    return self.head
        
      
    
  def delete_index_node(self, index):
    if self.head or self.head.next:
      if index == 1:
        current = self.head
        self.head = current.next
        current = None
        return self.head
      else:
        count = 0
        current = self.head
        previous = None
        while current:
          count +=1
          if count == index:
            previous.next = previous.next.next
            # previous.next = current.next
            current = None
            break
          previous = current
          current = current.next
        return self.head
  
  def add_value_node(self, value, new_value):
    current = self.head
    if current == None:
        return None
    # Special case: if the head node itself has the target value,
    # insert new node before head and update head
    if current.data == value:
      new_node = Node(new_value, current)
      self.head = new_node
      return self.head
    while current.next:
      counter += 1
      if current.next.data == value:
        new_node = Node(new_value)
        new_node.next = current.next
        current.next = new_node
      current = current.next
    return self.head

  def delete_value_node(self, index):
    if self.head or self.head.next:
      if self.head.data == value:
        current = self.head
        self.head = current.next
        current = None
        return self.head
      else:
        current = self.head
        previous = None
        while current:
          print(current.data)
          if current.data == value:
            previous.next = previous.next.next
            # previous.next = current.next
            current = None
            break
          previous = current
          current = current.next
        return self.head
        
  def add_index_node(self, value, index):
    current = self.head
    if current == None:
      return null
    if index == 1:
      return Node(value, current)
    counter = 0
    while current:
      counter += 1
      if counter == index-1:
        new_node = Node(value)
        new_node.next = current.next
        current.next = new_node
      current = current.next
    return self.head
      
  def size(self):
    counter = 0
    current = self.head
    while current:
      counter += 1 
      current = current.next
    return counter
      
def convertArrToLL(arr):
  linked_list = LinkedList()
  for i in arr:
    linked_list.append(i)
  return linked_list
  
def main_function(arr):
  linked_list = convertArrToLL(arr);
  linked_list_length = linked_list.size()
  target_element = linked_list.searchElement(44)
  # delete_node = linked_list.delete_head_node()
  # delete_node = linked_list.delete_last_node()
  # delete_node = linked_list.delete_index_node(2)
  # delete_node = linked_list.delete_value_node(4)
  print(linked_list.print_list())
  # add_node = linked_list.add_head_node(5)
  # add_node = linked_list.add_tail_node(5)
  # add_node = linked_list.add_index_node(5,3)
  add_node = linked_list.add_value_node(4,4)
  print(linked_list.print_list())
  return None
  
arr = [3,4,7,9]
# arr = []
print(main_function(arr))
'''

# 1 TODO :  introduction to linked list, learn about struct and how is node represented
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/linked-list/linked-list-introduction

https://www.youtube.com/watch?v=Nq7ok-OyEpg&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=237&t=1528s

https://bit.ly/3URZnst

'''
# # method 1 : brute force approch
class Node:
  def __init__(self, data1, next1=None):
    self.data = data1
    self.next = next1
# Creating a new Node with the value from the array
y = Node(2)
# Printing the data stored in the Node
print(y.data)


# 2 TODO : inserting a node in a linked list
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/linked-list/insert-at-the-head-of-a-linked-list

https://www.youtube.com/watch?v=Nq7ok-OyEpg&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=237&t=1528s

https://bit.ly/3w9pEIt

'''
# Node class to represent a linked list node
'''
insert a node :
head 
position
value 
last

Time Complexity: O(1) for inserting the new head of the linked list and O(N) for printing the linked list.

Space Complexity: O(1), as we have not used any extra space.
'''
class Node:
  def __init__(self, data1, next1=None):
    self.data = data1
    self.next = next1

# Function to print the linked list
def printLL(head):
  while head is not None:
    print(head.data, end=" ")
    head = head.next

# Function to insert a new node at the head of the linked list
def insertHead(head, val):
  temp = Node(val, head)
  return temp

if __name__ == "__main__":
  # Sample array and value for insertion
  arr = [12, 8, 5, 7]
  val = 100

  # Creating a linked list with initial elements from the array
  head = Node(arr[0])
  head.next = Node(arr[1])
  head.next.next = Node(arr[2])
  head.next.next.next = Node(arr[3])

  # Inserting a new node at the head of the linked list
  head = insertHead(head, val)

  # Printing the linked list
  printLL(head) 


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 3 TODO : deleting a node in a linked list
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/delete-last-node-of-linked-list/

https://www.youtube.com/watch?v=Nq7ok-OyEpg&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=237&t=1528s

https://leetcode.com/problems/delete-node-in-a-linked-list/


'''
'''
delete a node :
head - start of the list
tail - last of the linked list 
position - when index is given
value - when the node data value is given

Time Complexity: O(N) for traversing the linked list and updating the tail.

Space Complexity: O(1), as we have not used any extra space.
'''
# method 1 : brute force approch
class Node:
  def __init__(self, data, next_node=None):
    self.data = data
    self.next = next_node

# Function to delete the tail of the linked list
def delete_tail(head):
  # Check if the linked list is empty or has only one node
  if head is None or head.next is None:
    return None
  # Create a temporary pointer for traversal
  temp = head
  # Traverse the list until the second-to-last node
  while temp.next.next is not None:
    temp = temp.next
  # Nullify the connection from the second-to-last node to delete the last node
  temp.next = None

  # Return the updated head of the linked list
  return head

# Function to print the linked list
def print_ll(head):
  while head is not None:
    print(head.data, end=" ")
    head = head.next

# Main function
if __name__ == "__main__":
  # Initialize an array with integer values
  arr = [2, 5, 8, 7]

  # Create the linked list with nodes initialized with array values
  head = Node(arr[0])
  head.next = Node(arr[1])
  head.next.next = Node(arr[2])
  head.next.next.next = Node(arr[3])

  # Delete the tail of the linked list
  head = delete_tail(head)

  # Print the modified linked list
  print_ll(head)

# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 4 TODO : find the length of the linked list (learn traversal)
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/linked-list/find-the-length-of-a-linked-list

https://www.youtube.com/watch?v=Nq7ok-OyEpg&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=237&t=1528s

https://bit.ly/3Po7tpf

'''
'''
Since we are iterating over the entire list,  time complexity is O(N).

Space Complexity:
We are not using any extra space, thus space complexity is O(1) or constant.
'''
# method 1 : brute force approch
class Node:
  def __init__(self, data, next_node=None):
    self.data = data
    self.next = next_node
# Function to calculate the length of a linked list
def length_of_linked_list(head):
  cnt = 0
  temp = head
  
  # Traverse the linked list and count nodes
  while temp is not None:
    temp = temp.next
    cnt += 1
  return cnt

# Main function
def main():
  arr = [2, 5, 8, 7]
  # Create a linked list
  head = Node(arr[0])
  head.next = Node(arr[1])
  head.next.next = Node(arr[2])
  head.next.next.next = Node(arr[3])
  # Print the length of the linked list
  print("Length of the linked list:", length_of_linked_list(head))
main()


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 5 TODO : search an element in the linked list
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/linked-list/search-an-element-in-a-linked-list

https://www.youtube.com/watch?v=Nq7ok-OyEpg&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=237&t=1528s
https://bit.ly/3Epriup


'''
'''
Time Complexity: O(N) in the worst case if the element is not found. O(1) in the best case if the element is the first element. 

Space Complexity: O(1) as we did not use any extra space.
'''
class Node:
  def __init__(self, data1, next1=None):
    self.data = data1
    self.next = next1

# Function to check if a given element is present in the linked list
def check_if_present(head, desired_element):
  temp = head

  # Traverse the linked list
  while temp is not None:
    # Check if the current node's data is equal to the desired element
    if temp.data == desired_element:
      return 1  # Return 1 if the element is found

    # Move to the next node
    temp = temp.next

  return 0  # Return 0 if the element is not found in the linked list

# Main function
if __name__ == "__main__":
  # Create a linked list: 1 -> 2 -> 3
  arr = [1, 2, 3]
  head = Node(arr[0])
  head.next = Node(arr[1])
  head.next.next = Node(arr[2])

  val = 3  # Element to be checked for presence in the linked list

  # Call the check_if_present function and print the result
  print(check_if_present(head, val))

# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      



# endregion







# region 6.2 LINKED LIST - DOUBLY  EASY
# -------------------------------------
# 1 TODO :  introduction to linked list, learn about struct and how is node represented
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/linked-list/introduction-to-doubly-linked-list

https://bit.ly/3V9wY1v



'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -  
'''
https://www.youtube.com/watch?v=0eKMU10uEDI&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=239

ğŸ‘‰ğŸ‘‰ğŸ‘‰ all problem summary in this section 
class Node:
  def __init__(self, data, next=None, back=None):
    self.data = data
    self.next = next
    self.back = back

class DoublyLinkedList:
  def __init__(self):
    self.head = None

  def print_list(self):
    current = self.head
    while current:
      print(current.data, end=" <-> ")
      current = current.next
    print("None")

  def searchElement(self, target):
    temp = self.head
    while temp:
      if temp.data == target:
        return True
      temp = temp.next
    return False

  def delete_head_node(self):
    if self.head is None:
      return None
    if self.head.next is None:
      self.head = None
      return None

    temp = self.head
    self.head = temp.next
    self.head.back = None
    temp.next = None
    temp.back = None
    return self.head

  def add_head_node(self, val):
    new_node = Node(val, self.head, None)
    if self.head is not None:
      self.head.back = new_node
    self.head = new_node
    return self.head

  def delete_last_node(self):
    if self.head is None:
      return None
    if self.head.next is None:
      self.head = None
      return None

    temp = self.head
    while temp.next:
      temp = temp.next

    prev = temp.back
    prev.next = None
    temp.back = None
    return self.head

  def add_tail_node(self, val):
    if self.head is None:
      return self.add_head_node(val)

    temp = self.head
    while temp.next:
      temp = temp.next
    new_node = Node(val, None, temp)
    temp.next = new_node
    return self.head

  def delete_index_node(self, index):
    if self.head is None or index < 1:
      return None
    if index == 1:
      return self.delete_head_node()

    temp = self.head
    count = 1
    while temp and count < index:
      temp = temp.next
      count += 1

    if temp is None:
      return self.head  # index out of range

    prev = temp.back
    front = temp.next

    if front is None:  # last node
      prev.next = None
    else:
      prev.next = front
      front.back = prev

    temp.next = None
    temp.back = None
    return self.head

  def delete_value_node(self, value):
    temp = self.head
    while temp:
      if temp.data == value:
        break
      temp = temp.next

    if temp is None:
      return self.head  # value not found

    if temp.back is None:  # head node
      return self.delete_head_node()
    if temp.next is None:  # last node
      return self.delete_last_node()

    prev = temp.back
    front = temp.next
    prev.next = front
    front.back = prev

    temp.next = None
    temp.back = None
    return self.head

  def add_value_node(self, node, value):
    # Insert new node AFTER the given node
    if node is None:
      return self.head
    new_node = Node(value, node.next, node)
    if node.next is not None:
      node.next.back = new_node
    node.next = new_node
    return self.head

  def add_index_node(self, value, index):
    # Insert node with value at position index (1-based)
    if index < 1:
      return self.head
    if index == 1:
      return self.add_head_node(value)

    temp = self.head
    count = 1
    while temp and count < index - 1:
      temp = temp.next
      count += 1

    if temp is None:
      # Index is beyond the length, add at tail
      return self.add_tail_node(value)

    new_node = Node(value, temp.next, temp)
    if temp.next is not None:
      temp.next.back = new_node
    temp.next = new_node
    return self.head

  def size(self):
    counter = 0
    current = self.head
    while current:
      counter += 1
      current = current.next
    return counter

  def convertArrToDLL(self, arr):
    if not arr:
      self.head = None
      return None

    self.head = Node(arr[0])
    prev = self.head
    for i in range(1, len(arr)):
      new_node = Node(arr[i], None, prev)
      prev.next = new_node
      prev = new_node
    return self.head

def main_function(arr):
  dll = DoublyLinkedList()
  dll.convertArrToDLL(arr)

  print("Original list:")
  dll.print_list()

  print("Add node with value 10 at head")
  dll.add_head_node(10)
  dll.print_list()

  print("Add node with value 20 at tail")
  dll.add_tail_node(20)
  dll.print_list()

  print("Add node with value 15 at index 3")
  dll.add_index_node(15, 3)
  dll.print_list()

  print("Add node with value 17 after 2nd node")
  second_node = dll.head.next  # get second node
  dll.add_value_node(second_node, 17)
  dll.print_list()

  print("Delete node at index 4")
  dll.delete_index_node(4)
  dll.print_list()

  print("Delete node with value 15")
  dll.delete_value_node(15)
  dll.print_list()

  print("List size:", dll.size())
  return None

arr = [3, 4, 7, 9]
main_function(arr)

'''

# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : insert a node in DLL
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/data-structure/insert-at-end-of-doubly-linked-list/


https://bit.ly/3QD4hHs




'''
'''
Doubly Linked List Initially:
12 5 8 7 4 
Doubly Linked List After Inserting at the tail with value 10: 
12 5 8 7 4 10

Time Complexity: O(N) The time complexity of this insertion operation is O(N) because we have to traverse the entire list to reach its tail. The complexity would be O(1) if we were given the tail node directly.

Space Complexity: O(1)  The space complexity is also O(1) because we are notusing any extradatastructures to do the operations apart from creating a single new node.
'''
class Node:
    def __init__(self, data, next_node=None, back_node=None):
        """
        Constructor for a Node with data, a reference to the next node, and a reference to the previous node.
        """
        self.data = data
        self.next = next_node
        self.back = back_node

def convertArr2DLL(arr):
    """
    Function to convert an array to a doubly linked list.
    """
    # Create the head node with the first element of the array
    head = Node(arr[0])
    # Initialize 'prev' to the head node
    prev = head

    for i in range(1, len(arr)):
        # Create a new node with data from the array and set its 'back' pointer to the previous node
        temp = Node(arr[i], None, prev)
        # Update the 'next' pointer of the previous node to point to the new node
        prev.next = temp
        # Move 'prev' to the newly created node for the next iteration
        prev = temp

    # Return the head of the doubly linked list
    return head

def print_list(head):
    """
    Function to print the elements of the doubly linked list.
    """
    while head is not None:
        # Print the data in the current node
        print(head.data, end=" ")
        # Move to the next node
        head = head.next

def insert_at_tail(head, k):
    """
    Function to insert a new node with value 'k' at the end of the doubly linked list.
    """
    # Create a new node with data 'k'
    new_node = Node(k)

    # If the doubly linked list is empty, set 'head' to the new node
    if head is None:
        return new_node

    # Traverse to the end of the doubly linked list
    tail = head
    while tail.next is not None:
        tail = tail.next

    # Connect the new node to the last node in the list
    tail.next = new_node
    new_node.back = tail

    return head

# Main program
arr = [12, 5, 8, 7, 4]
head = convertArr2DLL(arr)
print("Doubly Linked List Initially:")
print_list(head)
print("\nDoubly Linked List After Inserting at the tail with value 10:")



# Insert a node with value 10 at the end
head = insert_at_tail(head, 10)
print_list(head) 


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 3 TODO : delete a node in DLL
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/delete-last-node-of-a-doubly-linked-list/


https://bit.ly/3QlEoMx


'''
'''
Time Complexity: O(1) Removing the head of a doubly linked list is a quick operation, taking constant time because it only involves updating references.

Space Complexity: O(1) Deleting the head also has minimal memory usage, using a few extra pointers without regard to the list's size.
'''
class Node:
    def __init__(self, data, next_node=None, back_node=None):
        self.data = data
        self.next = next_node
        self.back = back_node

def convert_arr_to_dll(arr):
    # Create the head node with the first element of the array
    head = Node(arr[0])
    # Initialize 'prev' to the head node
    prev = head

    for i in range(1, len(arr)):
        # Create a new node with data from the array and set its 'back' pointer to the previous node
        temp = Node(arr[i], None, prev)
        # Update the 'next' pointer of the previous node to point to the new node
        prev.next = temp
        # Move 'prev' to the newly created node for the next iteration
        prev = temp

    # Return the head of the doubly linked list
    return head

def print_dll(head):
    while head is not None:
        # Print the data in the current node
        print(head.data, end=" ")
        # Move to the next node
        head = head.next

def delete_tail(head):
    if head is None or head.next is None:
        return None  # If the list is empty or has only one node, return None

    tail = head
    while tail.next is not None:
        # Traverse to the last node (tail)
        tail = tail.next

    new_tail = tail.back
    new_tail.next = None
    tail.back = None

    # Free memory of the deleted node
    del tail

    return head

if __name__ == "__main__":
    arr = [12, 5, 8, 7]
    head = convert_arr_to_dll(arr)

    print("Original Doubly Linked List:", end=" ")
    print_dll(head)

    print("\n\nAfter deleting the tail node:", end=" ")
    head = delete_tail(head)
    print_dll(head)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 4 TODO : reverse in DLL
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

https://takeuforward.org/data-structure/reverse-a-doubly-linked-list/

https://www.youtube.com/watch?v=u3WUW2qe6ww&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=241

https://bit.ly/3w6hUaa

'''
"""
using stack/array,
using swapping of links
"""
# method 1 : brute force approch
'''
pushing  each node data into an array and then reverses it.

Time Complexity : O(2N) During the first traversal, each node's value is pushed into the stack once, which requires O(N) time. Then, during the second iteration, the values are popped from the stack and used to update the nodes. 

Space Complexity : O(N) This is because we are using an external stack data structure. At the end of the first iteration, the stack will hold all N values of the doubly linked list therefore the space required for stack is directly proportional to the size of the input doubly linked list.
'''
class Node:
  def __init__(self, data, next_node=None, back_node=None):
    # Data stored in the node
    self.data = data
    # Reference to the next node
    # in the list (forward direction)
    self.next = next_node
    # Reference to the previous node
    # in the list (backward direction)
    self.back = back_node

def convert_arr_to_dll(arr):
  # Create the head node with
  # the first element of the array
  head = Node(arr[0])
  # Initialize 'prev' to the head node
  prev = head

  for i in range(1, len(arr)):
    # Create a new node with data from the
    # array and set its 'back' pointer
    # to the previous node
    temp = Node(arr[i], None, prev)
    
    # Update the 'next' pointer of the
    # previous node to point to the new node
    prev.next = temp
    # Move 'prev' to the newly created 
    # node for the next iteration
    prev = temp

  # Return the head of the doubly linked list
  return head

def print_dll(head):
  while head is not None:
    # Print the data in the current node
    print(head.data, end=" ")
    # Move to the next node
    head = head.next
  print()


def reverse_dll(head):
  # If head is empty or there is only
  # one element, return the head directly
  if head is None or head.next is None:
    return head

  # Initialize a stack to store values
  st = []
  # Initialize the node pointer
  #'temp' at head
  temp = head

  # Traverse the doubly linked list
  # via the 'temp' pointer
  while temp is not None:
    # Insert the data of the current
    # node into the stack
    st.append(temp.data)
    # Traverse further
    temp = temp.next

  # Reinitialize 'temp' to head
  temp = head

  # Second iteration of the DLL
  # to replace the values
  while temp is not None:
    # Replace the value pointed to
    # by 'temp' with the value from
    # the top of the stack and pop it
    temp.data = st.pop()
    # Traverse further
    temp = temp.next

  # Return the updated doubly linked list
  # where the values of nodes from both
  # ends have been swapped
  return head


# Example usage:
arr = [12, 5, 6, 8, 4]
# Convert the array to a
# doubly linked list
head = convert_arr_to_dll(arr)
# Print the doubly linked list
print('Doubly Linked List Initially:  ')
print_dll(head)

print('Doubly Linked List After Reversing :')

# Reverse the doubly linked list
head = reverse_dll(head)
# Print the reversed doubly linked list
print_dll(head)




# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
swaping
temp = a
a = b
b = temp

logic same as swaping
prev = None
current = self.head
while current:
  prev = current.back
  
  current.back = current.next
  current.next = prev
  
  current = current.back
return prev.back

Time Complexity : O(N) We only have to traverse the doubly linked list once, hence our time complexity is O(N).

Space Complexity : O(1), as the reversal is done in place.
'''
class Node:
  def __init__(self, data, next_node=None, back_node=None):
    # Data stored in the node
    self.data = data
    # Reference to the next node
    # in the list (forward direction)
    self.next = next_node
    # Reference to the previous node
    # in the list (backward direction)
    self.back = back_node

def convert_arr_to_dll(arr):
  # Create the head node with
  # the first element of the array
  head = Node(arr[0])
  # Initialize 'prev' to the head node
  prev = head

  for i in range(1, len(arr)):
    # Create a new node with data from the
    # array and set its 'back' pointer
    # to the previous node
    temp = Node(arr[i], None, prev)
    
    # Update the 'next' pointer of the
    # previous node to point to the new node
    prev.next = temp
    # Move 'prev' to the newly created 
    # node for the next iteration
    prev = temp

  # Return the head of the doubly linked list
  return head

def print_dll(head):
  while head is not None:
    # Print the data in the current node
    print(head.data, end=" ")
    # Move to the next node
    head = head.next
  print()

def reverse_dll(head):
  # Check if the list is empty
  # or has only one node
  if head is None or head.next is None:
    # No change is needed;
    # return the current head
    return head
  
  # Initialize a pointer to
  # the previous node
  prev = None  
  
  # Initialize a pointer
  # to the current node
  current = head  

  # Traverse the linked list
  while current is not None:
    # Store a reference to
    # the previous node
    prev = current.back 

    # Swap the previous and next pointers
    current.back = current.next
    
    # This step reverses the links
    current.next = prev 
    
    # Move to the next node
    # in the original list
    current = current.back  

  # The final node in the original list
  # becomes the new head after reversal
  return prev.back

# Example usage:
arr = [12, 5, 6, 8, 4]
# Convert the array to a
# doubly linked list
head = convert_arr_to_dll(arr)
# Print the doubly linked list
print('Doubly Linked List Initially:  ')
print_dll(head)

print('Doubly Linked List After Reversing :')

# Reverse the doubly linked list
head = reverse_dll(head)
# Print the reversed doubly linked list
print_dll(head)



# endregion







# region 6.3 LINKED LIST - MEDIUM
# --------------------------------
# â­â­â­ PATTERN : Tortoise Hare method / slow and fast pointers
# 1 TODO :  middle of a LL (Tortoise Hare method)
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/data-structure/find-middle-element-in-a-linked-list/


https://leetcode.com/problems/middle-of-the-linked-list/



'''
# method 1 : brute force approch
'''
- count the number of nodes by increaseing counter by 1
ğŸ‘‰ use this ,for odd, middle node = (count/2) + 1
âŒ for even, middle node = (count/2)
- traverse again till the middle node by reducing (middle - 1) till we get 0

Time Complexity: O(N+N/2) The code traverses the entire linked list once and half times and then only half in the second iteration, first to count the number of nodes then then again to get to the middle node. Therefore, the time complexity is linear, O(N + N/2) ~ O(N).

Space Complexity : O(1) There is constant space complexity because it uses a constant amount of extra space regardless of the size of the linked list. We only use a few variables to keep track of the middle position and traverse the list, and the memory required for these variables does not depend on the size of the list.
'''                       
# Node class represents a node in 
# a linked list

class Node:
    def __init__(self, data, next_node=None):
        # Data stored in the node
        self.data = data       
        # Pointer to the next node in the list
        self.next = next_node  

# Function to find the middle 
# node of a linked list
def find_middle(head):
    # If the list is empty or has only 
    # one element, return the head
    # as it's the middle.
    if head is None or head.next is None:
        return head

    temp = head
    count = 0

    # Count the number of nodes
    # in the linked list.
    while temp is not None:
        count += 1
        temp = temp.next

    # Calculate the position of
    # the middle node.
    mid = count // 2 + 1
    temp = head

    # Traverse to the middle node by
    # moving temp to the middle position.
    while temp is not None:
        mid = mid -1

        # Check if the middle position is reached.
        if mid == 0:
            # break out of the loop
            # to return temp
            break
        
        # Move temp ahead
        temp = temp.next


    # Return the middle node.
    return temp

# Creating a sample linked list: 
head = Node(1)
head.next = Node(2)
head.next.next = Node(3)
head.next.next.next = Node(4)
head.next.next.next.next = Node(5)

# Find the middle node
middle_node = find_middle(head)

# Display the value of the middle node
print("The middle node value is:", middle_node.data)



# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
- create two pointers fast and slow
- itterate over the linked list 
- move the fast pointer two next to slow pointer 
- at last slow pointer will end at the middle

Time Complexity: O(N/2) The algorithm requires the 'fast' pointer to reach the end of the list which it does after approximately N/2 iterations (where N is the total number of nodes). Therefore, the maximum number of iterations needed to find the middle node is proportional to the number of nodes in the list, making the time complexity linear, or O(N/2) ~ O(N).

Space Complexity : O(1) There is constant space complexity because it uses a constant amount of extra space regardless of the size of the linked list. We only use a few variables to keep track of the middle position and traverse the list, and the memory required for these variables does not depend on the size of the list.
'''
# Node class represents a node in 
# a linked list

class Node:
    def __init__(self, data, next_node=None):
        # Data stored in the node
        self.data = data       
        # Pointer to the next node in the list
        self.next = next_node  

# Function to find the middle 
# node of a linked list
def find_middle(head):
    # Initialize the slow pointer to the head.
    slow = head   
    
    # Initialize the fast pointer to the head.
    fast = head   

    # Traverse the linked list using
    # the Tortoise and Hare algorithm.
    while fast and fast.next and slow:
        # Move fast two steps.
        fast = fast.next.next 
        # Move slow one step.
        slow = slow.next       

    # Return the slow pointer,
    # which is now at the middle node.
    return slow  


# Creating a sample linked list: 
head = Node(1)
head.next = Node(2)
head.next.next = Node(3)
head.next.next.next = Node(4)
head.next.next.next.next = Node(5)

# Find the middle node
middle_node = find_middle(head)

# Display the value of the middle node
print("The middle node value is:", middle_node.data)



# 2 TODO : reverse a LL (itterative)
# method 1 : brute force approch
'''


ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/data-structure/reverse-a-linked-list/


https://leetcode.com/problems/reverse-linked-list/


https://www.youtube.com/watch?v=D2vI2DNJGd8&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=245

Time Complexity: O(2N) This is because we traverse the linked list twice: once to push the values onto the stack, and once to pop the values and update the linked list. Both traversals take O(N) time, hence time complexity  O(2N) ~ O(N).

Space Complexity: O(N) We use a stack to store the values of the linked list, and in the worst case, the stack will have all N values,  ie. storing the complete linked list. 
'''

class Node:
    def __init__(self, data, next_node=None):
        self.data = data
        self.next = next_node

# Function to reverse the
# linked list using a stack
def reverse_linked_list(head):
    # Create a temporary pointer
    # to traverse the linked list
    temp = head  
    
    # Create a stack to temporarily
    # store the data values
    stack = []   

    # Step 1: Push the values of the
    # linked list onto the stack
    while temp is not None:
        # Push the current node's
        # data onto the stack
        stack.append(temp.data) 
        # Move to the next node
        # in the linked list
        temp = temp.next        

    # Reset the temporary pointer
    # to the head of the linked list
    temp = head  

    # Step 2: Pop values from the stack
    # and update the linked list
    while temp is not None:
        
        # Set the current node's data to
        # the value at the top of the stack
        temp.data = stack.pop()  
        
         # Move to the next node in
         # the linked list
        temp = temp.next        

    # Return the new head of
    # the reversed linked list
    return head  

# Function to print the linked list
def print_linked_list(head):
    temp = head
    while temp is not None:
        print(temp.data, end=" ")
        temp = temp.next
    print()

# Create a linked list with
# values 1, 3, 2, and 4
head = Node(1)
head.next = Node(3)
head.next.next = Node(2)
head.next.next.next = Node(4)

# Print the original linked list
print("Original Linked List:", end=" ")
print_linked_list(head)

# Reverse the linked list
head = reverse_linked_list(head)

# Print the reversed linked list
print("Reversed Linked List:", end=" ")
print_linked_list(head)


# method 2 : better approch
'''
Time Complexity: O(N) The code traverses the entire linked list once, where 'n' is the number of nodes in the list. This traversal has a linear time complexity, O(n).

Space Complexity: O(1) The code uses only a constant amount of additional space, regardless of the linked list's length. This is achieved by using three pointers (prev, temp and front) to reverse the list without any significant extra memory usage, resulting in constant space complexity, O(1).
'''

class Node:
    def __init__(self, data, next_node=None):
        self.data = data
        self.next = next_node

# Function to reverse linked list
# using 3 pointer approach
def reverseLinkedList(head):
    
    # Initialize 'temp' at the
    # head of the linked list
    temp = head
    
    # Initialize 'prev' to None,
    # representing the previous node 
    prev = None
    
    while temp is not None:
        # Store the next node in 'front'
        # to preserve the reference
        front = temp.next
        # Reverse the direction of the current
        # node's 'next' pointer to point to 'prev'
        temp.next = prev
        # Move 'prev' to the current 
        # node, for the next iteration
        prev = temp
        # Move 'temp' to 'front' node
        # advancing traversal
        temp = front

    # Return the new head
    # of the reversed linked list
    return prev
    
# Function to print the linked list
def print_linked_list(head):
    temp = head
    while temp is not None:
        print(temp.data, end=" ")
        temp = temp.next
    print()

# Create a linked list with
# values 1, 3, 2, and 4
head = Node(1)
head.next = Node(3)
head.next.next = Node(2)
head.next.next.next = Node(4)

# Print the original linked list
print("Original Linked List:", end=" ")
print_linked_list(head)

# Reverse the linked list
head = reverse_linked_list(head)

# Print the reversed linked list
print("Reversed Linked List:", end=" ")
print_linked_list(head)




# method 3 : optimal solution
'''
Time Complexity: O(N) This is because we traverse the linked list twice: once to push the values onto the stack, and once to pop the values and update the linked list. Both traversals take O(N) time.

Space Complexity : O(1) No additional space is used explicitly for data structures or allocations during the linked list reversal process. However, it's important to note that there is an implicit use of stack space due to recursion. This recursive stack space stores function calls and associated variables during the recursive traversal and reversal of the linked list. Despite this, no extra memory beyond the program's existing execution space is allocated, hence maintaining a space complexity of O(1).
'''

class Node:
    def __init__(self, data, next_node=None):
        self.data = data
        self.next = next_node

# Function to reverse a singly
# linked list using a recursion
def reverse_linked_list(head):
    # Base case:
    # If the linked list is empty or has only one node,
    # return the head as it is already reversed.
    if head is None or head.next is None:
        return head
    
    # Recursive step:
    # Reverse the linked list starting from the second node (head.next).
    new_head = reverse_linked_list(head.next)
    
    # Save a reference to the node following
    # the current 'head' node.
    front = head.next
    
    # Make the 'front' node point to the current
    # 'head' node in the reversed order.
    front.next = head
    
    # Break the link from the current 'head' node
    # to the 'front' node to avoid cycles.
    head.next = None
    
    # Return the 'new_head,' which is the new
    # head of the reversed linked list.
    return new_head


# Function to print the linked list
def print_linked_list(head):
    temp = head
    while temp is not None:
        print(temp.data, end=" ")
        temp = temp.next
    print()

# Create a linked list with
# values 1, 3, 2, and 4
head = Node(1)
head.next = Node(3)
head.next.next = Node(2)
head.next.next.next = Node(4)

# Print the original linked list
print("Original Linked List:", end=" ")
print_linked_list(head)

# Reverse the linked list
head = reverse_linked_list(head)

# Print the reversed linked list
print("Reversed Linked List:", end=" ")
print_linked_list(head)



# 3 TODO : reverse a LL (recursive)
'''


ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/data-structure/reverse-a-linked-list/

https://leetcode.com/problems/reverse-linked-list/


'''
# method 1 : brute force approch
'''
Time Complexity: O(2N) This is because we traverse the linked list twice: once to push the values onto the stack, and once to pop the values and update the linked list. Both traversals take O(N) time, hence time complexity  O(2N) ~ O(N).

Space Complexity: O(N) We use a stack to store the values of the linked list, and in the worst case, the stack will have all N values,  ie. storing the complete linked list. 
'''

class Node:
    def __init__(self, data, next_node=None):
        self.data = data
        self.next = next_node

# Function to reverse the
# linked list using a stack
def reverse_linked_list(head):
    # Create a temporary pointer
    # to traverse the linked list
    temp = head  
    
    # Create a stack to temporarily
    # store the data values
    stack = []   

    # Step 1: Push the values of the
    # linked list onto the stack
    while temp is not None:
        # Push the current node's
        # data onto the stack
        stack.append(temp.data) 
        # Move to the next node
        # in the linked list
        temp = temp.next        

    # Reset the temporary pointer
    # to the head of the linked list
    temp = head  

    # Step 2: Pop values from the stack
    # and update the linked list
    while temp is not None:
        
        # Set the current node's data to
        # the value at the top of the stack
        temp.data = stack.pop()  
        
         # Move to the next node in
         # the linked list
        temp = temp.next        

    # Return the new head of
    # the reversed linked list
    return head  

# Function to print the linked list
def print_linked_list(head):
    temp = head
    while temp is not None:
        print(temp.data, end=" ")
        temp = temp.next
    print()

# Create a linked list with
# values 1, 3, 2, and 4
head = Node(1)
head.next = Node(3)
head.next.next = Node(2)
head.next.next.next = Node(4)

# Print the original linked list
print("Original Linked List:", end=" ")
print_linked_list(head)

# Reverse the linked list
head = reverse_linked_list(head)

# Print the reversed linked list
print("Reversed Linked List:", end=" ")
print_linked_list(head)

# method 2 : better approch
'''
Time Complexity: O(N) The code traverses the entire linked list once, where 'n' is the number of nodes in the list. This traversal has a linear time complexity, O(n).

Space Complexity: O(1) The code uses only a constant amount of additional space, regardless of the linked list's length. This is achieved by using three pointers (prev, temp and front) to reverse the list without any significant extra memory usage, resulting in constant space complexity, O(1).
'''

class Node:
    def __init__(self, data, next_node=None):
        self.data = data
        self.next = next_node

# Function to reverse linked list
# using 3 pointer approach
def reverseLinkedList(head):
    
    # Initialize 'temp' at the
    # head of the linked list
    temp = head
    
    # Initialize 'prev' to None,
    # representing the previous node 
    prev = None
    
    while temp is not None:
        # Store the next node in 'front'
        # to preserve the reference
        front = temp.next
        # Reverse the direction of the current
        # node's 'next' pointer to point to 'prev'
        temp.next = prev
        # Move 'prev' to the current 
        # node, for the next iteration
        prev = temp
        # Move 'temp' to 'front' node
        # advancing traversal
        temp = front

    # Return the new head
    # of the reversed linked list
    return prev
    
# Function to print the linked list
def print_linked_list(head):
    temp = head
    while temp is not None:
        print(temp.data, end=" ")
        temp = temp.next
    print()

# Create a linked list with
# values 1, 3, 2, and 4
head = Node(1)
head.next = Node(3)
head.next.next = Node(2)
head.next.next.next = Node(4)

# Print the original linked list
print("Original Linked List:", end=" ")
print_linked_list(head)

# Reverse the linked list
head = reverse_linked_list(head)

# Print the reversed linked list
print("Reversed Linked List:", end=" ")
print_linked_list(head)





# method 3 : optimal solution
'''
Time Complexity: O(N) This is because we traverse the linked list twice: once to push the values onto the stack, and once to pop the values and update the linked list. Both traversals take O(N) time.

Space Complexity : O(1) No additional space is used explicitly for data structures or allocations during the linked list reversal process. However, it's important to note that there is an implicit use of stack space due to recursion. This recursive stack space stores function calls and associated variables during the recursive traversal and reversal of the linked list. Despite this, no extra memory beyond the program's existing execution space is allocated, hence maintaining a space complexity of O(1).
'''

class Node:
    def __init__(self, data, next_node=None):
        self.data = data
        self.next = next_node

# Function to reverse a singly
# linked list using a recursion
def reverse_linked_list(head):
    # Base case:
    # If the linked list is empty or has only one node,
    # return the head as it is already reversed.
    if head is None or head.next is None:
        return head
    
    # Recursive step:
    # Reverse the linked list starting from the second node (head.next).
    new_head = reverse_linked_list(head.next)
    
    # Save a reference to the node following
    # the current 'head' node.
    front = head.next
    
    # Make the 'front' node point to the current
    # 'head' node in the reversed order.
    front.next = head
    
    # Break the link from the current 'head' node
    # to the 'front' node to avoid cycles.
    head.next = None
    
    # Return the 'new_head,' which is the new
    # head of the reversed linked list.
    return new_head


# Function to print the linked list
def print_linked_list(head):
    temp = head
    while temp is not None:
        print(temp.data, end=" ")
        temp = temp.next
    print()

# Create a linked list with
# values 1, 3, 2, and 4
head = Node(1)
head.next = Node(3)
head.next.next = Node(2)
head.next.next.next = Node(4)

# Print the original linked list
print("Original Linked List:", end=" ")
print_linked_list(head)

# Reverse the linked list
head = reverse_linked_list(head)

# Print the reversed linked list
print("Reversed Linked List:", end=" ")
print_linked_list(head)





# 4 TODO : detect a loop in Ll
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/detect-a-cycle-in-a-linked-list/


https://leetcode.com/problems/linked-list-cycle/




'''
# â­â­â­ PATTERN : linked list with loops
# method 1 : brute force approch
'''
- create an hash object which contain key as the node value and values as the number of time encounter. Initialize it empty
- iterate over the linked list and fill the hash object via an if condition which check if it is already in the object 
- if the value is already in the object then return True else at the end False, it donot contain the loop


Time Complexity: O(N * 2 * log(N) )The algorithm traverses the linked list once, performing hashmap insertions and searches in the while loop for each node. The insertion and search operations in the unordered_map have a worst-case time complexity of O(log(N)). As the loop iterates through N nodes, the total time complexity is determined by the product of the traversal (O(N)) and the average-case complexity of the hashmap operations (insert and search), resulting in O(N * 2 * log(N)). 

Hashmaps and their time complexities are discussed in more detail here. 

Space Complexity: O(N) The code uses a hashmap/dictionary to store encountered nodes, which can take up to O(N) additional space, where 'n' is the number of nodes in the list. Hence, the spacecomplexity is O(N) due to the use of the map to track nodes.
'''
# Node class represents
# a node in a linked list
class Node:
    def __init__(self, data, next_node=None):
        self.data = data
        self.next = next_node

# Function to detect a loop 
# n a linked list
def detect_loop(head):
    # Initialize a pointer 'temp' at 
    # the head of the linked list
    temp = head

    # Create a set to keep track
    # of encountered nodes
    node_set = set()

    # Step 2: Traverse the linked list
    while temp is not None:
        # If the node is already
        # in the set, there is a loop
        if temp in node_set:
            return True

        # Store the current node in the set
        node_set.add(temp)

        # Move to the next node
        temp = temp.next

    # Step 3: If the list is successfully
    # traversed without a loop, return False
    return False

if __name__ == "__main__":
    # Create a sample linked list with
    # a loop for testing
    head = Node(1)
    second = Node(2)
    third = Node(3)
    fourth = Node(4)
    fifth = Node(5)

    head.next = second
    second.next = third
    third.next = fourth
    fourth.next = fifth
    # Create a loop
    fifth.next = third

    # Check if there is a loop
    # in the linked list
    if detect_loop(head):
        print("Loop detected in the linked list.")
    else:
        print("No loop detected in the linked list.")

    # No need to explicitly free memory
    # in Python; memory management is automatic





# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
- create two pointers fast and slow
- iterate over the linked list increment the slow pointer by 1 and fast pointer by 2 inside a while loop
- if fast and slow stop on the same node the loop will break 


Time Complexity: O(N), where N is the number of nodes in the linked list. This is because in the worst-case scenario, the fast pointer, which moves quicker, will either reach the end of the list (in case of no loop) or meet the slow pointer (in case of a loop) in a linear time relative to the length of the list.

The key insight into why this is O(N) and not something slower is that each step of the algorithm reduces the distance between the fast and slow pointers (when they are in the loop) by one. Therefore, the maximum number of steps needed for them to meet is proportional to the number of nodes in the list.


Space Complexity : O(1) The code uses only a constantamount of additionalspace, regardless of the linked list's length. This is achieved by using two pointers (slow and fast) to detect the loop without any significant extra memory usage, resulting in constantspace complexity, O(1).
'''
# Node class represents
# a node in a linked list
class Node:
    def __init__(self, data, next_node=None):
        self.data = data
        self.next = next_node

# Function to detect a loop in a
# linked list using the Tortoise and Hare Algorithm
def detect_cycle(head):
    # Initialize two pointers, slow and fast,
    # to the head of the linked list
    slow = head
    fast = head

    # Step 2: Traverse the linked list
    # with the slow and fast pointers
    while fast is not None and fast.next is not None:
        # Move slow one step
        slow = slow.next
        # Move fast two steps
        fast = fast.next.next

        # Check if slow and fast pointers meet
        if slow == fast:
            return True  # Loop detected

    # If fast reaches the end of the
    # list, there is no loop
    return False


if __name__ == "__main__":
    # Create a sample linked list with
    # a loop for testing
    head = Node(1)
    second = Node(2)
    third = Node(3)
    fourth = Node(4)
    fifth = Node(5)

    head.next = second
    second.next = third
    third.next = fourth
    fourth.next = fifth
    # Create a loop
    fifth.next = third

    # Check if there is a loop
    # in the linked list
    if detect_cycle(head):
        print("Loop detected in the linked list.")
    else:
        print("No loop detected in the linked list.")

    # No need to explicitly free memory
    # in Python; memory management is automatic




# 5 TODO : find the starting point in LL
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/starting-point-of-loop-in-a-linked-list/


https://leetcode.com/problems/linked-list-cycle-ii/


'''
# method 1 : brute force approch
'''
- create an hash object which contain key as the node and values as the number of time encounter. Initialize it empty
- iterate over the linked list and fill the hash object via an if condition which check if it is already in the object 
- if the value is already in the object then return True else at the end False, it donot contain the loop

Time Complexity: O(N) The code traverses the entire linked list once, where 'N' is the number of nodes in the list. Therefore, the time complexity is linear, O(N).

Space Complexity : O(N) The code uses a hash map/dictionary to store encountered nodes, which can take up to O(N) additional space, where 'n' is the number of nodes in the list. Hence, the space complexity is O(N) due to the use of the map to track nodes.
'''
# Node class represents a node in a linked list
class Node:
    def __init__(self, data, next_node=None):
        # Data stored in the node
        self.data = data  
         # Pointer to the next node in the list
        self.next = next_node 

# Function to detect a loop in a linked list
# and return the starting node of the loop
def detect_loop(head):
    # Use temp to traverse the linked list
    temp = head
    
    # Dictionary to store all visited nodes
    node_map = {}
    
    # Traverse the list using temp
    while temp is not None:
        # Check if temp has been encountered again
        if temp in node_map:
            # A loop is detected, hence return temp
            return temp
        
        # Store temp as visited
        node_map[temp] = True
        
        # Iterate through the list
        temp = temp.next

    # If no loop is detected, return None
    return None

# Create a sample linked list with a loop
node1 = Node(1)
node2 = Node(2)
node1.next = node2
node3 = Node(3)
node2.next = node3
node4 = Node(4)
node3.next = node4
node5 = Node(5)
node4.next = node5

# Make a loop from node5 to node2
node5.next = node2

# Set the head of the linked list
head = node1

# Detect the loop in the linked list
loop_start_node = detect_loop(head)

if loop_start_node:
    print("Loop detected. Starting node of the loop is:", loop_start_node.data)
else:
    print("No loop detected in the linked list.")
                                
                              


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
- create two pointers fast and slow
- iterate over the linked list increment the slow pointer by 1 and fast pointer by 2 inside a while loop
- if fast and slow stop on the same node then follow below steps
- inititiate the slow pointer with the head
- then increment the slow and fast by + 1 node, the point where slow and fast point on the same node break , this is the starting of the loop


Time Complexity: O(N) The code traverses the entire linked list once, where 'n' is the number of nodes in the list. This traversal has a linear time complexity, O(n).

Space Complexity : O(1) The code uses only a constant amount of additional space, regardless of the linked list's length. This is achieved by using two pointers (slow and fast) to detect the loop without any significant extra memory usage, resulting in constant space complexity, O(1).
'''
                     
# Node class represents a
# node in a linked list
class Node:
    def __init__(self, data, next_node=None):
        # Data stored in the node
        self.data = data  
        # Pointer to the next node in the list
        self.next = next_node  

# Function to find the first
# node of the loop in a linked list
def first_node(head):
    # Initialize a slow and fast
    # pointers to the head of the list
    slow = head
    fast = head

    # Phase 1: Detect the loop
    while fast is not None and fast.next is not None:
        # Move slow one step
        slow = slow.next

        # Move fast two steps
        fast = fast.next.next

        # If slow and fast meet,
        # a loop is detected
        if slow == fast:
            # Reset the slow pointer
            # to the head of the list
            slow = head

            # Phase 2: Find the first
            # node of the loop
            while slow != fast:
                # Move slow and fast one
                # step at a time
                slow = slow.next
                fast = fast.next

                # When slow and fast meet again,
                # it's the first node of the loop
            return slow

    # If no loop is found, return None
    return None
    
# with a loop
node1 = Node(1)
node2 = Node(2)
node1.next = node2
node3 = Node(3)
node2.next = node3
node4 = Node(4)
node3.next = node4
node5 = Node(5)
node4.next = node5

# Make a loop from node5 to node2
node5.next = node2

# Set the head of the linked list
head = node1

# Detect the loop in the linked list
loop_start_node = first_node(head)

if loop_start_node:
    print("Loop detected. Starting node of the loop is:", loop_start_node.data)
else:
    print("No loop detected in the linked list.")


# 6 TODO : length of a loop in LL
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/linked-list/length-of-loop-in-linked-list


https://bit.ly/3dyXL6m



'''
# method 1 : brute force approch
'''
- create an hash object which contain key as the node and values as the number start from 0. Initialize it empty
- iterate over the linked list and fill the hash object by adding the node as key and increment it's value by 1  
- if the value is already in the object then add it into rthe stack find the difference between the values f the same key it will give the length of the loop

Time Complexity: O(N) The code traverses the entire linked list at least once, where 'N' is the number of nodes in the list. Therefore, the time complexity is linear, O(N).

Space Complexity: O(N) The code uses a hashmap/dictionary to store encountered nodes, which can take up to O(N) additional space, where â€˜N' is the number of nodes in the list. Hence, the space complexity is O(N) due to the use of the map to track nodes.
'''

class Node:
    def __init__(self, data1, next1=None):
        # Data stored in the node
        self.data = data1
        # Pointer to the next node
        # in the list
        self.next = next1
        
# Function to return the lenght
# of loop when slow and fast are
# on the same node
def find_length(slow, fast):
    
    # count to keep track of 
    # nodes encountered in loop
    cnt = 1
    
    # move fast by one step
    fast = fast.next
    
    # traverse fast till it 
    # reaches back to slow
    while slow != fast:
        
        # at each node increase
        # count by 1 and move fast
        # forward by one step
        
        cnt += 1
        fast = fast.next
    
    # loop terminates when fast reaches
    # slow again and the count is returned
    return cnt
    
# Function to find the length
# of the loop in a linked list
def length_of_loop(head):
    slow = head
    fast = head
    
    # Step 1: Traverse the list to detect a loop
    while fast is not None and fast.next is not None:
        # Move slow one step
        slow = slow.next
        # Move fast two steps
        fast = fast.next.next
        
        # Step 2: If the slow and fast pointers
        # meet, there is a loop
        if slow == fast:
            
            # return the number of nodes
            # in the loop
            return find_length(slow, fast)
    
    return 0


# Create a linked list with a loop
head = Node(1)
second = Node(2)
third = Node(3)
fourth = Node(4)
fifth = Node(5)

# Create a loop from fifth to second
head.next = second
second.next = third
third.next = fourth
fourth.next = fifth

# This creates a loop
fifth.next = second

loopLength = length_of_loop(head)

if loopLength > 0:
    print("Length of the loop:", loopLength)
else:
    print("No loop found in the linked list.")





# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
- create two pointers fast and slow
- iterate over the linked list increment the slow pointer by 1 and fast pointer by 2 inside a while loop
- if fast and slow stop on the same node then follow below steps
- increment the fast pointer by +1 pointer with a counter variable starts from 0
- when fast again reaches to the slow pointer the counter gives the length of rthe counter and return the length

Time Complexity: O(N) The code traverses the entire linked list once, where 'n' is the number of nodes in the list. This traversal has a linear time complexity, O(n).

Space Complexity: O(1) The code uses only a constant amount of additional space, regardless of the linked list's length. This is achieved by using two pointers (slow and fast) to detect the loop without any significant extra memory usage, resulting in constant space complexity, O(1).
'''
class Node:
    def __init__(self, data, next=None):
        self.data = data
        self.next = next

# Function to detect a loop in a
# linked list using the Tortoise and Hare Algorithm

def detect_loop(head):
    # Initialize the slow pointer at the head
    slow = head  
    
     # Initialize the fast pointer at the head
    fast = head 

    # Step 1: Traverse the list to detect a loop
    while fast is not None and fast.next is not None:
        # Move slow one step
        slow = slow.next  
        # Move fast two steps
        fast = fast.next.next  

        # Step 2: If the slow and fast
        # pointers meet, there is a loop
        if slow == fast:
            return True

    # Step 3: If the fast pointer
    # reaches the end, there is no loop
    return False

# Function to find the length
# of the loop in a linked list
def find_loop_length(head):
    slow = head
    fast = head

    # Step 1: Traverse the list to detect a loop
    while fast is not None and fast.next is not None:
        # Move slow one step
        slow = slow.next     
        # Move fast two steps
        fast = fast.next.next  

        # Step 2: If the slow and fast
        # pointers meet, there is a loop
        if slow == fast:
            # Initialize the loop length
            length = 1  
             # Move fast one step
            fast = fast.next 

            # Step 4: Initialize a counter
            # and traverse using the fast pointer
            while slow != fast:
                # Move fast one step
                fast = fast.next  
                # Increment the counter
                length += 1  

            # Step 6: Return the 
            # length of the loop
            return length

    # Step 3: If the fast pointer
    # reaches the end, there is no loop
    return 0  

# Create a linked list with a loop for testing
head = Node(1)
node2 = Node(2)
node3 = Node(3)
node4 = Node(4)
node5 = Node(5)

head.next = node2
node2.next = node3
node3.next = node4
node4.next = node5
node5.next = node3  # Creating a loop

# Check if there is a loop in the linked list
if detect_loop(head):
    # If there is a loop, find its length
    length = find_loop_length(head)
    print(f"The length of the loop is: {length}")
else:
    print("No loop found in the linked list.")



# 7 TODO : check if LL is pallindrome or not
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/check-if-given-linked-list-is-plaindrome/

https://leetcode.com/problems/palindrome-linked-list/


'''
# method 1 : brute force approch
'''
ğŸ‘‰ in place of dequeue, we can also use array

- use an array to store each element of the stack
- re-iterate the linked list from the head, 
- in each iteration compare the the node data with the last element of the array, also go to next node and pop() that element from the array


Time Complexity: O(2 * N) This is because we traverse the linked list twice: once to push the values onto the stack, and once to pop the values and compare with the linked list. Both traversals take O(2*N) ~ O(N) time.

Space Complexity: O(N) We use a stack to store the values of the linked list, and in the worst case, the stack will have all N values,  ie. storing the complete linked list. 
'''
from collections import deque

class Node:
    def __init__(self, data, next_node=None):
        self.data = data
        self.next = next_node


def isPalindrome(head):
    # Create an empty deque
    # to store values
    st = deque()

    # Initialize a temporary pointer
    # to the head of the linked list
    temp = head

    # Traverse the linked list and
    # push values onto the deque
    while temp is not None:
        # Push the data from the
        # current node onto the deque
        st.append(temp.data)

        # Move to the next node
        temp = temp.next

    # Reset the temporary pointer back
    # to the head of the linked list
    temp = head

    # Compare values by popping from the deque
    # and checking against linked list nodes
    while temp is not None:
        if temp.data != st.pop():
            # If values don't match,
            # it's not a palindrome
            return False

        # Move to the next node
        # in the linked list
        temp = temp.next

    # If all values match,
    # it's a palindrome
    return True

    
# Function to print the linked list
def print_linked_list(head):
    temp = head
    while temp is not None:
        print(temp.data, end=" ")
        temp = temp.next
    print()

def main():
    # Create a linked list with
    # values 1, 5, 2, 5, and 1 (15251, a palindrome)
    head = Node(1)
    head.next = Node(5)
    head.next.next = Node(2)
    head.next.next.next = Node(5)
    head.next.next.next.next = Node(1)

    # Print the original linked list
    print("Original Linked List: ", end="")
    print_linked_list(head)

    # Check if the linked list is a palindrome
    if is_palindrome(head):
        print("The linked list is a palindrome.")
    else:
        print("The linked list is not a palindrome.")

if __name__ == "__main__":
    main()





# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O (2* N) The algorithm traverses the linked list twice, dividing it into halves. During the first traversal, it reverses one-half of the list, and during the second traversal, it compares the elements of both halves. As each traversal covers N/2 elements, the time complexity is calculated as O(N/2 + N/2 + N/2 + N/2), which simplifies to O(2N), ultimately representing O(N). 

Space Complexity: O(1) The approach uses a constant amount of additional space regardless of the size of the input linked list. It doesn't allocate any new data structures that depend on the input size, resulting in a space complexity of O(1).
'''
class Node:
    def __init__(self, data, next_node=None):
        self.data = data
        self.next = next_node

# Function to reverse linked list
# using recursion approach
def reverse_linked_list(head):
    # Check if the list is empty
    # or has only one node
    if head is None or head.next is None:
        
        # No change is needed;
        # return the current head
        return head

    # Recursive step: Reverse the remaining part
    # of the list and obtain the new head
    new_head = reverse_linked_list(head.next)

    # Store the next node in 'front' to reverse the link
    front = head.next

    # Update the 'next' pointer of 'front' to 
    # point to the current head, effectively
    # reversing the link direction
    front.next = head

    # Set the 'next' pointer of the current
    # head to 'None' to break the original link
    head.next = None

    # Return the new head obtained
    # from the recursion
    return new_head
    
def is_palindrome(head):
    # Check if the linked list is empty
    # or has only one node
    if head is None or head.next is None:
        # It's a palindrome by definition
        return True

    # Initialize two pointers, slow and fast,
    # to find the middle of the linked list
    slow = head
    fast = head

    # Traverse the linked list to find the
    # middle using slow and fast pointers
    while fast.next is not None and fast.next.next is not None:
        # Move slow pointer one step at a time
        slow = slow.next

        # Move fast pointer two steps at a time
        fast = fast.next.next

    # Reverse the second half of the
    # linked list starting from the middle
    new_head = reverse_linked_list(slow.next)

    # Pointer to the first half
    first = head

    # Pointer to the reversed second half
    second = new_head
    while second is not None:
        # Compare data values of
        # nodes from both halves

        # If values do not match,
        # the list is not a palindrome
        if first.data != second.data:
            # Reverse the second half
            # back to its original state
            reverse_linked_list(new_head)
            # Not a palindrome
            return False

        # Move the first pointer
        first = first.next

        # Move the second pointer
        second = second.next

    # Reverse the second half
    # back to its original state
    reverse_linked_list(new_head)

    # The linked list is a palindrome
    return True
    
# Function to print the linked list
def print_linked_list(head):
    temp = head
    while temp is not None:
        print(temp.data, end=" ")
        temp = temp.next
    print()

def main():
    # Create a linked list with
    # values 1, 5, 2, 5, and 1 (15251, a palindrome)
    head = Node(1)
    head.next = Node(5)
    head.next.next = Node(2)
    head.next.next.next = Node(5)
    head.next.next.next.next = Node(1)

    # Print the original linked list
    print("Original Linked List: ", end="")
    print_linked_list(head)

    # Check if the linked list is a palindrome
    if is_palindrome(head):
        print("The linked list is a palindrome.")
    else:
        print("The linked list is not a palindrome.")

if __name__ == "__main__":
    main()




# 8 TODO : segrregate odd and even nodes in a LL
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

https://takeuforward.org/data-structure/segregate-even-and-odd-nodes-in-linkedlist

https://www.youtube.com/watch?v=qf6qp7GzD5Q&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=242

https://leetcode.com/problems/odd-even-linked-list/

'''
# method 1 : brute force approch
'''
using an array data structure then put the values inside the linked list
TC     -      O(2N)
SC     -    O(N)  
'''
class Node:
    def __init__(self, data, next = None, back=None):
        self.data = data
        self.next = next
        self.back = back
    
class DoublyLinkedList:
  def __init__(self):
    self.head = None
    
def print_list(dll):
  current = dll
  while current:
      print(current.data, end=" <-> ")
      current = current.next
  print("None")

def convertArrToDLL(arr):
  # If the array is empty, return immediately
  if not arr:
      return None
  
  # Create the head node using the first element of the array
  head = Node(arr[0])
  prev = head
  
  # Traverse the array and create nodes, linking them together
  for i in range(1, len(arr)):
    # self.append(arr[i])
    new_node = Node(arr[i], None ,prev)  # Create a new node for each element
    prev.next = new_node
    prev = new_node  # Move current to the new node
  return head

def sumLL(ll1, ll2):
  dummy_node = Node(-1)
  curr = dummy_node
  carry = 0
  t1 = ll1
  t2 = ll2 
  while t1 is not None or t2 is not None:
    sum = carry
    if t1:
      sum  = sum + t1.data
    if t2:
      sum = sum + t2.data
    new_node = Node(sum % 10)
    carry = sum // 10
    curr.next = new_node
    curr = curr.next
    if t1:
      t1 = t1.next
    if t2:
      t2 = t2.next
  if carry:
    new_node = Node(carry)
    curr.next = new_node
  
  head = remove_dummy_node(dummy_node)
  return head
  
def find_odd_even(ll):
  print(ll.__dict__)
  temp = ll
  arr = []
  while temp != None or temp.next != None:
    arr.append(temp.data)
    print(arr)
    if temp.next and temp.next.next:
      temp = temp.next.next
    else:
      break
  
  temp = ll.next
  while temp or temp.next:
    arr.append(temp.data)
    if temp.next and temp.next.next:
      temp = temp.next.next
    else:
      break
  
  i = 0
  temp = ll
  while temp:
    temp.data = arr[i]
    i += 1
    temp = temp.next
  return ll

def main_function(arr1):
  dll1 = convertArrToDLL(arr1)
  odd_even = find_odd_even(dll1)
  print_list(odd_even)
  return None
  
arr1 = [1,2,3,4,5,6,7]
print(main_function(arr1))  


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -     O(N) 
# SC     -   O(1)

class Node:
    def __init__(self, data, next = None, back=None):
        self.data = data
        self.next = next
        self.back = back
    
class DoublyLinkedList:
  def __init__(self):
    self.head = None
    
def print_list(dll):
  current = dll
  while current:
      print(current.data, end=" <-> ")
      current = current.next
  print("None")

def convertArrToDLL(arr):
  # If the array is empty, return immediately
  if not arr:
      return None
  
  # Create the head node using the first element of the array
  head = Node(arr[0])
  prev = head
  
  # Traverse the array and create nodes, linking them together
  for i in range(1, len(arr)):
    # self.append(arr[i])
    new_node = Node(arr[i], None ,prev)  # Create a new node for each element
    prev.next = new_node
    prev = new_node  # Move current to the new node
  return head
  
def find_odd_even(ll):
  if not ll or not ll.next:
    return ll 
  odd = ll 
  even = ll.next
  evenHead = ll.next
  while even != None and even.next != None:
    odd.next = odd.next.next
    even.next = even.next.next
    
    odd = odd.next
    even = even.next
    print(odd.__dict__)
    print(even.__dict__)
  odd.next = evenHead
  
  return ll
def main_function(arr1):
  dll1 = convertArrToDLL(arr1)
  odd_even = find_odd_even(dll1)
  print_list(odd_even)
  return None
  
arr1 = [1,2,3,4,5,6,7]
print(main_function(arr1))   


# 9 TODO : remove Nth node from end/back of LL
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/remove-n-th-node-from-the-end-of-a-linked-list/


https://leetcode.com/problems/remove-nth-node-from-end-of-list/




'''
# method 1 : brute force approch
'''
Time Complexity: O(L)+O(L-N), We are calculating the length of the linked list and then iterating up to the (L-N)th node of the linked list, where L is the total length of the list.

Space Complexity:  O(1), as we have not used any extra space.
'''

class Node:
    def __init__(self, data, next_node=None):
        self.data = data
        self.next = next_node

# Function to print the linked list
def printLL(head):
    while head is not None:
        print(head.data, end=' ')
        head = head.next

# Function to delete the Nth node from the end of the linked list
def DeleteNthNodefromEnd(head, N):
    if head is None:
        return None
    cnt = 0
    temp = head

    # Count the number of nodes in the linked list
    while temp is not None:
        cnt += 1
        temp = temp.next

    # If N equals the total number of nodes, delete the head
    if cnt == N:
        newhead = head.next
        head = None
        return newhead

    # Calculate the position of the node to delete (res)
    res = cnt - N
    temp = head

    # Traverse to the node just before the one to delete
    while temp is not None:
        res -= 1
        if res == 0:
            break
        temp = temp.next

    # Delete the Nth node from the end
    delNode = temp.next
    temp.next = temp.next.next
    delNode = None
    return head

arr = [1, 2, 3, 4, 5]
N = 3
head = Node(arr[0])
head.next = Node(arr[1])
head.next.next = Node(arr[2])
head.next.next.next = Node(arr[3])
head.next.next.next.next = Node(arr[4])

# Delete the Nth node from the end and print the modified linked list
head = DeleteNthNodefromEnd(head, N)
printLL(head)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(N) since the fast pointer will traverse the entire linked list, where N is the length of the linked list.

Space Complexity: O(1), as we have not used any extra space.
'''
class Node:
    def __init__(self, data, next_node=None):
        self.data = data
        self.next = next_node

# Function to print the linked list
def printLL(head):
    while head is not None:
        print(head.data, end=' ')
        head = head.next

# Function to delete the Nth node from the end of the linked list
def DeleteNthNodefromEnd(head, N):
    # Create two pointers, fastp and slowp
    fastp = head
    slowp = head

    # Move the fastp pointer N nodes ahead
    for i in range(N):
        fastp = fastp.next

    # If fastp becomes None, the Nth node from the end is the head
    if fastp is None:
        return head.next

    # Move both pointers until fastp reaches the end
    while fastp.next is not None:
        fastp = fastp.next
        slowp = slowp.next

    # Delete the Nth node from the end
    delNode = slowp.next
    slowp.next = slowp.next.next
    delNode = None
    return head

arr = [1, 2, 3, 4, 5]
N = 3
head = Node(arr[0])
head.next = Node(arr[1])
head.next.next = Node(arr[2])
head.next.next.next = Node(arr[3])
head.next.next.next.next = Node(arr[4])

# Delete the Nth node from the end and print the modified linked list
head = DeleteNthNodefromEnd(head, N)
printLL(head)




# 10 TODO :  delete the middle node of a LL
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/linked-list/delete-the-middle-node-of-the-linked-list


https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/#:~:text=You%20are%20given%20the%20head,than%20or%20equal%20to%20x%20.





'''
# method 1 : brute force approch
'''
- iteraet over the linked list keep incrementing the counter and temp which currently holding the head
- after iteration we got the length of the linked list make res = N/2
- re-iterate the linked list and keep decrementing res when res becomes zero
- middle  = temp.next 
temp.next = temp.next.next 
middle  = None
- break the loop

Time Complexity: O(N + N/2) The loop traverses the entire linked list once to count the total number of nodes then the loop iterates halfway through the linked list to reach the middle node. Hence, the time complexity is O(N + N/2) ~ O(N).

Space Complexity : O(1) The algorithm uses a constant amount of extra space regardless of the size of the input (linked list). It doesn't use any additional data structures in proportion to the input size. Thus, the space complexity is O(1) (constant space). 
'''
# Node class represents a node in 
# a linked list

class Node:
    def __init__(self, data, next_node=None):
        # Data stored in the node
        self.data = data       
        # Pointer to the next node in the list
        self.next = next_node  

# Function to delete the
# middle node of a linked list
def delete_middle(head):
    # Initialize a temporary node
    # to traverse the linked list
    temp = head
    
    # Variable to hold the number
    # of nodes in the linked list
    n = 0
    
    # Loop to count the number of
    # nodes in the linked list
    while temp is not None:
        n += 1
        temp = temp.next
    
    # Calculate the index of the middle node
    res = n // 2
    
    # Reset the temporary node to
    # the beginning of the linked list
    temp = head
    
    # Loop to find the
    # middle node to delete
    while temp is not None:
        res -= 1
        
        # If the middle node is found
        if res == 0:
            
            # Create a pointer
            # to the middle node
            middle = temp.next
            
            # Adjust pointers to
            # skip the middle node
            temp.next = temp.next.next
            
            # Delete the middle node
            # (Python handles memory management)
            # No explicit free() needed
            
            # Exit the loop after
            # deleting the middle node
            break
        
        # Move to the next node
        # in the linked list
        temp = temp.next
    
    # Return the head of the
    # modified linked list
    return head


def print_linked_list(head):
    temp = head
    while temp:
        print(temp.data, end=" ")
        temp = temp.next
    print()

# Creating a sample linked list
head = Node(1)
head.next = Node(2)
head.next.next = Node(3)
head.next.next.next = Node(4)
head.next.next.next.next = Node(5)

# Display the original linked list
print("Original Linked List: ", end="")
print_linked_list(head)

# Deleting the middle node
head = delete_middle(head)

# Displaying the updated linked list
print("Updated Linked List: ", end="")
print_linked_list(head)




# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
- create two pointers fast and slow
- iterate over the linked list increment the slow pointer by 1 and fast pointer by 2 inside a while loop. But for the first iteration increment fast but not slow
- at the end of the iteration slow will point to the node previous to middle node

Time Complexity: O(N/2) The algorithm traverses the linked list using the Tortoise and Hare approach. The code increments both 'slow' and 'fast' pointers at different rates, effectively covering about half the list before reaching the midpoint, hence the time complexity of the algorithm is O(N/2) ~ O(N).

Space Complexity: O(1) The algorithm uses a constant amount of extra space regardless of the size of the input (linked list). It doesn't use any additional data structures in proportion to the input size. Thus, the space complexity is O(1) (constant space). 
'''
# Node class represents a node in 
# a linked list

class Node:
    def __init__(self, data, next_node=None):
        # Data stored in the node
        self.data = data       
        # Pointer to the next node in the list
        self.next = next_node  

# Function to delete the middle
# node of a linked list
def delete_middle(head):
    """
    If the list is empty or has only one node,
    return None as there is no middle node to delete
    """
    if head is None or head.next is None:
        return None

    # Initialize slow and fast pointers
    slow = head
    fast = head.next.next if head.next else None

    # Move 'fast' pointer twice as fast as 'slow'
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

    # Delete the middle node by skipping it
    slow.next = slow.next.next
    return head

def print_linked_list(head):
    temp = head
    while temp:
        print(temp.data, end=" ")
        temp = temp.next
    print()

# Creating a sample linked list
head = Node(1)
head.next = Node(2)
head.next.next = Node(3)
head.next.next.next = Node(4)
head.next.next.next.next = Node(5)

# Display the original linked list
print("Original Linked List: ", end="")
print_linked_list(head)

# Deleting the middle node
head = delete_middle(head)

# Displaying the updated linked list
print("Updated Linked List: ", end="")
print_linked_list(head)




# 11 TODO : sort LL
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/linked-list/sort-a-linked-list


https://leetcode.com/problems/sort-list/




'''
# method 1 : brute force approch
'''
https://www.youtube.com/watch?v=8ocB7a_c-Cc&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=262

- iterate over the linked list and put the node data into an array
- sort the array 
- then, push the elements in that linked list  


Time Complexity: O(N) + O(N log N) + O(N)where N is the number of nodes in the linked list.

O(N) to traverse the linked list and store its data values in an additional array.
O(N log N) to sort the array containing the node values.
O(N) to traverse the sorted array and convert it into a new linked list.
Space Complexity : O(N)where N is the number of nodes in the linked list as we have to store the values of all nodes in the linked list in an additional array to sort them.
'''
# Node class represents a
# node in a linked list
class Node:
    def __init__(self, data, next_node=None):
        # Data stored in the node
        self.data = data
        # Pointer to the next node in the list
        self.next = next_node


# Function to sort a linked list
# using Brute Force approach
def sort_LL(head):
    # Create a list to
    # store node values
    arr = []
    
    # Temporary pointer to
    # traverse the linked list
    temp = head
    
    # Traverse the linked list and
    # store node values in the list
    while temp is not None:
        arr.append(temp.data)
        temp = temp.next
    
    # Sort the list
    # containing node values
    arr.sort()
    
    # Reassign sorted values to
    # the linked list nodes
    temp = head
    for i in range(len(arr)):
        # Update the node's data
        # with the sorted values
        temp.data = arr[i]
        # Move to the next node
        temp = temp.next
    
    # Return the head of the
    # sorted linked list
    return head


# Function to print the linked list
def print_linked_list(head):
    temp = head
    while temp is not None:
        # Print the data of the current node
        print(temp.data, end=" ")
        # Move to the next node
        temp = temp.next
    print()


# Linked List: 3 2 5 4 1
head = Node(3)
head.next = Node(2)
head.next.next = Node(5)
head.next.next.next = Node(4)
head.next.next.next.next = Node(1)

print("Original Linked List: ", end="")
print_linked_list(head)

# Sort the linked list
head = sort_LL(head)

print("Sorted Linked List: ", end="")
print_linked_list(head)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
- apply merge sort on the linked list

Time Complexity: O(N log N)where N is the number of nodes in the linked list. Finding the middle node of the linked list requires traversing it linearly taking O(N) time complexity and to reach the individual nodes of the list, it has to be split log N times (continuously halve the list until we have individual elements).

Space Complexity : O(1) as no additional data structures or space is allocated for storage during the merging process. However, space proportional to O(log N) stack space is required for the recursive calls. THe maximum recursion depth of log N height is occupied on the call stack.
'''
                                
                     
# Node class represents a
# node in a linked list
class Node:
    def __init__(self, data1, next1=None):
        # Data stored in the node
        self.data = data1
        
        # Pointer to the next node in the list
        self.next = next1

# Function to merge two sorted linked lists
def mergeTwoSortedLinkedLists(list1, list2):
    # Create a dummy node to serve
    # as the head of the merged list
    dummyNode = Node(-1)
    temp = dummyNode

    # Traverse both lists simultaneously
    while list1 is not None and list2 is not None:
        # Compare elements of both lists and
        # link the smaller node to the merged list
        if list1.data <= list2.data:
            temp.next = list1
            list1 = list1.next
        else:
            temp.next = list2
            list2 = list2.next
        # Move the temporary pointer
        # to the next node
        temp = temp.next 

    # If any list still has remaining
    # elements, append them to the merged list
    if list1 is not None:
        temp.next = list1
    else:
        temp.next = list2
    
    # Return the merged list starting 
    # from the next of the dummy node
    return dummyNode.next

# Function to find the middle of a linked list
def findMiddle(head):
    # If the list is empty or has only one node
    # the middle is the head itself
    if head is None or head.next is None:
        return head

    # Initializing slow and fast pointers
    slow = head
    fast = head.next

    # Move the fast pointer twice as
    # fast as the slow pointer

    while fast is not None and fast.next is not None:
        slow = slow.next
        fast = fast.next.next
        
    # When the fast pointer reaches the end,
    # the slow pointer will be at the middle

    return slow

# Function to perform merge sort on a linked list
def sortLL(head):
    # Base case: if the list is empty
    # or has only one node it is already 
    # sorted, so return the head
    if head is None or head.next is None:
        return head

    # Find the middle of the list
    # using the findMiddle function
    middle = findMiddle(head)

    # Divide the list into two halves
    right = middle.next
    middle.next = None
    left = head

    # Recursively sort the left and right halves
    left = sortLL(left)
    right = sortLL(right)

    # Merge the sorted halves using
    # the mergeTwoSortedLinkedLists function
    return mergeTwoSortedLinkedLists(left, right)

# Function to print the linked list
def printLinkedList(head):
    temp = head
    while temp is not None:
        # Print the data of the current node
        print(temp.data, end=" ")
        # Move to the next node
        temp = temp.next
    print()

# Linked List: 3 2 5 4 1
head = Node(3)
head.next = Node(2)
head.next.next = Node(5)
head.next.next.next = Node(4)
head.next.next.next.next = Node(1)

print("Original Linked List: ", end="")
printLinkedList(head)

# Sort the linked list
head = sortLL(head)

print("Sorted Linked List: ", end="")
printLinkedList(head)
    


# 12 TODO : sort a LL of 0's, 1's and 2's by changing links
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡




https://bit.ly/3Ceotvr





'''
# method 1 : brute force approch
'''
- create three variables count0, count1, count1 and initialize them with 0
- iterate over the linked list and increment the variable which ever is found 
- again, iterate over the linked list push the values inside that linked list 


TC - O(2N)
SC - O(N)
'''
class Node:
    def __init__(self, data, next = None, back=None):
        self.data = data
        self.next = next
        self.back = back
    
class DoublyLinkedList:
  def __init__(self):
    self.head = None
    
def print_list(dll):
  current = dll
  while current:
      print(current.data, end=" <-> ")
      current = current.next
  print("None")

def convertArrToDLL(arr):
  # If the array is empty, return immediately
  if not arr:
      return None
  
  # Create the head node using the first element of the array
  head = Node(arr[0])
  prev = head
  
  # Traverse the array and create nodes, linking them together
  for i in range(1, len(arr)):
    # self.append(arr[i])
    new_node = Node(arr[i], None ,prev)  # Create a new node for each element
    prev.next = new_node
    prev = new_node  # Move current to the new node
  return head
  
def sort012(ll):
  if not ll or not ll.next:
    return ll 
  temp = ll 
  count0 = 0
  count1 = 0
  count2 = 0
  while temp:
    if temp.data == 0:
      count0 += 1
    elif temp.data == 1:
      count1 += 1 
    else:
      count2 += 1 
    temp = temp.next
  
  temp = ll 
  while temp:
    if count0:
      temp.data = 0
      count0 -= 1
    elif count1:
      temp.data = 1
      count1 -= 1
    else:
      temp.data = 2
      count2 -= 1
    temp = temp.next    
  return ll
  
def main_function(arr1):
  dll1 = convertArrToDLL(arr1)
  odd_even = sort012(dll1)
  print_list(odd_even)
  return None
  
arr1 = [0,1,1,1,2,2,0,0,1,1]
print(main_function(arr1))

# method 2 : better approch

# method 3 : optimal approch
'''
- create 3 seperate linked list with single note having value -1 also hold their head pointer in 3 different variable zeroHead, oneHead and twoHead
- iterate over the linked list and add the nodes in the respective linked list based on values
- remove first node ie -1 from each linked list
- link the last pointers next value with each other 0 -> 1 -> 2 -> None 

- 
TC - O(N)
SC - O(1)
'''
class Node:
    def __init__(self, data, next = None, back=None):
        self.data = data
        self.next = next
        self.back = back
    
class DoublyLinkedList:
  def __init__(self):
    self.head = None
    
def print_list(dll):
  current = dll
  while current:
      print(current.data, end=" <-> ")
      current = current.next
  print("None")

def convertArrToDLL(arr):
  # If the array is empty, return immediately
  if not arr:
      return None
  
  # Create the head node using the first element of the array
  head = Node(arr[0])
  prev = head
  
  # Traverse the array and create nodes, linking them together
  for i in range(1, len(arr)):
    # self.append(arr[i])
    new_node = Node(arr[i], None ,prev)  # Create a new node for each element
    prev.next = new_node
    prev = new_node  # Move current to the new node
  return head

def sort012(ll):
  if not ll or not ll.next:
    return ll 
  temp = ll 
  zeroHead = Node(-1)
  oneHead = Node(-1)
  twoHead = Node(-1)
  zero = zeroHead
  one = oneHead
  two = twoHead
  while temp != None:
    if temp.data == 0:
      print("0 => ",temp.data)
      zero.next = temp
      zero = zero.next
      # zero = temp
    elif temp.data == 1:
      print("1 => ",temp.data)
      one.next = temp
      one = one.next
      # one = temp
    else:
      print("2 => ",temp.data)
      two.next = temp
      two = two.next
      # two = temp
    temp = temp.next
  
  print_list(zeroHead)
  print_list(oneHead)
  print_list(twoHead)
  zero.next = oneHead.next if oneHead.next else twoHead.next  # Link zero list to the one or two list
  one.next = twoHead.next  # Link the one list to the two list
  two.next = None  # End of the list
  new_node = zeroHead.next
  # do code to delete dummyHead
  # ... code 
  print_list(new_node)
  return new_node
  
def main_function(arr1):
  dll1 = convertArrToDLL(arr1)
  odd_even = sort012(dll1)
  print_list(odd_even)
  return None
  
arr1 = [0,1,1,1,2,2,0,0,1,1]
print(main_function(arr1))

# 13 TODO : find the intersection points of Y LL
# method 1 : brute force approch
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://takeuforward.org/data-structure/find-intersection-of-two-linked-lists/


https://leetcode.com/problems/intersection-of-two-linked-lists/



https://www.youtube.com/watch?v=0DYoPz2Tpt4&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=248




Time Complexity: O(m*n)

Reason: For each node in list 2 entire list 1 is iterated. 

Space Complexity: O(1)

Reason: No extra space is used.
'''
class Node:
    def __init__(self, val):
        self.val = val
        self.next = None




# utility function to insert node at the end of the linked list
def insertNode(head, val):
    newNode = Node(val)
    if head == None:
        head = newNode
        return head
    temp = head
    while temp.next != None:
        temp = temp.next
    temp.next = newNode
    return head




# utility function to check presence of intersection
def intersectionPresent(head1, head2):
    while head2 != None:
        temp = head1
        while temp != None:
            # if both nodes are same
            if temp == head2:
                return head2
            temp = temp.next
        head2 = head2.next
    # intersection is not present between the lists
    return None




# utility function to print linked list created
def printList(head):
    while head.next != None:
        print(head.val, end='->')
        head = head.next
    print(head.val)




if __name__ == '__main__':
    head = None
    head = insertNode(head, 1)
    head = insertNode(head, 3)
    head = insertNode(head, 1)
    head = insertNode(head, 2)
    head = insertNode(head, 4)
    head1 = head
    head = head.next.next.next
    headSec = None
    headSec = insertNode(headSec, 3)
    head2 = headSec
    headSec.next = head
    print('List1: ', end='')
    printList(head1)
    print('List2: ', end='')
    printList(head2)
    answerNode = intersectionPresent(head1, head2)
    if answerNode == None:
        print('No intersection')
    else:
        print('The intersection point is', answerNode.val) 


# method 2 : better approch


Time Complexity: O(n+m)
'''
- iterate over the first linked list and store it's node in an array/dict
- the, iterate over the second linked list and check if it is present in the array or not. 
- if present return the first node of intersection it will the head 

Reason: Iterating through list 1 first takes O(n), then iterating through list 2 takes O(m). 

Space Complexity: O(n)

Reason: Storing list 1 node addresses in unordered_set.
'''
class Node:
    def __init__(self, val):
        self.val = val
        self.next = None




# utility function to insert node at the end of the linked list
def insertNode(head, val):
    newNode = Node(val)
    if head == None:
        head = newNode
        return head
    temp = head
    while temp.next != None:
        temp = temp.next
    temp.next = newNode
    return head




# utility function to check presence of intersection
def intersectionPresent(head1, head2):
    st = set()
    while head1 != None:
        st.add(head1)
        head1 = head1.next
    while head2 != None:
        if head2 in st:
            return head2
        head2 = head2.next
    return None




# utility function to print linked list created
def printList(head):
    while head.next != None:
        print(head.val, end='->')
        head = head.next
    print(head.val)




if __name__ == '__main__':
    head = None
    head = insertNode(head, 1)
    head = insertNode(head, 3)
    head = insertNode(head, 1)
    head = insertNode(head, 2)
    head = insertNode(head, 4)
    head1 = head
    head = head.next.next.next
    headSec = None
    headSec = insertNode(headSec, 3)
    head2 = headSec
    headSec.next = head
    print('List1: ', end='')
    printList(head1)
    print('List2: ', end='')
    printList(head2)
    answerNode = intersectionPresent(head1, head2)
    if answerNode == None:
        print('No intersection')
    else:
        print('The intersection point is', answerNode.val)


# method 3 : optimal solution
'''
- find the length of both linked list
- find the difference  = l2 -l1
- mark the longer linked list at the defference index node
- then iterate over the shorter linked list and compare it's value with the other one


Time Complexity:

O(2max(length of list1,length of list2))+O(abs(length of list1-length of list2))+O(min(length of list1,length of list2))

Reason: Finding the length of both lists takes max(length of list1, length of list2) because it is found simultaneously for both of them. Moving the head pointer ahead by a difference of them. The next one is for searching.

Space Complexity: O(1)

Reason: No extra space is used.
'''
class Node:
    def __init__(self, val):
        self.val = val
        self.next = None




# utility function to insert node at the end of the linked list
def insertNode(head, val):
    newNode = Node(val)
    if head == None:
        head = newNode
        return head
    temp = head
    while temp.next != None:
        temp = temp.next
    temp.next = newNode
    return head




def getDifference(head1, head2):
    len1 = 0
    len2 = 0
    while head1 != None or head2 != None:
        if head1 != None:
            len1 += 1
            head1 = head1.next
        if head2 != None:
            len2 += 1
            head2 = head2.next
    # if difference is neg-> length of list2 > length of list1 else vice-versa
    return len1 - len2




# utility function to check presence of intersection
def intersectionPresent(head1, head2):
    diff = getDifference(head1, head2)
    if diff < 0:
        while diff != 0:
            head2 = head2.next
            diff += 1
    else:
        while diff != 0:
            head1 = head1.next
            diff -= 1
    while head1 != None:
        if head1 == head2:
            return head1
        head2 = head2.next
        head1 = head1.next
    return head1




# utility function to print linked list created
def printList(head):
    while head.next != None:
        print(head.val, end='->')
        head = head.next
    print(head.val)




if __name__ == '__main__':
    head = None
    head = insertNode(head, 1)
    head = insertNode(head, 3)
    head = insertNode(head, 1)
    head = insertNode(head, 2)
    head = insertNode(head, 4)
    head1 = head
    head = head.next.next.next
    headSec = None
    headSec = insertNode(headSec, 3)
    head2 = headSec
    headSec.next = head
    print('List1: ', end='')
    printList(head1)
    print('List2: ', end='')
    printList(head2)
    answerNode = intersectionPresent(head1, head2)
    if answerNode == None:
        print('No intersection')
    else:
        print('The intersection point is', answerNode.val)

# method 4 optimized
'''
- iterate over the linked list simultaneously and increment them by 1
- if t1 get None then head of ll2 will be assigned to t1 and vice versa
- at a certain point both gets null at the same time by this

Time Complexity: O(2*max(length of list1,length of list2))

Reason: Uses the same concept of difference of lengths of two lists.

Space Complexity: O(1)

Reason: No extra data structure is used
'''
class Node:
    def __init__(self, val):
        self.val = val
        self.next = None




# utility function to insert node at the end of the linked list
def insertNode(head, val):
    newNode = Node(val)
    if head == None:
        head = newNode
        return head
    temp = head
    while temp.next != None:
        temp = temp.next
    temp.next = newNode
    return head




# utility function to check presence of intersection
def intersectionPresent(head1, head2):
    d1 = head1
    d2 = head2
    while d1 != d2:
        d1 = head2 if d1 == None else d1.next
        d2 = head1 if d2 == None else d2.next
    return d1




# utility function to print linked list created
def printList(head):
    while head.next != None:
        print(head.val, end='->')
        head = head.next
    print(head.val)




if __name__ == '__main__':
    head = None
    head = insertNode(head, 1)
    head = insertNode(head, 3)
    head = insertNode(head, 1)
    head = insertNode(head, 2)
    head = insertNode(head, 4)
    head1 = head
    head = head.next.next.next
    headSec = None
    headSec = insertNode(headSec, 3)
    head2 = headSec
    headSec.next = head
    print('List1: ', end='')
    printList(head1)
    print('List2: ', end='')
    printList(head2)
    answerNode = intersectionPresent(head1, head2)
    if answerNode == None:
        print('No intersection')
    else:
        print('The intersection point is', answerNode.val)



# 14 TODO : add 1 to a number represented by LL
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://bit.ly/3piCTD3



'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 15 TODO :add 2 numbers in LL
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://takeuforward.org/data-structure/add-two-numbers-represented-as-linked-lists/

https://www.youtube.com/watch?v=XmRrGzR6udg&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=241

https://leetcode.com/problems/add-two-numbers/

'''
# method 1 : brute force approch
'''
Time Complexity: O(max(m,n)). Assume that m and n represent the length of l1 and l2 respectively, the algorithm above iterates at most max(m,n) times.

Space Complexity: O(max(m,n)). The length of the new list is at most max(m,n)+1.
'''
# Definition for singly-linked list.
class ListNode:
  def __init__(self, val=0, next=None):
    self.val = val
    self.next = next

class Solution:
  def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
    dummy = ListNode()
    temp = dummy
    carry = 0
    while l1 or l2 or carry:
      total = carry
      if l1:
        total += l1.val
        l1 = l1.next
      if l2:
        total += l2.val
        l2 = l2.next
      carry = total // 10
      node = ListNode(total % 10)
      temp.next = node
      temp = temp.next
    return dummy.next

def create_linked_list(nums):
  head = ListNode(nums[0])
  current = head
  for num in nums[1:]:
    current.next = ListNode(num)
    current = current.next
  return head

def print_linked_list(node):
  while node:
    print(node.val, end="")
    if node.next:
      print(" -> ", end="")
    node = node.next
  print()

# Example: (2 -> 4 -> 3) + (5 -> 6 -> 4) = 7 -> 0 -> 8
l1 = create_linked_list([2, 4, 3])
l2 = create_linked_list([5, 6, 4])

solution = Solution()
result = solution.addTwoNumbers(l1, l2)

print_linked_list(result)



ğŸ‘‰ğŸ‘‰ğŸ‘‰
'''
class Node:
    def __init__(self, data, next = None, back=None):
        self.data = data
        self.next = next
        self.back = back
    
class DoublyLinkedList:
  def __init__(self):
    self.head = None
    
def print_list(dll):
  current = dll
  while current:
      print(current.data, end=" <-> ")
      current = current.next
  print("None")

def convertArrToDLL(arr):
  # If the array is empty, return immediately
  if not arr:
      return None
  
  # Create the head node using the first element of the array
  head = Node(arr[0])
  prev = head
  
  # Traverse the array and create nodes, linking them together
  for i in range(1, len(arr)):
    # self.append(arr[i])
    new_node = Node(arr[i], None ,prev)  # Create a new node for each element
    prev.next = new_node
    prev = new_node  # Move current to the new node
  return head
  
# def reverseDLL(self):
#   if self.head == None or self.head.next == None:
#     return self.head
  
#   prev = None
#   current = self.head
#   while current:
#     prev = current.back
    
#     current.back = current.next
#     current.next = prev
    
#     current = current.back
  
#   print("---->",self.print_list())
#   return prev.back

def remove_dummy_node(head):
  if head == None or head.next == None:
    return None 
  print_list(head)
  temp = head
  head = temp.next
  head.prev = None
  temp.next = None 
  temp = None
  print_list(head)
  return head

def sumLL(ll1, ll2):
  dummy_node = Node(-1)
  # print_list(dummy_node)
  curr = dummy_node
  # print_list(curr)
  carry = 0
  t1 = ll1
  t2 = ll2 
  while t1 is not None or t2 is not None:
    sum = carry
    if t1:
      sum  = sum + t1.data
    if t2:
      sum = sum + t2.data
    new_node = Node(sum % 10)
    carry = sum // 10
    curr.next = new_node
    curr = curr.next
    if t1:
      t1 = t1.next
    if t2:
      t2 = t2.next
  if carry:
    new_node = Node(carry)
    curr.next = new_node
  
  head = remove_dummy_node(dummy_node)
  return head
  
def main_function(arr1, arr2):
  dll = DoublyLinkedList()
  dll1 = convertArrToDLL(arr1)
  dll2 = convertArrToDLL(arr2)
  print(print_list(dll1))
  print(print_list(dll2))
  
  sum  = sumLL(dll1,dll2)
  print(print_list(sum))
  
  # print(dll.reverseDLL().__dict__)
  return None
  
arr1 = [3,5]
arr2 = [4,5,9,9]
print(main_function(arr1, arr2))
'''

# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# endregion






# region 6.4 LINKED LIST - DOUBLY MEDIUM
# --------------------------------------

# 1 TODO :  delete all occurences of a key in DLL
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://bit.ly/3zuBr66



'''
# method 1 : brute force approch
'''
https://www.youtube.com/watch?v=Mh0NH_SD92k&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=254
TC     -      O(N)
SC     -      O(1)
'''
class Node:
    def __init__(self, data, next = None, back=None):
        self.data = data
        self.next = next
        self.back = back
    
class DoublyLinkedList:
  def __init__(self):
    self.head = None
    
def print_list(dll):
  current = dll
  while current:
      print(current.data, end=" <-> ")
      current = current.next
  print("None")

def convertArrToDLL(arr):
  # If the array is empty, return immediately
  if not arr:
      return None
  
  # Create the head node using the first element of the array
  head = Node(arr[0])
  prev = head
  
  # Traverse the array and create nodes, linking them together
  for i in range(1, len(arr)):
    # self.append(arr[i])
    new_node = Node(arr[i], None ,prev)  # Create a new node for each element
    prev.next = new_node
    prev = new_node  # Move current to the new node
  return head
  
def delete_all_occurances(ll, value):
  temp=ll 
  while temp:
    if temp.data == value:
      if temp == ll:
        ll = ll.next
      pre_node = temp.back
      next_node = temp.next 
      if next_node:
        next_node.back = pre_node
      if pre_node:
        pre_node.next = next_node
      temp = None
      temp = next_node
    else:
      temp = temp.next
  return ll  
  
def main_function(arr1, sum):
  dll1 = convertArrToDLL(arr1)
  new_ll = delete_all_occurances(dll1, sum)
  print_list(new_ll)
  return None
  
arr1 = [3,1,2,3,3,4,9,3]
value  = 3
print(main_function(arr1,value))   


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : find pairs with given sum in DLL
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://bit.ly/3zWPiBj


'''
# method 1 : brute force approch
'''
https://www.youtube.com/watch?v=YitR4dQsddE&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=255

- take head as temp1 and head.next as temp2
- increment temp2 making temp1 at when place then again increment temp1 and so on

TC     -    O~(N*N)  
SC     -    O(1) 
'''
class Node:
    def __init__(self, data, next = None, back=None):
        self.data = data
        self.next = next
        self.back = back
    
class DoublyLinkedList:
  def __init__(self):
    self.head = None
    
def print_list(dll):
  current = dll
  while current:
      print(current.data, end=" <-> ")
      current = current.next
  print("None")

def convertArrToDLL(arr):
  # If the array is empty, return immediately
  if not arr:
      return None
  
  # Create the head node using the first element of the array
  head = Node(arr[0])
  prev = head
  
  # Traverse the array and create nodes, linking them together
  for i in range(1, len(arr)):
    # self.append(arr[i])
    new_node = Node(arr[i], None ,prev)  # Create a new node for each element
    prev.next = new_node
    prev = new_node  # Move current to the new node
  return head
  
def find_sum_values(ll, target_sum):
  temp1=ll 
  list = []
  while temp1 != None:
    temp2 = temp1.next
    while temp2 != None:
      if (temp1.data + temp2.data == sum) and (temp1.data + temp2.data < sum):
        list.append([temp1.data, temp2.data])
      temp2 = temp2.next
    temp1 = temp1.next
  return list  
  
def main_function(arr1, sum):
  dll1 = convertArrToDLL(arr1)
  sum_values = find_sum_values(dll1, sum)
  print(sum_values)
  return None
  
arr1 = [1,2,3,4,9]
sum  = 5
print(main_function(arr1,sum))

# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
- take head as left, tail as right and a list to store the data and apply two pointer approch

TC     -      
SC     -
'''
class Node:
    def __init__(self, data, next = None, back=None):
        self.data = data
        self.next = next
        self.back = back
    
class DoublyLinkedList:
  def __init__(self):
    self.head = None
    
def print_list(dll):
  current = dll
  while current:
      print(current.data, end=" <-> ")
      current = current.next
  print("None")

def convertArrToDLL(arr):
  # If the array is empty, return immediately
  if not arr:
      return None
  
  # Create the head node using the first element of the array
  head = Node(arr[0])
  prev = head
  
  # Traverse the array and create nodes, linking them together
  for i in range(1, len(arr)):
    # self.append(arr[i])
    new_node = Node(arr[i], None ,prev)  # Create a new node for each element
    prev.next = new_node
    prev = new_node  # Move current to the new node
  return head
  
def find_tail(ll):
  tail = ll
  while tail.next:
    tail = tail.next
  return tail
  
def find_sum_values(ll, sum):
  left=ll 
  right = find_tail(ll)
  list = []
  while left.data < right.data:
    if left.data + right.data == sum:
      list.append([left.data, right.data])
      left = left.next
      right = right.back
    elif left.data + right.data < sum:
      left = left.next
    else:
      right = right.back
  return list
  # return ll
  
def main_function(arr1, sum):
  dll1 = convertArrToDLL(arr1)
  sum_values = find_sum_values(dll1, sum)
  print(sum_values)
  return None
  
arr1 = [1,2,3,4,9]
sum  = 5
print(main_function(arr1,sum))


# 3 TODO : remove duplicates from sorted DLL
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://bit.ly/3FtJUtZ


'''
# method 1 : brute force approch
'''
https://www.youtube.com/watch?v=YJKVTnOJXSY&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=256

TC     -      O(N)
SC     -     O(1)
'''
class Node:
    def __init__(self, data, next = None, back=None):
        self.data = data
        self.next = next
        self.back = back
    
class DoublyLinkedList:
  def __init__(self):
    self.head = None
    
def print_list(dll):
  current = dll
  while current:
      print(current.data, end=" <-> ")
      current = current.next
  print("None")

def convertArrToDLL(arr):
  # If the array is empty, return immediately
  if not arr:
      return None
  
  # Create the head node using the first element of the array
  head = Node(arr[0])
  prev = head
  
  # Traverse the array and create nodes, linking them together
  for i in range(1, len(arr)):
    # self.append(arr[i])
    new_node = Node(arr[i], None ,prev)  # Create a new node for each element
    prev.next = new_node
    prev = new_node  # Move current to the new node
  return head
  
def delete_all_duplicates(ll):
  temp=ll 
  while temp and temp.next:
    next_node = temp.next 
    while next_node and next_node.data == temp.data:
      duplicate = next_node
      next_node = next_node.next
      duplicate = None 
    temp.next = next_node
    if next_node:
      next_node.back = temp
    temp = temp.next
  return ll  
  
def main_function(arr1):
  dll1 = convertArrToDLL(arr1)
  new_ll = delete_all_duplicates(dll1)
  print_list(new_ll)
  return None
  
arr1 = [1,1,1,2,3,3,4]
# value  = 3
print(main_function(arr1))

# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      




# endregion






# region 6.5 LINKED LIST - HARD
# -----------------------------

# 1 TODO :  reverse LL in group of given size K
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/data-structure/reverse-linked-list-in-groups-of-size-k/


https://leetcode.com/problems/reverse-nodes-in-k-group/




'''
# method 1 : brute force approch
'''
https://www.youtube.com/watch?v=lIar1skcQYI&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=258  

- initialize variable tep as head and prevNode as Node
- write a function to return the Kth node from the linked list
- write a function to reverse a linked list
- iterate over the linked list
- If kth node is None, link the last node to the current node and break
- store the Kth Node in a vauable, and make Kth node next to null to break the linked list because a section of a linked list cannot be reversed
- reverse the linked list from the Kth node to the current node
- if temp == head, then make the Kth node as head else Link the last node of the previous group to the reversed group
- update the prev Node with temp 
- take next group first node as temp






Time Complexity: O(2N) The time complexity consists of actions of reversing segments of K and finding the Kth node which operates in linear time. Thus, O(N) + O(N) = O(2N), which simplifies to O(N).

Space Complexity: O(1) The space complexity is O(1) as the algorithm operates in place without any additional space requirements.
'''
class Node:
    def __init__(self, data, next_node=None):
        self.data = data
        self.next = next_node

# Function to reverse linked list
# using 3 pointer approach
def reverseLinkedList(head):
    
    # Initialize 'temp' at the
    # head of the linked list
    temp = head
    
    # Initialize 'prev' to None,
    # representing the previous node 
    prev = None
    
    while temp is not None:
        # Store the next node in 'front'
        # to preserve the reference
        front = temp.next
        # Reverse the direction of the current
        # node's 'next' pointer to point to 'prev'
        temp.next = prev
        # Move 'prev' to the current 
        # node, for the next iteration
        prev = temp
        # Move 'temp' to 'front' node
        # advancing traversal
        temp = front

    # Return the new head
    # of the reversed linked list
    return prev
    
# Function to get the Kth node from
# a given position in the linked list
def getKthNode(temp, k):
    # Decrement K as we already
    # start from the 1st node
    k -= 1

    # Decrement K until it reaches
    # the desired position
    while temp is not None and k > 0:
        # Decrement k as temp progresses
        k -= 1

        # Move to the next node
        temp = temp.next

    # Return the Kth node
    return temp


# Function to reverse nodes in groups of K
def kReverse(head, k):
    # Initialize a temporary
    # node to traverse the list
    temp = head

    # Initialize a pointer to track the
    # last node of the previous group
    prevLast = None

    # Traverse through the linked list
    while temp is not None:
        # Get the Kth node of the current group
        kThNode = getKthNode(temp, k)

        # If the Kth node is NULL
        # (not a complete group)
        if kThNode is None:
            # If there was a previous group,
            # link the last node to the current node
            if prevLast:
                prevLast.next = temp

            # Exit the loop
            break

        # Store the next node
        # after the Kth node
        nextNode = kThNode.next

        # Disconnect the Kth node
        # to prepare for reversal
        kThNode.next = None

        # Reverse the nodes from
        # temp to the Kth node
        reverseLinkedList(temp)

        # Adjust the head if the reversal
        # starts from the head
        if temp == head:
            head = kThNode
        else:
            # Link the last node of the previous
            # group to the reversed group
            prevLast.next = kThNode

        # Update the pointer to the
        # last node of the previous group
        prevLast = temp

        # Move to the next group
        temp = nextNode

    # Return the head of the
    # modified linked list
    return head


# Function to print the linked list
def printLinkedList(head):
    temp = head
    while temp is not None:
        print(temp.data, end=" ")
        temp = temp.next
    print()


class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


# Create a linked list with
# values 5, 4, 3, 7, 9 and 2
head = Node(5)
head.next = Node(4)
head.next.next = Node(3)
head.next.next.next = Node(7)
head.next.next.next.next = Node(9)
head.next.next.next.next.next = Node(2)

# Print the original linked list
print("Original Linked List: ", end="")
printLinkedList(head)

# Reverse the linked list
head = kReverse(head, 4)

# Print the reversed linked list
print("Reversed Linked List: ", end="")
printLinkedList(head)  


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : rotate a LL
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/rotate-a-linked-list/


https://leetcode.com/problems/rotate-list/description/




'''
# method 1 : brute force approch

'''

Time Complexity: O(Number of nodes present in the list*k)

Reason: For k times, we are iterating through the entire list to get the last element and move it to first.

Space Complexity: O(1)

Reason: No extra data structures is used for computations
'''
class Node:
    def __init__(self, val):
        self.val = val
        self.next = None




# utility function to insert node at the end of the linked list
def insertNode(head, val):
    newNode = Node(val)
    if head == None:
        head = newNode
        return head
    temp = head
    while temp.next != None:
        temp = temp.next
    temp.next = newNode
    return head




# utility function to rotate list by k times
def rotateRight(head, k):
    if head == None or head.next == None:
        return head
    for i in range(k):
        temp = head
        while temp.next.next != None:
            temp = temp.next
        end = temp.next
        temp.next = None
        end.next = head
        head = end
    return head




# utility function to print list
def printList(head):
    while head.next != None:
        print(head.val, end='->')
        head = head.next
    print(head.val)
    return




if __name__ == '__main__':
    head = None
    # inserting Node
    head = insertNode(head, 1)
    head = insertNode(head, 2)
    head = insertNode(head, 3)
    head = insertNode(head, 4)
    head = insertNode(head, 5)


    print("Original list: ", end='')
    printList(head)


    k = 2
    # calling function for rotating right of the nodes by k times
    newHead = rotateRight(head, k)


    print("After", k, "iterations: ", end='')
    printList(newHead)  # list after rotating nodes


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''

https://www.youtube.com/watch?v=uT7YI7XbTY8&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=258

- take two vaiables head and tail, initialize them with the head of ll and a variable len with 1
- find the length of the linked list
- base condition if K%len == 0 then return head
- connect the tail to the head of the linked list
- find the node that should be the end ie (len - k)th node
- make the (len - k)th node next as head
- make (len - k)th node next as None 



Time Complexity: O(length of list) + O(length of list - (length of list%k))

Reason: O(length of the list) for calculating the length of the list. O(length of the list - (length of list%k)) for breaking link.

Space Complexity: O(1)

Reason: No extra data structure is used for computation.
'''
class Node:
    def __init__(self, val):
        self.val = val
        self.next = None




# utility function to insert node at the end of the linked list
def insertNode(head, val):
    newNode = Node(val)
    if head == None:
        head = newNode
        return head
    temp = head
    while temp.next != None:
        temp = temp.next
    temp.next = newNode
    return head




# utility function to rotate list by k times
def rotateRight(head, k):
    if head == None or head.next == None or k == 0:
        return head
    # calculating length
    temp = head
    length = 1
    while temp.next != None:
        length += 1
        temp = temp.next
    # link last node to first node
    temp.next = head
    k = k % length  # when k is more than length of list
    end = length - k  # to get end of the list
    while end:
        temp = temp.next
        end -= 1
    # breaking last node link and pointing to NULL
    head = temp.next
    temp.next = None


    return head




# utility function to print list
def printList(head):
    while head.next != None:
        print(head.val, end='->')
        head = head.next
    print(head.val)
    return




if __name__ == '__main__':
    head = None
    # inserting Node
    head = insertNode(head, 1)
    head = insertNode(head, 2)
    head = insertNode(head, 3)
    head = insertNode(head, 4)
    head = insertNode(head, 5)


    print("Original list: ", end='')
    printList(head)


    k = 2
    # calling function for rotating right of the nodes by k times
    newHead = rotateRight(head, k)


    print("After", k, "iterations: ", end='')
    printList(newHead)  # list after rotating nodes


# 3 TODO : flattening of LL
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/data-structure/flattening-a-linked-list/


https://bit.ly/3w9TKf8



'''
# method 1 : brute force approch
'''

https://www.youtube.com/watch?v=ykelywHJWLg&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=260

- initialize a blank array to store all elements
- take temp to point on main node and temp2 to point the child node
- use while into while and put all ements in the arr
- do sorting on the arr
- create avertical linked list wth these values


Time Complexity: O(N*M) + O(N*M log(N*M)) + O(N*M)where N is the length of the linked list along the next pointer and M is the length of the linked list along the child pointer.

O(N*M) as we traverse through all the elements, iterating through â€˜Nâ€™ nodes along the next pointer and â€˜Mâ€™ nodes along the child pointer.
O(N*M log(N*M)) as we sort the array containing N*M (total) elements.
O(N*M) as we reconstruct the linked list from the sorted array by iterating over the N*M elements of the array.
Space Complexity : O(N*M) + O(N*M)where N is the length of the linked list along the next pointer and M is the length of the linked list along the child pointer.

O(N*M) for storing all the elements in an additional array for sorting.
O(N*M) to reconstruct the linked list from the array after sorting
'''
                                
class Node:
    def __init__(self, x=None, nextNode=None, childNode=None):
        self.data = x
        self.next = nextNode
        self.child = childNode

# Function to convert a list to a linked list
def convertArrToLinkedList(arr):
    # Create a dummy node to serve as
    # the head of the linked list
    dummyNode = Node(-1)
    temp = dummyNode

    # Iterate through the list and
    # create nodes with list elements
    for val in arr:
        # Create a new node with the list element
        temp.child = Node(val)
        # Move the temporary pointer
        # to the newly created node
        temp = temp.child

    # Return the linked list starting
    # from the next of the dummy node
    return dummyNode.child

# Function to flatten a linked list with child pointers
def flattenLinkedList(head):
    arr = []

    # Traverse through the linked list
    while head:
        # Traverse through the child
        # nodes of each head node
        t2 = head
        while t2:
            # Store each node's data in the list
            arr.append(t2.data)
            # Move to the next child node
            t2 = t2.child
        # Move to the next head node
        head = head.next

    # Sort the list containing
    # node values in ascending order
    arr.sort()

    # Convert the sorted list
    # back to a linked list
    return convertArrToLinkedList(arr)

# Print the linked list by
# traversing through child pointers
def printLinkedList(head):
    while head:
        print(head.data, end=" ")
        head = head.child
    print()

# Print the linked list
# in a grid-like structure
def printOriginalLinkedList(head, depth=0):
    while head:
        print(head.data, end="")

        # If child exists, recursively
        # print it with indentation
        if head.child:
            print(" -> ", end="")
            printOriginalLinkedList(head.child, depth + 1)

        # Add vertical bars
        # for each level in the grid
        if head.next:
            print()
            print("| " * depth, end="")

        head = head.next

# Create a linked list with child pointers
head = Node(5)
head.child = Node(14)

head.next = Node(10)
head.next.child = Node(4)

head.next.next = Node(12)
head.next.next.child = Node(20)
head.next.next.child.child = Node(13)

head.next.next.next = Node(7)
head.next.next.next.child = Node(17)

# Print the original
# linked list structure
print("Original linked list:")
printOriginalLinkedList(head)

# Flatten the linked list
# and print the flattened list
flattened = flattenLinkedList(head)
print("\nFlattened linked list: ")
printLinkedList(flattened)



# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
https://www.youtube.com/watch?v=ykelywHJWLg&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=260


Time Complexity: O( N*(2M) ) ~ O(2 N*M)where N is the length of the linked list along the next pointer and M is the length of the linked list along the child pointers.

The merge operation in each recursive call takes time complexity proportional to the length of the linked lists being merged as they have to iterate over the entire lists. Since the vertical depth of the linked lists is assume to be M, the time complexity for a single merge operation is proportional to O(2*M).
This operation operation is performed N number of times (to each and every node along the next pointer list) hence the resultant time complexity becomes: O(N* 2M).
Space Complexity : O(1) as this algorithm uses no external space or additional data structures to store values. But a recursive stack uses O(N) space to build the recursive calls for each node along the next pointer list.
'''
                     
class Node:
    def __init__(self, x=0, nextNode=None, childNode=None):
        self.data = x
        self.next = nextNode
        self.child = childNode

# Merges two linked lists in a particular
# order based on the data value
def merge(list1, list2):
    # Create a dummy node as a
    # placeholder for the result
    dummyNode = Node(-1)
    res = dummyNode

    # Merge the lists based on data values
    while list1 and list2:
        if list1.data < list2.data:
            res.child = list1
            res = list1
            list1 = list1.child
        else:
            res.child = list2
            res = list2
            list2 = list2.child
        res.next = None

    # Connect the remaining
    # elements if any
    if list1:
        res.child = list1
    else:
        res.child = list2

    # Break the last node's
    # link to prevent cycles
    if dummyNode.child:
        dummyNode.child.next = None

    return dummyNode.child

# Flattens a linked list with child pointers
def flattenLinkedList(head):
    # If head is null or there 
    # is no next node, return head
    if not head or not head.next:
        return head

    # Recursively flatten the
    # rest of the linked list
    mergedHead = flattenLinkedList(head.next)
    head = merge(head, mergedHead)
    return head

# Print the linked list by
# traversing through child pointers
def printLinkedList(head):
    while head:
        print(head.data, end=" ")
        head = head.child
    print()

# Print the linked list
# in a grid-like structure
def printOriginalLinkedList(head, depth):
    while head:
        print(head.data, end="")

        # If child exists, recursively
        # print it with indentation
        if head.child:
            print(" -> ", end="")
            printOriginalLinkedList(head.child, depth + 1)

        # Add vertical bars
        # for each level in the grid
        if head.next:
            print()
            print("| " * depth, end="")
        head = head.next

# Create a linked list with child pointers
head = Node(5)
head.child = Node(14)
head.next = Node(10)
head.next.child = Node(4)
head.next.next = Node(12)
head.next.next.child = Node(20)
head.next.next.child.child = Node(13)
head.next.next.next = Node(7)
head.next.next.next.child = Node(17)

# Print the original
# linked list structure
print("Original linked list:")
printOriginalLinkedList(head, 0)

# Flatten the linked list
# and print the flattened list
flattened = flattenLinkedList(head)
print("\nFlattened linked list: ", end="")
printLinkedList(flattened)

                                
                            


# 4 TODO : clone a linked list with random and next pointer
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/data-structure/clone-linked-list-with-random-and-next-pointer/


https://leetcode.com/problems/copy-list-with-random-pointer/



'''
# method 1 : brute force approch
'''
https://www.youtube.com/watch?v=q570bKdrnlw&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=263

- store each node as key as the node value node but without links pair
- put the values of next and random pointer using the hash object


Time Complexity: O(2N) where N is the number of nodes in the linked list. The linked list is traversed twice, once for creating copies of each node and for the second time to set the next and random pointers for each copied node. The time to access the nodes in the map is O(1) due to hashing.

Space Complexity : O(N)+O(N)where N is the number of nodes in the linked list as all nodes are stored in the map to maintain mappings and the copied linked lists takes O(N) space as well.
''' 
                                
# Node class to represent
# elements in the linked list
class Node:
    def __init__(self, x, nextNode=None, randomNode=None):
        # Data stored in the node
        self.data = x
        # Pointer to the next node
        self.next = nextNode
        # Pointer to a random
        # node in the list
        self.random = randomNode


# Function to clone the linked list
def cloneLL(head):
    temp = head
    # Create a dictionary to map original
    # nodes to their corresponding copied nodes
    mpp = {}

    # Step 1: Create copies of each node
    # and store them in the map
    while temp is not None:
        # Create a new node with the
        # same data as the original node
        newNode = Node(temp.data)
        # Map the original node to its
        # corresponding copied node in the dictionary
        mpp[temp] = newNode
        # Move to the next node in the original list
        temp = temp.next

    temp = head
    # Step 2: Connect the next and random
    # pointers of the copied nodes using the dictionary
    while temp is not None:
        # Access the copied node corresponding
        # to the current original node
        copyNode = mpp[temp]
        # Set the next pointer of the copied node
        # to the copied node mapped to the
        # next node in the original list
        copyNode.next = mpp[temp.next]
        # Set the random pointer of the copied node
        # to the copied node mapped to the
        # random node in the original list
        copyNode.random = mpp[temp.random]
        # Move to the next node
        # in the original list
        temp = temp.next

    # Return the head of the
    # deep copied list from the dictionary
    return mpp[head]


# Function to print the cloned linked list
def printClonedLinkedList(head):
    while head is not None:
        print(f"Data: {head.data}", end="")
        if head.random is not None:
            print(f", Random: {head.random.data}")
        else:
            print(", Random: nullptr")
        head = head.next


# Main function
if __name__ == "__main__":
    # Example linked list: 7 -> 14 -> 21 -> 28
    head = Node(7)
    head.next = Node(14)
    head.next.next = Node(21)
    head.next.next.next = Node(28)

    # Assigning random pointers
    head.random = head.next.next
    head.next.random = head
    head.next.next.random = head.next.next.next
    head.next.next.next.random = head.next

    print("Original Linked List with Random Pointers:")
    printClonedLinkedList(head)

    # Clone the linked list
    clonedList = cloneLL(head)

    print("\nCloned Linked List with Random Pointers:")
    printClonedLinkedList(clonedList)
                                
                            


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
- insert the copy node in between the nodes
- then connect the links

Time Complexity: O(3N)where N is the number of nodes in the linked list. The algorithm makes three traversals of the linked list, once to create copies and insert them between original nodes, then to set the random pointers of the copied nodes to their appropriate copied nodes and then to separate the copied and original nodes.

Space Complexity : O(N) where N is the number of nodes in the linked list as the only extra additional space allocated it to create the copied list without creating any other additional data structures.
'''
                                
                     
# Node class to represent
# elements in the linked list
class Node:
    # Data stored in the node
    def __init__(self, x):
        self.data = x
        # Pointer to the next node
        self.next = None
        # Pointer to a random
        # node in the list
        self.random = None

# Function to insert a copy of each
# node in between the original nodes
def insertCopyInBetween(head):
    temp = head
    while temp:
        nextElement = temp.next
        # Create a new node with the same data
        copy = Node(temp.data)

        # Point the copy's next to
        # the original node's next
        copy.next = nextElement

        # Point the original
        # node's next to the copy
        temp.next = copy

        # Move to the next original node
        temp = nextElement

# Function to connect random
# pointers of the copied nodes
def connectRandomPointers(head):
    temp = head
    while temp:
        # Access the copied node
        copyNode = temp.next

        # If the original node
        # has a random pointer
        if temp.random:
            # Point the copied node's random to the
            # corresponding copied random node
            copyNode.random = temp.random.next
        else:
            # Set the copied node's random to
            # null if the original random is null
            copyNode.random = None

        # Move to the next original node
        temp = temp.next.next

# Function to retrieve the
# deep copy of the linked list
def getDeepCopyList(head):
    temp = head
    # Create a dummy node
    dummyNode = Node(-1)
    # Initialize a result pointer
    res = dummyNode

    while temp:
        # Creating a new List by
        # pointing to copied nodes
        res.next = temp.next
        res = res.next

        # Disconnect and revert back to the
        # initial state of the original linked list
        temp.next = temp.next.next
        temp = temp.next

    # Return the deep copy of the
    # list starting from the dummy node
    return dummyNode.next

# Function to clone the linked list
def cloneLL(head):
    # If the original list
    # is empty, return null
    if not head:
        return None

    # Step 1: Insert copy of
    # nodes in between
    insertCopyInBetween(head)
    # Step 2: Connect random
    # pointers of copied nodes
    connectRandomPointers(head)
    # Step 3: Retrieve the deep
    # copy of the linked list
    return getDeepCopyList(head)

# Function to print the cloned linked list
def printClonedLinkedList(head):
    while head:
        print("Data:", head.data, end="")
        if head.random:
            print(", Random:", head.random.data, end="")
        else:
            print(", Random: None", end="")
        print()
        # Move to the next node
        head = head.next

# Main function
if __name__ == "__main__":
    # Example linked list: 7 -> 14 -> 21 -> 28
    head = Node(7)
    head.next = Node(14)
    head.next.next = Node(21)
    head.next.next.next = Node(28)

    # Assigning random pointers
    head.random = head.next.next
    head.next.random = head
    head.next.next.random = head.next.next.next
    head.next.next.next.random = head.next

    print("Original Linked List with Random Pointers:")
    printClonedLinkedList(head)

    # Clone the linked list
    clonedList = cloneLL(head)

    print("\nCloned Linked List with Random Pointers:")
    printClonedLinkedList(clonedList)





# endregion

â­â­â­there are more questions in youtube apart from these 




# region 7.1 RECURSION - BASIC
# ----------------------------

# 1 TODO :  recursive implementation of atoi()
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

- The atoi() function converts a string (which may represent a number) into an integer. 

https://leetcode.com/problems/string-to-integer-atoi/




'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
'''
Time Complexity (TC): The recursive approach processes each character exactly once, so the time complexity is O(n), where n is the length of the string s.

Space Complexity (SC): The space complexity is primarily due to the recursion stack. In the worst case (no recursion optimizations like tail call elimination), the depth of recursion is O(n), where n is the length of the string s. Therefore, the space complexity is O(n).

'''
def atoi_helper(s, index, result):
    # Base case: when all characters have been processed
    if index == len(s):
        return result
    
    # Handle negative numbers
    if s[index] == '-':
        return -atoi_helper(s, index + 1, result)  # handle negative recursively
    
    # Handle digit characters (convert them to integers)
    if '0' <= s[index] <= '9':
        digit = ord(s[index]) - ord('0')  # Convert character to integer
        result = result * 10 + digit      # Build the result recursively
    
    # Recursive call for the next character
    return atoi_helper(s, index + 1, result)

def atoi(s):
    # Remove leading spaces
    s = s.strip()
    
    # Edge case for empty string
    if not s:
        return 0
    
    # Start recursive helper from the first character with initial result as 0
    return atoi_helper(s, 0, 0)

# Example usage:
print(atoi("123"))          # Output: 123
print(atoi("-123"))         # Output: -123
print(atoi("  456  "))      # Output: 456
print(atoi("abc"))          # Output: 0 (invalid input)


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : pow(x,n)
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/implement-powxn-x-raised-to-the-power-n/


https://leetcode.com/problems/powx-n/



'''
# method 1 : brute force approch
Time Complexity: O(N)

Space Complexity: O(1)

def myPow(x: float, n: int) -> float:
    ans = 1.0
    for i in range(n):
        ans = ans * x
    return ans

if __name__ == "__main__":
    print(myPow(2, 10))


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(log n)

Space Complexity: O(1)
'''
def myPow(x: float, n: int) -> float:
    ans = 1.0
    nn = n
    if nn < 0:
        nn = -1 * nn
    while nn:
        if nn % 2:
            ans = ans * x
            nn = nn - 1
        else:
            x = x * x
            nn = nn // 2
    if n < 0:
        ans = 1.0 / ans
    return ans

if __name__ == "__main__":
    print(myPow(2, 10))


# 3 TODO : count good numbers
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

- A Good Number is defined based on certain criteria. For this example, let's assume a Good Number is one where all of its digits are in the set {2, 3, 5, 7} (primes) and the number itself is greater than zero.

https://leetcode.com/problems/count-good-numbers/

'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
'''
Time Complexity (TC):

The recursive function explores all possible combinations of digits {2, 3, 5, 7} to form valid numbers. In the worst case, it will explore 4^d numbers, where d is the number of digits in the largest number n. Therefore, the time complexity is O(4^d), where d is the number of digits in n.
Space Complexity (SC):

The space complexity is mainly due to the recursion stack. In the worst case, the depth of recursion will be d (number of digits), so the space complexity is O(d).

'''
def is_good_number(num, n):
    # If the current number exceeds n, return 0 (no good number)
    if num > n:
        return 0
    
    # Base case: if we reach a valid good number, count it
    if num != 0:
        count = 1
    else:
        count = 0
    
    # Recursive case: For each valid digit, try constructing the next number
    good_digits = [2, 3, 5, 7]
    for digit in good_digits:
        # Form the next number and recursively count good numbers
        count += is_good_number(num * 10 + digit, n)
    
    return count

def count_good_numbers(n):
    # Start counting from an empty number (0)
    return is_good_number(0, n)

# Example usage:
n = 100
result = count_good_numbers(n)
print(f"Number of Good Numbers from 1 to {n}: {result}")


# method 3 : optimal solution
# TC     -      
# SC     -      


# 4 TODO : sort a stack using recursion
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://bit.ly/3Pu0YBn




'''
# method 1 : brute force approch
'''
Time Complexity (TC):

Each recursive call to sort_stack processes one element from the stack.
The insert_sorted function takes linear time in the worst case (it might have to pop all elements in the stack before inserting the element).
Therefore, the overall time complexity is O(n^2), where n is the number of elements in the stack.
Space Complexity (SC):

The space complexity is mainly due to the recursion stack, which in the worst case will be O(n), where n is the number of elements in the stack.


'''   
def insert_sorted(stack, element):
    # Base case: If stack is empty or the element is greater than the top element
    if not stack or stack[-1] <= element:
        stack.append(element)
        return
    
    # Pop the top element and recursively insert the element
    temp = stack.pop()
    insert_sorted(stack, element)
    
    # Push the popped element back to the stack
    stack.append(temp)

def sort_stack(stack):
    # Base case: If the stack is empty, return
    if not stack:
        return
    
    # Pop the top element
    element = stack.pop()
    
    # Recursively sort the remaining stack
    sort_stack(stack)
    
    # Insert the popped element into the sorted stack
    insert_sorted(stack, element)

# Example usage
stack = [5, 3, 8, 1, 2]
print("Original stack:", stack)

# Sorting the stack
sort_stack(stack)

print("Sorted stack:", stack)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 5 TODO : reverse a stack using recursion
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://bit.ly/3podAiY



'''
# method 1 : brute force approch
'''
Time Complexity (TC):

The reverse_stack function processes each element once (i.e., pops an element and then calls the recursive function).
The insert_at_bottom function, in the worst case, needs to traverse the entire stack to insert the element at the bottom, which also takes linear time.
Therefore, the overall time complexity is O(n^2), where n is the number of elements in the stack. This is because for each element, the insert_at_bottom function may traverse the entire stack.

Space Complexity (SC):

The space complexity is primarily due to the recursion stack, which in the worst case is O(n), where n is the number of elements in the stack.
'''
def insert_at_bottom(stack, element):
    # Base case: If the stack is empty, push the element to the stack
    if not stack:
        stack.append(element)
        return
    
    # Pop the top element
    temp = stack.pop()
    
    # Recursively insert the element at the bottom
    insert_at_bottom(stack, element)
    
    # Push the popped element back to the stack
    stack.append(temp)

def reverse_stack(stack):
    # Base case: If the stack is empty, return
    if not stack:
        return
    
    # Pop the top element
    element = stack.pop()
    
    # Recursively reverse the remaining stack
    reverse_stack(stack)
    
    # Insert the popped element at the bottom of the stack
    insert_at_bottom(stack, element)

# Example usage
stack = [1, 2, 3, 4, 5]
print("Original stack:", stack)

# Reversing the stack
reverse_stack(stack)

print("Reversed stack:", stack)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      



# endregion






# region 7.2 RECURSION - PATTERN
# ------------------------------

# 1 TODO :  generate all binary strings
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://bit.ly/3QJ0vwc


'''
# method 1 : brute force approch
'''
Time Complexity (TC):

The function generates all possible binary strings of length n. There are 2^n possible binary strings, as each position in the string can either be '0' or '1'.
Therefore, the time complexity is O(2^n), where n is the length of the binary strings.
Space Complexity (SC):

The recursion depth will be n (the length of the string being built), so the space complexity is O(n) due to the recursion stack.
Additionally, the space required to store the generated strings in memory is O(2^n) (as there are 2^n binary strings and each has a length of n).

'''
def generate_binary_strings(n, current=""):
    # Base case: If the current string reaches the length n, print it
    if len(current) == n:
        print(current)
        return
    
    # Recursive case: Append '0' or '1' and call the function recursively
    generate_binary_strings(n, current + "0")
    generate_binary_strings(n, current + "1")

# Example usage:
n = 3
print(f"All binary strings of length {n} are:")
generate_binary_strings(n)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : generate paranthesis
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/generate-parentheses/



'''
# method 1 : brute force approch
'''
Time Complexity (TC):

The total number of valid parentheses combinations is given by the n-th Catalan number: C(n) = (2n)! / (n! * (n+1)!). This grows exponentially with n.
Therefore, the time complexity is O(C(n)), where C(n) is the n-th Catalan number.
Space Complexity (SC):

The recursion depth is at most 2n (because we are adding one character at a time to the string), so the space complexity is O(n) due to the recursion stack.

'''
def generate_parentheses(n, open_count=0, close_count=0, current=""):
    # Base case: If the current string has used n pairs of parentheses
    if open_count == n and close_count == n:
        print(current)
        return
    
    # Recursive case: Add an opening parenthesis if we have not yet used n opening ones
    if open_count < n:
        generate_parentheses(n, open_count + 1, close_count, current + "(")
    
    # Recursive case: Add a closing parenthesis if we have opened more parentheses than closed
    if close_count < open_count:
        generate_parentheses(n, open_count, close_count + 1, current + ")")

# Example usage:
n = 3
print(f"All valid parentheses combinations of length {n} are:")
generate_parentheses(n)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 3 TODO : print all subsequences / power set
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡




https://takeuforward.org/data-structure/power-set-print-all-the-possible-subsequences-of-the-string/


https://leetcode.com/problems/subsets/



'''
# method 1 : brute force approch
'''end=
Time Complexity (TC):

The number of subsequences of a string of length n is 2^n (because for each character, we have two choices: include or exclude it).
Therefore, the time complexity is O(2^n).
Space Complexity (SC):

The recursion depth will be at most n, as we are processing one element at a time, so the space complexity is O(n) for the recursion stack.
The additional space used by the current string at any moment is also O(n) (in the worst case), but this is part of the recursion state.


'''
def print_subsequences(s, index=0, current=""):
    # Base case: If we've reached the end of the string/list, print the current subsequence
    if index == len(s):
        print(current)
        return
    
    # Recursive case 1: Include the current element in the subsequence
    print_subsequences(s, index + 1, current + s[index])
    
    # Recursive case 2: Exclude the current element from the subsequence
    print_subsequences(s, index + 1, current)

# Example usage
input_string = "abc"
print(f"All subsequences of '{input_string}' are:")
print_subsequences(input_string)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 4 TODO : learn all patterns of subsequences (theory)
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://bit.ly/3US225G




'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 5 TODO : count all subsequences with sum K
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://bit.ly/3SVf1me


'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 6 TODO : check if there exists a subsequences with sum K
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://www.codingninjas.com/studio/problems/subset-sum_630213?utm_source=striver&utm_medium=website&utm_campaign=a_zcoursetuf





'''
# method 1 : brute force approch
'''
Time Complexity (TC):

There are 2^n subsequences of an array of size n because for each element, we have two choices: include or exclude.
The recursive function explores all possible subsequences, so the time complexity is O(2^n).
Space Complexity (SC):

The space complexity is determined by the recursion depth, which is at most n (because we are processing one element at a time).
Therefore, the space complexity is O(n) due to the recursion stack.
'''
def count_subsequences_with_sum(arr, n, target_sum, current_sum=0, index=0):
    # Base case: If we've processed all elements
    if index == n:
        # If the current sum is equal to the target sum, it's a valid subsequence
        if current_sum == target_sum:
            return 1
        return 0
    
    # Recursive case 1: Include the current element
    include = count_subsequences_with_sum(arr, n, target_sum, current_sum + arr[index], index + 1)
    
    # Recursive case 2: Exclude the current element
    exclude = count_subsequences_with_sum(arr, n, target_sum, current_sum, index + 1)
    
    # Return the total count of valid subsequences
    return include + exclude

# Example usage:
arr = [1, 2, 3]
target_sum = 3
n = len(arr)
print(f"Number of subsequences with sum {target_sum}: {count_subsequences_with_sum(arr, n, target_sum)}")


# method 2 : better approch
'''end=
Time Complexity with Memoization: The time complexity is reduced to O(n * target_sum) because we are memoizing the results for each combination of index and current_sum.
Space Complexity with Memoization: The space complexity is O(n * target_sum) due to the memoization table.

'''
def count_subsequences_with_sum_memo(arr, n, target_sum, current_sum=0, index=0, memo={}):
    # Base case: If we've processed all elements
    if index == n:
        # If the current sum is equal to the target sum, it's a valid subsequence
        return 1 if current_sum == target_sum else 0
    
    # Check if the result is already computed
    if (index, current_sum) in memo:
        return memo[(index, current_sum)]
    
    # Recursive case 1: Include the current element
    include = count_subsequences_with_sum_memo(arr, n, target_sum, current_sum + arr[index], index + 1, memo)
    
    # Recursive case 2: Exclude the current element
    exclude = count_subsequences_with_sum_memo(arr, n, target_sum, current_sum, index + 1, memo)
    
    # Store the result in the memoization table
    memo[(index, current_sum)] = include + exclude
    
    return memo[(index, current_sum)]

# Example usage with memoization
arr = [1, 2, 3]
target_sum = 3
n = len(arr)
print(f"Number of subsequences with sum {target_sum}: {count_subsequences_with_sum_memo(arr, n, target_sum)}")


# method 3 : optimal solution
# TC     -      
# SC     -      


# 7 TODO : combination sum - I
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/combination-sum-1/


https://leetcode.com/problems/combination-sum/




'''
# method 1 : brute force approch
'''
Time Complexity: O(2^t * k) where t is the target, k is the average length

Reason: Assume if you were not allowed to pick a single element multiple times, every element will have a couple of options: pick or not pick which is 2^n different recursion calls, also assuming that the average length of every combination generated is k. (to put length k data structure into another data structure)

Why not (2^n) but (2^t) (where n is the size of an array)?

Assume that there is 1 and the target you want to reach is 10 so 10 times you can â€œpick or not pickâ€ an element.

Space Complexity: O(k*x), k is the average length and x is the no. of combinations
'''
from typing import List




class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        ans = []
        ds = []


        def findCombination(ind: int, target: int):
            if ind == len(candidates):
                if target == 0:
                    ans.append(ds[:])
                return
            if candidates[ind] <= target:
                ds.append(candidates[ind])
                findCombination(ind, target - candidates[ind])
                ds.pop()
            findCombination(ind + 1, target)
        findCombination(0, target)
        return ans




if __name__ == "__main__":
    obj = Solution()
    candidates = [2, 3, 6, 7]
    target = 7
    ans = obj.combinationSum(candidates, target)
    print("Combinations are: ")
    for i in range(len(ans)):
        for j in range(len(ans[i])):
            print(ans[i][j], end=" ")
        print()


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 8 TODO : combination sum - II
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡




https://takeuforward.org/data-structure/combination-sum-ii-find-all-unique-combinations/


https://leetcode.com/problems/combination-sum-ii/




'''
# method 1 : brute force approch
'''
Time Complexity:O(2^n*k)

Reason: Assume if all the elements in the array are unique then the no. of subsequence you will get will be O(2^n). we also add the ds to our ans when we reach the base case that will take â€œkâ€//average space for the ds.

Space Complexity:O(k*x)

Reason: if we have x combinations then space will be x*k where k is the average length of the combination.
'''
from typing import List




def combinationSum2(candidates: List[int], target: int) -> List[List[int]]:
    ans = []
    ds = []
    candidates.sort()


    def findCombination(ind: int, target: int):
        if target == 0:
            ans.append(ds[:])
            return
        for i in range(ind, len(candidates)):
            if i > ind and candidates[i] == candidates[i - 1]:
                continue
            if candidates[i] > target:
                break
            ds.append(candidates[i])
            findCombination(i + 1, target - candidates[i])
            ds.pop()


    findCombination(0, target)
    return ans




if __name__ == "__main__":
    v = [10, 1, 2, 7, 6, 1, 5]
    comb = combinationSum2(v, 8)
    print(*comb)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 9 TODO : subset sum - I
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/subset-sum-sum-of-all-subsets/


https://bit.ly/3C9GQRS




'''
# method 1 : brute force approch
'''
Time Complexity: O(2^n)+O(2^n log(2^n)). Each index has two ways. You can either pick it up or not pick it. So for n index time complexity for O(2^n) and for sorting it will take (2^n log(2^n)).

Space Complexity: O(2^n) for storing subset sums, since 2^n subsets can be generated for an array of size n.
'''
from typing import List




class Solution:
    def subsetSums(self, arr: List[int], n: int) -> List[int]:
        ans = []


        def subsetSumsHelper(ind: int, sum: int):
            if ind == n:
                ans.append(sum)
                return
            # element is picked
            subsetSumsHelper(ind + 1, sum + arr[ind])
            # element is not picked
            subsetSumsHelper(ind + 1, sum)
        subsetSumsHelper(0, 0)
        ans.sort()
        return ans




if __name__ == "__main__":
    arr = [3, 1, 2]
    ans = Solution().subsetSums(arr, len(arr))
    print("The sum of each subset is")
    for sum in ans:
        print(sum, end=" ")
    print()


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 10 TODO :  subset sum - II
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/subset-ii-print-all-the-unique-subsets/


https://leetcode.com/problems/subsets-ii/

'''
# method 1 : brute force approch
'''
Time Complexity: O( 2^n *(k log (x) )). 2^n  for generating every subset and k* log( x)  to insert every combination of average length k in a set of size x. After this, we have to convert the set of combinations back into a list of list /vector of vectors which takes more time.

Space Complexity:  O(2^n * k) to store every subset of average length k. Since we are initially using a set to store the answer another O(2^n *k) is also used.
'''

from typing import List




class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        ans = []
        res = set()


        def fun(index: int, ds: List[int]):
            if index == len(nums):
                ds.sort()
                res.add(tuple(ds))
                return
            ds.append(nums[index])
            fun(index + 1, ds)
            ds.pop()
            fun(index + 1, ds)
        fun(0, [])
        for it in res:
            ans.append(list(it))
        return ans




if __name__ == "__main__":
    nums = [1, 2, 2]
    obj = Solution()
    ans = obj.subsetsWithDup(nums)
    print("The unique subsets are ")
    print("[ ", end="")
    for i in range(len(ans)):
        print("[ ", end="")
        for j in range(len(ans[i])):
            print(ans[i][j], end=" ")
        print("]", end="")  


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(2^n) for generating every subset and O(k)  to insert every subset in another data structure if the average length of every subset is k. Overall O(k * 2^n).

Space Complexity: O(2^n * k) to store every subset of average length k. Auxiliary space is O(n)  if n is the depth of the recursion tree.
'''

from typing import List




class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        ans = []
        ds = []


        def findSubsets(ind: int):
            ans.append(ds[:])
            for i in range(ind, len(nums)):
                if i != ind and nums[i] == nums[i - 1]:
                    continue
                ds.append(nums[i])
                findSubsets(i + 1)
                ds.pop()
        nums.sort()
        findSubsets(0)
        return ans




if __name__ == "__main__":
    nums = [1, 2, 2]
    obj = Solution()
    ans = obj.subsetsWithDup(nums)
    print("The unique subsets are ")
    print(*ans)   


# 11 TODO : combination sum  - III
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://leetcode.com/problems/combination-sum-iii/



'''
# method 1 : brute force approch
'''end=
Time Complexity: The time complexity of the backtracking approach is O(2^n), where n is the number of possible numbers (in this case, 9). This is because at each step, we have two choices: include or exclude the number. However, the recursion depth is bounded by k and pruning conditions limit the exploration.

Space Complexity: The space complexity is O(k), as we maintain a current_combination of size k at each recursive level, and the recursion stack also uses space proportional to k.


'''
def combinationSum3(k, n):
    result = []

    def backtrack(start, k, n, current_combination):
        # Base case: if we have k numbers in the current combination and sum equals n
        if k == 0 and n == 0:
            result.append(list(current_combination))
            return
        
        # If we have used k numbers or the sum exceeds n, no need to proceed further
        if k == 0 or n <= 0:
            return
        
        # Start from the current number and go up to 9
        for i in range(start, 10):
            current_combination.append(i)  # Include i
            backtrack(i + 1, k - 1, n - i, current_combination)  # Recur with reduced k and n
            current_combination.pop()  # Backtrack, remove i
    
    backtrack(1, k, n, [])
    return result

# Example usage:
k = 3
n = 7
print(combinationSum3(k, n))  # Output: [[1, 2, 4]]


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 12 TODO : letter combination of phone number
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/letter-combinations-of-a-phone-number/


'''
# method 1 : brute force approch
'''end=
Time Complexity: The time complexity is O(4^n), where n is the number of digits in the input string. In the worst case (if all digits are 7 or 9), each digit can have up to 4 possible letters, so we have 4^n possible combinations to explore.
Space Complexity: The space complexity is O(n) for the recursion stack and the current_combination list that stores the current combination of letters. Additionally, the result list stores all possible combinations, which can be up to 4^n combinations.

'''
def letterCombinations(digits):
    # Mapping digits to corresponding letters
    phone_map = {
        '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',
        '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'
    }
    
    # Helper function to perform backtracking
    def backtrack(index, current_combination):
        # If the current combination is of the same length as the digits, add it to the result
        if index == len(digits):
            result.append(''.join(current_combination))
            return
        
        # Get the current digit's possible letters
        current_digit = digits[index]
        letters = phone_map[current_digit]
        
        # Try each letter and recurse
        for letter in letters:
            current_combination.append(letter)
            backtrack(index + 1, current_combination)  # Recurse to next digit
            current_combination.pop()  # Backtrack (remove the last added letter)

    # If digits is an empty string, return an empty list
    if not digits:
        return []
    
    result = []
    backtrack(0, [])
    return result

# Example usage:
digits = "23"
print(letterCombinations(digits))  # Output: ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# endregion






# region 7.3 RECUSION - HARD
# --------------------------

# 1 TODO :  pallindrome partitioning
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/palindrome-partitioning/


https://leetcode.com/problems/palindrome-partitioning/



'''
# method 1 : brute force approch
'''
Time Complexity: O( (2^n) *k*(n/2) )

Reason: O(2^n) to generate every substring and O(n/2)  to check if the substring generated is a palindrome. O(k) is for inserting the palindromes in another data structure, where k  is the average length of the palindrome list.

Space Complexity: O(k * x)

Reason: The space complexity can vary depending on the length of the answer. k is the average length of the list of palindromes and if we have x such list of palindromes in our final answer. The depth of the recursion tree is n, so the auxiliary space required is equal to the O(n).
'''
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        res = []
        path = []


        def partitionHelper(index: int):
            if index == len(s):
                res.append(path[:])
                return
            for i in range(index, len(s)):
                if isPalindrome(s, index, i):
                    path.append(s[index:i + 1])
                    partitionHelper(i + 1)
                    path.pop()


        def isPalindrome(s: str, start: int, end: int) -> bool:
            while start <= end:
                if s[start] != s[end]:
                    return False
                start += 1
                end -= 1
            return True


        partitionHelper(0)
        return res




if __name__ == "__main__":
    s = "aabb"
    obj = Solution()
    ans = obj.partition(s)
    print("The Palindromic partitions are :-")
    print(" [ ", end="")
    for i in ans:
        print("[ ", end="")
        for j in i:
            print(j, end=" ")
        print("] ", end="")
    print("]")

# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : word search
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/word-search-leetcode/


https://leetcode.com/problems/word-search/



'''
# method 1 : brute force approch
'''end=
Time Complexity:
The time complexity of the solution is O(m * n * 4^k), where:
m is the number of rows in the board.
n is the number of columns in the board.
k is the length of the word.
In the worst case, we might explore all possible paths from each cell of the board, and at each level of recursion, we have 4 possible directions to explore.
Space Complexity:
The space complexity is O(k), where k is the length of the word, because the recursion stack stores the path for up to k recursive calls (each for one character in the word).


'''
def exist(board, word):
    # Helper function to perform DFS search
    def dfs(board, word, index, i, j):
        # If we have matched all characters in word, return True
        if index == len(word):
            return True
        
        # Check if the current cell is out of bounds or doesn't match the character
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[index]:
            return False
        
        # Mark the current cell as visited by replacing the character with a special character
        temp = board[i][j]
        board[i][j] = '#'

        # Explore all 4 possible directions: up, down, left, right
        result = (dfs(board, word, index + 1, i + 1, j) or  # Down
                  dfs(board, word, index + 1, i - 1, j) or  # Up
                  dfs(board, word, index + 1, i, j + 1) or  # Right
                  dfs(board, word, index + 1, i, j - 1))    # Left
        
        # Restore the cell value (backtrack)
        board[i][j] = temp
        
        return result
    
    # If the board is empty or the word is empty, return False
    if not board or not word:
        return False
    
    # Iterate through all cells of the board
    for i in range(len(board)):
        for j in range(len(board[0])):
            # Start DFS from each cell
            if board[i][j] == word[0] and dfs(board, word, 0, i, j):
                return True
    
    return False

# Example usage:
board = [
    ['A', 'B', 'C', 'E'],
    ['S', 'F', 'C', 'S'],
    ['A', 'D', 'E', 'E']
]
word = "ABCCED"
print(exist(board, word))  # Output: True

word = "SEE"
print(exist(board, word))  # Output: True

word = "ABCB"
print(exist(board, word))  # Output: False


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 3 TODO : N queen
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/data-structure/n-queen-problem-return-all-distinct-solutions-to-the-n-queens-puzzle/


https://leetcode.com/problems/n-queens/




'''
# method 1 : brute force approch
'''
Time Complexity: Exponential in nature since we are trying out all ways, to be precise its O(N! * N).

Space Complexity: O( N2 )
'''

class Solution:
    def isSafe1(self, row, col, board, n):
        # check upper element
        duprow = row
        dupcol = col


        while row >= 0 and col >= 0:
            if board[row][col] == 'Q':
                return False
            row -= 1
            col -= 1


        col = dupcol
        row = duprow
        while col >= 0:
            if board[row][col] == 'Q':
                return False
            col -= 1


        row = duprow
        col = dupcol
        while row < n and col >= 0:
            if board[row][col] == 'Q':
                return False
            row += 1
            col -= 1


        return True


    def solve(self, col, board, ans, n):
        if col == n:
            ans.append(list(board))
            return


        for row in range(n):
            if self.isSafe1(row, col, board, n):
                board[row] = board[row][:col] + 'Q' + board[row][col+1:]
                self.solve(col+1, board, ans, n)
                board[row] = board[row][:col] + '.' + board[row][col+1:]


    def solveNQueens(self, n):
        ans = []
        board = ['.'*n for _ in range(n)]
        self.solve(0, board, ans, n)
        return ans


n = 4
obj = Solution()
ans = obj.solveNQueens(n)
for i in range(len(ans)):
    print(f"Arrangement {i+1}")
    for j in range(len(ans[0])):
        print(ans[i][j])
    print()


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: Exponential in nature since we are trying out all ways, to be precise it is O(N! * N).

Space Complexity: O(N)
'''
from typing import List




class Solution:
    def solve(self, col, board, ans, leftrow, upperDiagonal, lowerDiagonal, n):
        if col == n:
            ans.append(board[:])
            return


        for row in range(n):
            if leftrow[row] == 0 and lowerDiagonal[row+col] == 0 and upperDiagonal[n-1+col-row] == 0:
                board[row] = board[row][:col] + 'Q' + board[row][col+1:]
                leftrow[row] = 1
                lowerDiagonal[row+col] = 1
                upperDiagonal[n-1+col-row] = 1
                self.solve(col+1, board, ans, leftrow,
                           upperDiagonal, lowerDiagonal, n)
                board[row] = board[row][:col] + '.' + board[row][col+1:]
                leftrow[row] = 0
                lowerDiagonal[row+col] = 0
                upperDiagonal[n-1+col-row] = 0


    def solveNQueens(self, n: int) -> List[List[str]]:
        ans = []
        board = ['.'*n for _ in range(n)]
        leftrow = [0]*n
        upperDiagonal = [0]*(2*n-1)
        lowerDiagonal = [0]*(2*n-1)
        self.solve(0, board, ans, leftrow, upperDiagonal, lowerDiagonal, n)
        return ans




if __name__ == '__main__':
    n = 4
    obj = Solution()
    ans = obj.solveNQueens(n)
    for i in range(len(ans)):
        print("Arrangement", i+1)
        for j in range(len(ans[0])):
            print(ans[i][j])
            print()


# 4 TODO : rent a maze
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/data-structure/rat-in-a-maze/


https://practice.geeksforgeeks.org/problems/rat-in-a-maze-problem/1



'''
# method 1 : brute force approch
'''
Time Complexity: O(4^(m*n)), because on every cell we need to try 4 different directions.

Space Complexity:  O(m*n), Maximum Depth of the recursion tree(auxiliary space).
'''

from typing import List




class Solution:


    def findPathHelper(self, i: int, j: int, a: List[List[int]], n: int, ans: List[str], move: str, vis: List[List[int]]):
        if i == n - 1 and j == n - 1:
            ans.append(move)
            return


        # downward
        if i + 1 < n and not vis[i + 1][j] and a[i + 1][j] == 1:
            vis[i][j] = 1
            self.findPathHelper(i + 1, j, a, n, ans, move + 'D', vis)
            vis[i][j] = 0


        # left
        if j - 1 >= 0 and not vis[i][j - 1] and a[i][j - 1] == 1:
            vis[i][j] = 1
            self.findPathHelper(i, j - 1, a, n, ans, move + 'L', vis)
            vis[i][j] = 0


        # right
        if j + 1 < n and not vis[i][j + 1] and a[i][j + 1] == 1:
            vis[i][j] = 1
            self.findPathHelper(i, j + 1, a, n, ans, move + 'R', vis)
            vis[i][j] = 0


        # upward
        if i - 1 >= 0 and not vis[i - 1][j] and a[i - 1][j] == 1:
            vis[i][j] = 1
            self.findPathHelper(i - 1, j, a, n, ans, move + 'U', vis)
            vis[i][j] = 0


    def findPath(self, m: List[List[int]], n: int) -> List[str]:
        ans = []
        vis = [[0 for _ in range(n)] for _ in range(n)]


        if m[0][0] == 1:
            self.findPathHelper(0, 0, m, n, ans, "", vis)
        return ans




if __name__ == '__main__':
    n = 4


    m = [[1, 0, 0, 0], [1, 1, 0, 1], [1, 1, 0, 0], [0, 1, 1, 1]]


    obj = Solution()
    result = obj.findPath(m, n)
    if len(result) == 0:
        print(-1)
    else:
        for i in range(len(result)):
            print(result[i], end=" ")
    print() 


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(4^(m*n)), because on every cell we need to try 4 different directions.

Space Complexity:  O(m*n), Maximum Depth of the recursion tree(auxiliary space).
'''

from typing import List



class Solution:


    def solve(self, i: int, j: int, a: List[List[int]], n: int, ans: List[str], move: str, vis: List[List[int]], di: List[int], dj: List[int]):
        if i == n - 1 and j == n - 1:
            ans.append(move)
            return
        dir = "DLRU"
        for ind in range(4):
            nexti = i + di[ind]
            nextj = j + dj[ind]
            if nexti >= 0 and nextj >= 0 and nexti < n and nextj < n and not vis[nexti][nextj] and a[nexti][nextj] == 1:
                vis[i][j] = 1
                self.solve(nexti, nextj, a, n, ans,
                           move + dir[ind], vis, di, dj)
                vis[i][j] = 0


    def findPath(self, m: List[List[int]], n: int) -> List[str]:
        ans = []
        vis = [[0 for _ in range(n)] for _ in range(n)]
        di = [+1, 0, 0, -1]
        dj = [0, -1, 1, 0]
        if m[0][0] == 1:
            self.solve(0, 0, m, n, ans, "", vis, di, dj)
        return ans




if __name__ == "__main__":
    n = 4
    m = [[1, 0, 0, 0], [1, 1, 0, 1], [1, 1, 0, 0], [0, 1, 1, 1]]
    obj = Solution()
    result = obj.findPath(m, n)
    if len(result) == 0:
        print(-1)
    else:
        for i in range(len(result)):
            print(result[i], end=" ")
    print()   


# 5 TODO : word break
'''
https://leetcode.com/problems/word-break/





'''
# method 1 : brute force approch
'''end=
Time Complexity:

In the worst case, we are checking every substring of s, and for each substring, we check if it is in the dictionary. So the time complexity is O(n^2), where n is the length of the string s.
Memoization reduces the number of repeated calculations, ensuring that each substring of s is only processed once.
Space Complexity:

The space complexity is O(n) because of the memoization dictionary, where we store the results for all substrings starting at indices 0 to n-1.
The recursion stack can also go as deep as O(n) in the worst case.

'''
def wordBreak(s, wordDict):
    # Convert the wordDict to a set for faster lookup
    word_set = set(wordDict)
    
    # Memoization dictionary to store results of subproblems
    memo = {}
    
    def canBreak(start):
        # If we reach the end of the string, we have successfully segmented the string
        if start == len(s):
            return True
        
        # If the result for this substring is already computed, return it
        if start in memo:
            return memo[start]
        
        # Try every possible substring starting at index `start`
        for end in range(start + 1, len(s) + 1):
            # Check if the substring s[start:end] is in the word set
            if s[start:end] in word_set:
                # Recursively check the remaining part of the string
                if canBreak(end):
                    memo[start] = True  # Memoize the result
                    return True
        
        # If no valid segmentation is found, memoize and return False
        memo[start] = False
        return False
    
    # Start the recursion from index 0
    return canBreak(0)

# Example usage:
s = "leetcode"
wordDict = ["leet", "code"]
print(wordBreak(s, wordDict))  # Output: True

s = "applepenapple"
wordDict = ["apple", "pen"]
print(wordBreak(s, wordDict))  # Output: True

s = "catsandog"
wordDict = ["cats", "dog", "sand", "and", "cat"]
print(wordBreak(s, wordDict))  # Output: False


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 6 TODO : M coloring problem
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/m-coloring-problem/


https://practice.geeksforgeeks.org/problems/m-coloring-problem-1587115620/1#


'''
# method 1 : brute force approch
'''
Time Complexity: O( N^M) (n raised to m)

Space Complexity: O(N)
'''
def isSafe(node, color, graph, n, col):
    for k in range(n):
        if k != node and graph[k][node] == 1 and color[k] == col:
            return False
    return True




def solve(node, color, m, N, graph):
    if node == N:
        return True


    for i in range(1, m + 1):
        if isSafe(node, color, graph, N, i):
            color[node] = i
            if solve(node + 1, color, m, N, graph):
                return True
            color[node] = 0


    return False


# Function to determine if graph can be coloured with at most M colours such
# that no two adjacent vertices of graph are coloured with same colour.




def graphColoring(graph, m, N):
    color = [0] * N
    if solve(0, color, m, N, graph):
        return True
    return False




if __name__ == '__main__':
    N = 4
    m = 3


    graph = [[0 for i in range(101)] for j in range(101)]


    # Edges are (0, 1), (1, 2), (2, 3), (3, 0), (0, 2)
    graph[0][1] = 1
    graph[1][0] = 1
    graph[1][2] = 1
    graph[2][1] = 1
    graph[2][3] = 1
    graph[3][2] = 1
    graph[3][0] = 1
    graph[0][3] = 1
    graph[0][2] = 1
    graph[2][0] = 1


    print(1 if graphColoring(graph, m, N) else 0)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 7 TODO : sudoko solver
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/sudoku-solver/



https://leetcode.com/problems/sudoku-solver/




'''
# method 1 : brute force approch
'''
Time Complexity: O(9(n ^ 2)), in the worst case, for each cell in the n2 board, we have 9 possible numbers.

Space Complexity: O(1), since we are refilling the given board itself, there is no extra space required, so constant space complexity.
'''
from typing import List




def isValid(board: List[List[str]], row: int, col: int, c: str) -> bool:
    for i in range(9):
        if board[i][col] == c:
            return False
        if board[row][i] == c:
            return False
        if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == c:
            return False
    return True




def solveSudoku(board: List[List[str]]) -> bool:
    for i in range(len(board)):
        for j in range(len(board[0])):
            if board[i][j] == ".":
                for c in "123456789":
                    if isValid(board, i, j, c):
                        board[i][j] = c
                        if solveSudoku(board):
                            return True
                        else:
                            board[i][j] = "."
                return False
    return True




if __name__ == "__main__":
    board = [
        ["9", "5", "7", ".", "1", "3", ".", "8", "4"],
        ["4", "8", "3", ".", "5", "7", "1", ".", "6"],
        [".", "1", "2", ".", "4", "9", "5", "3", "7"],
        ["1", "7", ".", "3", ".", "4", "9", ".", "2"],
        ["5", ".", "4", "9", "7", ".", "3", "6", "."],
        ["3", ".", "9", "5", ".", "8", "7", ".", "1"],
        ["8", "4", "5", "7", "9", ".", "6", "1", "3"],
        [".", "9", "1", ".", "3", "6", ".", "7", "5"],
        ["7", ".", "6", "1", "8", "5", "4", ".", "9"],
    ]
    solveSudoku(board)
    for i in range(9):
        for j in range(9):
            print(board[i][j], end=" ")
        print()  


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 8 TODO : expression add operators
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://leetcode.com/problems/expression-add-operators/




'''
# method 1 : brute force approch
'''end=
Time Complexity:
The time complexity is O(3^n) where n is the length of the string num. This is because at each position, we have 3 choices (to add +, -, or *), and the recursion explores all possible combinations of these choices.
In the worst case, there are approximately O(3^n) different expressions we need to check.
Space Complexity:
The space complexity is O(n) due to the recursion stack and the space used by the result list to store valid expressions. Each recursive call consumes space in the stack, and in the worst case, we may store up to O(n) expressions.

'''
def addOperators(num, target):
    # Result list to store valid expressions
    result = []
    
    # Helper function for backtracking
    def backtrack(index, prev_operand, current_operand, value, expression):
        # If we have reached the end of the string, check if the value equals target
        if index == len(num):
            if value == target:
                result.append(expression)
            return
        
        # Start from the current index and try all possible numbers
        for i in range(index + 1, len(num) + 1):
            # Avoid numbers with leading zeros
            if i > index + 1 and num[index] == '0':
                break
            
            # Get the current number from the substring
            current_num = int(num[index:i])
            current_str = num[index:i]
            
            # Recursively call backtrack for the next operator with the current number
            if index == 0:
                # For the first number, there is no operator before it
                backtrack(i, current_num, 0, current_num, current_str)
            else:
                # Add '+' operator
                backtrack(i, current_num, 0, value + current_num, expression + "+" + current_str)
                # Add '-' operator
                backtrack(i, -current_num, 0, value - current_num, expression + "-" + current_str)
                # Add '*' operator
                backtrack(i, prev_operand * current_num, current_num, value - prev_operand + (prev_operand * current_num), expression + "*" + current_str)
    
    # Call the backtrack function from the start of the string
    backtrack(0, 0, 0, 0, "")
    
    return result

# Example usage:
num = "232"
target = 8
print(addOperators(num, target))  # Output: ["2*3+2", "2+3*2"]

num = "105"
target = 5
print(addOperators(num, target))  # Output: ["1*0+5", "10-5"]

num = "00"
target = 0
print(addOperators(num, target))  # Output: ["0+0", "0-0", "0*0"]


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# endregion







# region 8.1 BIT MANIPULATION - BASIC
# -----------------------------------
'''
https://www.youtube.com/watch?v=qQd-ViW7bfk&list=PLgUwDviBIf0rnqh8QsJaHyIX7KUiaPUv7&index=1 

ğŸ‘‰ binary to decimal, TC - log2(N), SC - log2(N)
def main_function(num):
  result = ""
  if num == 0:
    return "0"
  while num > 0:
    if num %2 == 1:
      result = result + str(1) 
    else:
      result = result + str(0)
    num = num // 2
  # reverse a string 
  result = result[::-1] 
  
  return result
print(main_function(3))


ğŸ‘‰ decimal to binary, TC - O(len), SC - O(1) 
def main_function(x):
  str_len = len(str(x))
  p2 = 1
  num = 0
  for i in range(str_len-1, -1, -1):
    print(i)
    if x[i] == '1':
      num = num + p2
    p2 = p2 * 2
  return num
print(main_function("1101"))

ğŸ‘‰ 1's complement, first convert to binary then flip the numbers
13 -> (0010)2


ğŸ‘‰ 2's complement, first 1's complement then add 1 to it
13 = (0011)2

'''



# 1 TODO :  introduction to bit manipulation
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://bit.ly/3Eo8JVW







'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : check if the i-th bit is set or not
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://practice.geeksforgeeks.org/problems/check-whether-k-th-bit-is-set-or-not-1587115620/1






'''
# method 1 : brute force approch, using left shift
# TC     -      O(1)
# SC     -     O(1)
def is_bit_set(num, i):
    # Create a mask by shifting 1 to the left by i positions
    mask = 1 << i
    # Use the AND operator to check if the i-th bit is set
    if num & mask:
        return True  # The i-th bit is set
    else:
        return False  # The i-th bit is not set

# Test cases
num = 5  # binary: 0101
i = 2    # checking the 2nd bit (counting from 0)
print(is_bit_set(num, i))  # Output: True, because the 2nd bit is set (0101)
i = 1
print(is_bit_set(num, i))  # Output: False, because the 1st bit is not set (0101)



# method 2 : better approch, using right shift
# TC     -      O(1)
# SC     -     O(1)
def is_bit_set(num, i):
    # Right shift num by i positions
    shifted_num = num >> i
    
    # Check if the least significant bit of shifted_num is set
    if shifted_num & 1:
        return True  # The i-th bit is set
    else:
        return False  # The i-th bit is not set

# Test cases
num = 5  # binary: 0101
i = 2    # checking the 2nd bit (counting from 0)

print(is_bit_set(num, i))  # Output: True, because the 2nd bit is set (0101)

i = 1
print(is_bit_set(num, i))  # Output: False, because the 1st bit is not set (0101)


# method 3 : optimal solution
# TC     -      
# SC     -      


# 3 TODO : check if a number is odd or not
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://practice.geeksforgeeks.org/problems/odd-or-even3618/1




'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 4 TODO : check if a number is power of 2 or not
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://leetcode.com/problems/power-of-two/



'''
# method 1 : brute force approch
# TC     -      
# SC     -   
def main_function(num):
  return (num & (num - 1)) == 0
  
num = 16
print(main_function(num))  
num = 13
print(main_function(num)) 
num = 32
print(main_function(num))   


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 5 TODO : count the number of set bits
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://practice.geeksforgeeks.org/problems/count-total-set-bits-1587115620/1


'''
# method 1 : brute force approch
# TC     -      
# SC     -   
def main_function(num):
  count = 0
  while num > 1:
    if num % 2 == 1:
      count += 1
    num = num // 2
  if num==1:
    count += 1
  return count
  
num = 16
print(main_function(num))  
num = 13
print(main_function(num)) 
num = 32
print(main_function(num))     


# method 2 : better approch
# TC     -      
# SC     -   
def main_function(num):
  count = 0
  while num > 1:
    count += num & 1
    num = num >> 1
  if num==1:
    count += 1
  return count
  
num = 16
print(main_function(num))  
num = 13
print(main_function(num)) 
num = 32
print(main_function(num))       


# method 3 : optimal solution
# TC     -     O(Nos of bits on) 
# SC     -     
def main_function(num):
  count = 0
  while num != 0:
    num = num & (num - 1)
    count += 1
  return count
  
num = 16
print(main_function(num))  
num = 13
print(main_function(num)) 
num = 32
print(main_function(num))   


# ğŸ‘‰ toggle the ith bit
def main_function(num, shift):
  return num ^ (1<< shift)
  
a = 13
shift = 2
print(main_function(a, shift))   

# ğŸ‘‰ remove the last set bit (rightmost)
def main_function(num):
  return num & (num - 1)
  
num = 16
print(main_function(num))  
num = 40
print(main_function(num)) 
num = 84
print(main_function(num)) 


# 6 TODO : set/unset the right ith bit
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://practice.geeksforgeeks.org/problems/set-the-rightmost-unset-bit4436/1





'''
# method 1 : brute force approch
# TC     -      
# SC     -  
def set_to_1(num, shift):
  return num | 1<< shift

def unset_to_1(num, shift):
  return num & ~(1<< shift)
  
a = 9
shift = 2
print(set_to_1(a, shift)) 
a = 13
shift = 2
print(unset_to_1(a, shift)) 




# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 7 TODO : swap two numbers
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://practice.geeksforgeeks.org/problems/swap-two-numbers3844/1




'''
# method 1 : brute force approch
# TC     -      
# SC     -   
def main_function(a,b):
  temp = a 
  a = b 
  b = temp 
  return a,b
  
a = 5
b = 6
print(main_function(a,b))  


# method 2 : better approch
'''
XORing a number with itself results in 0 (e.g., a ^ a = 0).
XORing a number with 0 gives the number back (e.g., a ^ 0 = a).
'''
# TC     -      
# SC     -  
def main_function(a, b):
  a = a ^ b  # Step 1: a becomes the XOR of a and b
  b = a ^ b  # Step 2: b becomes the original value of a
  a = a ^ b  # Step 3: a becomes the original value of b
  return a, b

a = 5
b = 6
print(main_function(a, b))  # Output: (6, 5)


# method 3 : optimal solution
# TC     -      
# SC     -      


# 8 TODO : divide two integers without using multiplication, division and mod operator

'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡




https://leetcode.com/problems/divide-two-integers/


'''
# method 1 : brute force approch
'''
https://www.youtube.com/watch?v=pBD4B1tzgVc&list=PLgUwDviBIf0rnqh8QsJaHyIX7KUiaPUv7&index=9
'''
# TC     -      
# SC     -     
def main_function(dividend, divisor):
  count = 0
  sum = 0
  while sum + divisor <= dividend:
    count +=1
    sum += divisor
  return count
  
dividend = 22
divisor = 3
print(main_function(dividend, divisor))  

# method 2 : better approch
# TC     -      
# SC     -     
'''def main_function(dividend, divisor):
  if dividend == 0:
    return 0
  if divisor == dividend:
    return 1 
  sign = True

  if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):
    sign = False
  dividend = abs(dividend)
  divisor = abs(divisor)
  while dividend >= divisor:
    count = 0
    ans = 0
    while dividend >= (divisor*2**count+1):
      count +=1 
    # ans = ans + 2**count
    ans = ans + 1<<count
    dividend = dividend - (dividend * (1<<count))
    if ans > 2**31 and sign == True:
      return "INT-MAX"
    if ans > 2**31 and sign == False:
      return "INT-MIN"
    return ans if sign else (-1*ans)
  
dividend = 22
divisor = 3
print(main_function(dividend, divisor))  
 '''

# method 3 : optimal solution
# TC     -      
# SC     -    
def main_function(dividend, divisor):
    # Edge case: if the dividend is 0, return 0
    if dividend == 0:
        return 0
    
    sign = True
    if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):
        sign = False  # result should be negative if only one of them is negative
    
    dividend = abs(dividend)
    divisor = abs(divisor)
    
    ans = 0
    count = 0
    
    while dividend >= divisor:
        count = 0
        while dividend >= (divisor << count):
            count += 1
        ans += (1 << (count - 1))  # add the appropriate power of 2 to the answer
        dividend -= (divisor << (count - 1))  # subtract the corresponding divisor multiple
        
    # INT_MAX is 2^31 - 1, INT_MIN is -2^31
    INT_MAX = 2**31 - 1
    INT_MIN = -2**31
    
    # If the answer exceeds 32-bit signed integer range, return the appropriate value
    if ans > INT_MAX:
        return INT_MAX if sign else INT_MIN
    
    return ans if sign else -ans

# Test case
dividend = 22
divisor = 3
print(main_function(dividend, divisor))  # Expected output: 7



# endregion







# region 8.2 BIT MANIPULATION - MEDIUM
# ------------------------------------

# 1 TODO :  count number of bits to be flipped to convert A to B
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/minimum-bit-flips-to-convert-number/


'''
# method 1 : brute force approch
https://www.youtube.com/watch?v=OOdrmcfZXd8&list=PLgUwDviBIf0rnqh8QsJaHyIX7KUiaPUv7&index=3
# TC     -      O(31) OR O()log2(start^goal)
# SC     -     O(1)
def main_function(start, goal):
  ans = start^goal
  count = 0 
  for i in range(0, 31):
    if ans & (1<<i):
      count += 1 
  return count
  
start = 10
goal = 7
print(main_function(start, goal)) 
start = 3
goal = 4
print(main_function(start, goal)) 
 

# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : find the number that appears odd number of times, single number - I
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://leetcode.com/problems/single-number/



'''
# method 1 : brute force approch
https://www.youtube.com/watch?v=sFBCAl8yBfE&list=PLgUwDviBIf0rnqh8QsJaHyIX7KUiaPUv7&index=5
# TC     -      O(N + logm) + m where m =(n/2)+1
# SC     -     O(m)
def main_function(arr):
  obj = {}
  for i in range(len(arr)):
    obj[arr[i]] = obj.get(i, 0) + 1 
  print(obj)
  for key, value in obj.items():
    if value==1:
      return key
  return -1
  
start = [4,1,2,1,2]
print(main_function(start)) 

# method 2 : better approch
# TC     -      
# SC     -  
def main_function(arr):
  xor = 0
  for i in range(len(arr)):
    xor = xor^arr[i]
  return xor
  
start = [4,1,2,1,2]
goal = 7
print(main_function(start))    


# method 3 : optimal solution
# TC     -      
# SC     - 
     
# ğŸ‘‰ single number - II
https://www.youtube.com/watch?v=5Bb2nqA40JY&list=PLgUwDviBIf0rnqh8QsJaHyIX7KUiaPUv7&index=6


# 3 TODO : power set (print all sub sets)
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/subsets/

https://www.youtube.com/watch?v=LqKaUv1G3_I&list=PLgUwDviBIf0rnqh8QsJaHyIX7KUiaPUv7&index=4


'''
# method 1 : brute force approch
# TC     -      O(N * 2^n)
# SC     -     O(2^n * N) near by 
def main_function(nums):
    ans = []
    n = len(nums)
    subsets = 1 << n  # 2^n, total number of subsets
    for i in range(subsets):
        subset = []
        for j in range(n):
            if (i & (1 << j)):  # check if the j-th bit is set in i
                subset.append(nums[j])
        ans.append(subset)
    
    return ans  # Return the list of subsets

arr = [1, 2, 3]
print(main_function(arr))



# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 4 TODO : find xor of numbers from left to right
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://bit.ly/3T8xUCf


'''
# method 1 : brute force approch
http://youtube.com/watch?v=WqGb7159h7Q&list=PLgUwDviBIf0rnqh8QsJaHyIX7KUiaPUv7&index=8
# TC     -     O(N) 
# SC     -    O(1) 
def main_function(nums):
    xor = 0 
    for i in range(nums+1):
      xor = xor^i
    
    return xor  # Return the list of subsets

arr = 4
print(main_function(arr))



# method 2 : better approch
'''
N % 4 == 1  -> 1
N % 4 == 2  -> N+1
N % 4 == 3  -> 0
N % 4 == 0  -> N
'''
# TC     -      O(1)
# SC     -    O(1) 
def main_function(N):
    if N % 4 == 1:
      return 1
    elif N % 4 == 2:
      return N+1
    elif N % 4 == 3:
      return 0
    else:
      return N
    
num = 4
print(main_function(num))


# method 3 : optimal solution
# TC     -      
# SC     -     

# ğŸ‘‰ find xor between two numbers, TC - O(1), SC - O(N)
def main_function(left, right):
  
  return utility(left-1)^utility(right)


def utility(N):
  if N % 4 == 1:
    return 1
  elif N % 4 == 2:
    return N+1
  elif N % 4 == 3:
    return 0
  else:
    return N
  
left = 4
right = 7
print(main_function(left, right))



# 5 TODO : find the two numbers appearing off number of times, single number - III, 
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://practice.geeksforgeeks.org/problems/two-numbers-with-odd-occurrences5846/1

'''
concept of buckets
XORing two number, minimum 1 bit will be different in binary of those numbers
https://www.youtube.com/watch?v=UA5JnV1J2sI&list=PLgUwDviBIf0rnqh8QsJaHyIX7KUiaPUv7&index=7
# method 1 : brute force approch
# TC     -      O(N + logm) + m where m =(n/2)+1
# SC     -     O(m)
def main_function(arr):
  obj = {}
  for i in range(len(arr)):
    obj[arr[i]] = obj.get(i, 0) + 1 
  res = []
  for key, value in obj.items():
    if value==1:
      res.append(key)
  return res
  
start = [4,1,2,1,2]
print(main_function(start)) 


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      



# endregion








# region 8.3 BIT MANIPULATION - HARD
# ----------------------------------
https://www.youtube.com/watch?v=LT7XhVdeRyg&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=267
# 1 TODO :  print prime factors of a number
'''


ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://bit.ly/3C165p8



'''
# method 1 : brute force approch
# TC     -  O(N*sqrt(N))    
# SC     -    
def main_function(num):
  res = []
  for i in range(2, num+1):
    if num % i==0:
      if prime(i):
        res.append(i)
        
  return res

import math

def prime(num):
    if num <= 1:
        return False  # 1 and numbers less than 1 are not prime
    for i in range(2, int(math.sqrt(num)) + 1):  # Check divisibility from 2 to sqrt(num)
        if num % i == 0:
            return False  # num is divisible by i, hence it's not prime
    return True  # num is prime if it's not divisible by any number in the range

num = 60
print(main_function(num))
num = 35
print(main_function(num))
num = 780
print(main_function(num)) 


# method 2 : better approch
# TC     -     O(sqrt(N) * 2 * sqrt(N)) near by 
# SC     -    
import math

def main_function(num):
    res = []
    # Loop through divisors from 1 to sqrt(num)
    for i in range(1, int(math.sqrt(num)) + 1):  # Fixing the range
        if num % i == 0:  # Check if i is a divisor of num
            if prime(i):
                res.append(i)
            if num // i != i:  # To avoid duplicates, check if i is not the square root of num
                if prime(num // i):
                    res.append(num // i)
    return res

import math

def prime(num):
    if num <= 1:
        return False  # 1 and numbers less than 1 are not prime
    for i in range(2, int(math.sqrt(num)) + 1):  # Check divisibility from 2 to sqrt(num)
        if num % i == 0:
            return False  # num is divisible by i, hence it's not prime
    return True  # num is prime if it's not divisible by any number in the range

num = 60
print(main_function(num))
num = 35
print(main_function(num))
num = 780
print(main_function(num)) 


# method 3 : optimal solution
# TC     -      
# SC     -    
import math

def main_function(num):
    res = []
    # Loop through divisors from 1 to sqrt(num)
    for i in range(2, num):
      if num % i == 0:
        res.append(i)
        while num % i == 0:
          num = num // i
    return res

import math

def prime(num):
    if num <= 1:
        return False  # 1 and numbers less than 1 are not prime
    for i in range(2, int(math.sqrt(num)) + 1):  # Check divisibility from 2 to sqrt(num)
        if num % i == 0:
            return False  # num is divisible by i, hence it's not prime
    return True  # num is prime if it's not divisible by any number in the range

num = 60
print(main_function(num))
num = 35
print(main_function(num))
num = 780
print(main_function(num))  

# method 4 : optimal solution
# TC     -      O(sqrt(N)*log(N))
# SC     -    
import math

def main_function(num):
    res = []
    # Loop through divisors from 1 to sqrt(num)
    for i in range(2, int(math.sqrt(num)+1)):
      if num % i == 0:
        res.append(i)
        while num % i == 0:
          num = num // i
    if num != 1:
      res.append(num)
    return res


num = 60
print(main_function(num))
num = 35
print(main_function(num))
num = 780
print(main_function(num)) 


# 2 TODO : all divisors of a number
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://practice.geeksforgeeks.org/problems/all-divisors-of-a-number/1?utm_source=youtube&amp;utm_medium=collab_striver_ytdescription&amp;utm_campaign=all-divisors-of-a-number




'''
https://www.youtube.com/watch?v=Ae_Ag_saG9s&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=265
# method 1 : brute force approch
# TC     -      
# SC     -    
import math

def main_function(num):
    res = []
    for i in range(1, num + 1):
      if num % i == 0:
        res.append(i)
    return res


num = 60
print(main_function(num))
num = 36
print(main_function(num))
num = 780
print(main_function(num)) 


# method 2 : better approch
# TC     -      O(sqrt(N))
# SC     -    
import math

def main_function(num):
    res = []
    for i in range(1, int(math.sqrt(num) + 1)):
      if num % i == 0:
        res.append(i)
        if num // i != i:
          res.append(num//i)
    return res


num = 60
print(main_function(num))
num = 36
print(main_function(num))
num = 780
print(main_function(num)) 


# method 3 : optimal solution
# TC     -      
# SC     -      


# 3 TODO : sieve of eratosthenes, print all the prime till the number N
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/count-primes/

'''
https://www.youtube.com/watch?v=g5Fuxn_AvSk&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=269
# method 1 : brute force approch
# TC     -      
# SC     -     
import math

def main_function(num):
    res = []
    for i in range(1, num + 1):
      if prime(i):
        res.append(i)
    return res
    
def prime(num):
    if num <= 1:
        return False  # 1 and numbers less than 1 are not prime
    for i in range(2, int(math.sqrt(num)) + 1):  # Check divisibility from 2 to sqrt(num)
        if num % i == 0:
            return False  # num is divisible by i, hence it's not prime
    return True  # num is prime if it's not divisible by any number in the range



num = 60
print(main_function(num))
num = 36
print(main_function(num))
num = 780
print(main_function(num))


# method 2 : better approch
# TC     -      
# SC     -     
import math

def main_function(num):
    res = []
    # Loop through divisors from 1 to sqrt(num)
    prime = utility(num)
    for i in range(1, num + 1):
      if prime[i]:
        res.append(i)
    # utility(num)
    return res
    
def utility(N):
  prime = [1]*(N+1)
  print(prime)
  for i in range(2, N):
    if prime[i] == 1:
      for j in range(2*i, N+1, i):
        prime[j] = 0
  return prime


num = 60
print(main_function(num))
num = 36
print(main_function(num))
num = 780
print(main_function(num))

# method 3 : optimal solution
# TC     -     O(N) + O(N*log(log(N))) + O(N) 
# SC     -  O(N)
import math

def main_function(num):
    res = []
    # Generate a list of primes up to num using the utility function
    prime = utility(num)
    # Collecting the prime numbers based on the sieve result
    for i in range(2, num + 1):
        if prime[i]:  # If prime[i] is 1, it means i is prime
            res.append(i)
    return res
    
def utility(N):
    prime = [1] * (N + 1)  # A list to track if numbers are prime (1 means prime, 0 means not prime)
    prime[0], prime[1] = 0, 0  # 0 and 1 are not prime numbers
    
    # Sieve of Eratosthenes algorithm
    for i in range(2, int(math.sqrt(N)) + 1):  # We only need to go up to sqrt(N)
        if prime[i] == 1:  # If i is prime
            # Mark all multiples of i as non-prime
            for j in range(i * i, N + 1, i):  # Start from i^2, since smaller multiples would have been marked already
                prime[j] = 0
    return prime

# Test cases
num = 60
print(main_function(num))  # Output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]
num = 36
print(main_function(num))  # Output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]
num = 780
print(main_function(num))  # Output: Primes up to 780
    


# 4 TODO : find prime factorisation of a number using sieve
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://bit.ly/3SPGzbK



'''
https://www.youtube.com/watch?v=glKWkmKFlMw&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=271
# method 1 : brute force approch
# TC     -      
# SC     -     
import math

def main_function(num):
    res = []
    # Loop through divisors from 1 to sqrt(num)
    for i in range(2, int(math.sqrt(num)+1)):
      if num % i == 0:
        
        while num % i == 0:
          res.append(i)
          num = num // i
    if num != 1:
      res.append(num)
    return res


num = 60
print(main_function(num))
num = 35
print(main_function(num))
num = 780
print(main_function(num)) 


# method 2 : better approch
# TC     -      
# SC     - 
NOT according to striver    
# import math

# def main_function(num):
#     prime_factors = []
#     primes = utility(num)  # Get primes up to 'num' using the sieve
#     for i in range(2, num + 1):
#         # Check if 'i' is prime and divides 'num'
#         if primes[i]:  # i is prime
#             while num % i == 0:  # Keep dividing 'num' by i as long as it's divisible
#                 prime_factors.append(i)
#                 num //= i  # Update 'num' after dividing by the prime factor
#     return prime_factors
    
# def utility(N):
#     prime = [1] * (N + 1)  # Sieve of Eratosthenes array
#     prime[0], prime[1] = 0, 0  # 0 and 1 are not prime
    
#     # Sieve of Eratosthenes algorithm
#     for i in range(2, int(math.sqrt(N)) + 1):
#         if prime[i] == 1:
#             for j in range(i * i, N + 1, i):
#                 prime[j] = 0  # Mark multiples of i as non-prime
#     return prime

# # Test cases
# num = 60
# print(main_function(num))  # Output: [2, 2, 3, 5]
# num = 36
# print(main_function(num))  # Output: [2, 2, 3, 3]
# num = 780
# print(main_function(num))  # Output: [2, 2, 3, 5, 13]



# method 3 : optimal solution
# TC     -      
# SC     -      


# â­â­â­ PATTERN - power exponention
# 5 TODO : power(n,x), using power exponention
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/powx-n/




'''
https://www.youtube.com/watch?v=hFWckDXE-K8&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=268
# method 1 : brute force approch
# TC     -      
# SC     -   
def main_function(num, pow):
  res = 1 
  for i in range(1, pow+1):
    res = 2*res
  return res


num = 2
pow = 5
print(main_function(num, pow))


# method 2 : better approch
# TC     -      O(log2(N))
# SC     -  O(1)
def main_function(num, pow):
    ans = 1
    while pow > 0:
        if pow % 2 == 1:  # If the exponent is odd
            ans = ans * num
        num = num * num  # Square the base
        pow = pow // 2  # Halve the exponent
    if pow < 0:
        return 1 / ans
    return ans

# Test case
num = 2
pow = 5
print(main_function(num, pow))  # Output should be 32 (2^5)
   


# method 3 : optimal solution
# TC     -      
# SC     -      



# endregion








# region 9.1 STACK/QUEUE - LEARNING
# ---------------------------------
'''
https://www.youtube.com/watch?v=tqQ5fTamIN4&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=297

Time Complexity: O(1)

Space Complexity: O(N)
'''
# 1 TODO :  implement stack using arrays
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/data-structure/implement-stack-using-array/


https://bit.ly/3QPJ39w




'''
# method 1 : brute force approch

class Stack:
    def __init__(self):
      self.top = -1
      self.size = 1000
      self.arr = [0] * self.size


    def push(self, x: int) -> None:
      if self.top >= self.size:
        return "Stack is full."
      self.top += 1
      self.arr[self.top] = x


    def pop(self) -> int:
      if self.top != -1:
        x = self.arr[self.top]
        self.top -= 1
        return x


    def Top(self) -> int:
      # -1 means stack is empty
      return self.arr[self.top]


    def Size(self) -> int:
      return self.top + 1




if __name__ == "__main__":
    s = Stack()
    s.push(6)
    s.push(3)
    s.push(7)
    print("Top of stack is before deleting any element", s.Top())
    print("Size of stack before deleting any element", s.Size())
    print("The element deleted is", s.pop())
    print("Size of stack after deleting an element", s.Size())
    print("Top of stack after deleting an element", s.Top())

# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : implement queue using arrays
# method 1 : brute force approch
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/data-structure/implement-queue-using-array/


https://bit.ly/3C9HLli

https://www.youtube.com/watch?v=tqQ5fTamIN4&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=297

Time Complexity:

pop function: O(1)

push function: O(1)

top function: O(1)

size function: O(1)

Space Complexity:
Whole Queue: O(n)
'''
class Queue:
    def __init__(self):
        self.start = -1
        self.end = -1
        self.currSize = 0
        self.maxSize = 16
        self.arr = [0] * self.maxSize


    def push(self, newElement: int) -> None:
        if self.currSize == self.maxSize:
            print("Queue is full\nExiting...")
            exit(1)
        if self.currSize == 0:
            self.start = 0
            self.end = 0
        # if self.end == -1:
        #     self.start = 0
        #     self.end = 0
        else:
            self.end = (self.end + 1) % self.maxSize
        self.arr[self.end] = newElement
        print("The element pushed is", newElement)
        self.currSize += 1


    def pop(self) -> int:
        if self.start == -1:
            print("Queue Empty\nExiting...")
        popped = self.arr[self.start]
        if self.currSize == 1:
            self.start = -1
            self.end = -1
        else:
            self.start = (self.start + 1) % self.maxSize
        self.currSize -= 1
        return popped


    def top(self) -> int:
        if self.start == -1:
            print("Queue is Empty")
            exit(1)
        return self.arr[self.start]


    def size(self) -> int:
        return self.currSize




if __name__ == "__main__":
    q = Queue()
    print(q.__dict__)
    q.push(4)
    q.push(14)
    q.push(24)
    q.push(34)
    print("The peek of the queue before deleting any element", q.top())
    print("The size of the queue before deletion", q.size())
    print("The first element to be deleted", q.pop())
    print("The peek of the queue after deleting an element", q.top())
    print("The size of the queue after deleting an element", q.size())

# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      
 


# 3 TODO : implement stack using queue
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://takeuforward.org/data-structure/implement-stack-using-single-queue/


https://leetcode.com/problems/implement-stack-using-queues/




'''
# method 1 : brute force approch

https://www.youtube.com/watch?v=tqQ5fTamIN4&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=297

Time Complexity: O(N)

Space Complexity: O(N)


from queue import Queue  

class Stack:
    def __init__(self):
        self.q = Queue() 

    def push(self, x):
        s = self.q.qsize()  # Get the current size of the queue (number of elements in the stack)
        
        # Add the new element to the end of the queue
        self.q.put(x)
        
        # Rotate the queue elements to make the newly added element the front (simulating stack behavior)
        for i in range(s):
            self.q.put(self.q.get())  # Remove the front element and put it at the end
        
    def pop(self):
        if self.q.empty():  # Check if the queue (stack) is empty
            print("Stack is empty! Cannot pop.")
            return None
        n = self.q.get()  # Get the front element (top of the stack)
        return n  # Return the popped element

    def top(self):
        if self.q.empty():  # Check if the stack is empty
            print("Stack is empty! Cannot get the top.")
            return None
        return self.q.queue[0]  # Access the front element of the queue (top of the stack)

    def size(self):
        return self.q.qsize()  # Return the size of the queue (number of elements in the stack)

# Driver code to test the Stack implementation
if __name__ == "__main__":
    s = Stack()  # Create a new stack instance using the Stack class
    
    # Push elements onto the stack
    s.push(3)
    s.push(2)
    s.push(4)
    s.push(1)
    
    # Print the top element of the stack (should be the most recently added element)
    print("Top of the stack: ", s.top())  # Expected output: 1 (most recently pushed element)
    
    # Print the size of the stack before popping any element
    print("Size of the stack before removing element: ", s.size())  # Expected output: 4
    
    # Pop the top element and print it
    print("The deleted element is: ", s.pop())  # Expected output: 1 (most recently added element)
    
    # Print the top element of the stack after the pop operation
    print("Top of the stack after removing element: ", s.top())  # Expected output: 4 (next element)
    
    # Print the size of the stack after popping an element
    print("Size of the stack after removing element: ", s.size())  # Expected output: 3


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 4 TODO : implement queue using stack
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/implement-queue-using-stack/


https://leetcode.com/problems/implement-queue-using-stacks/




'''
# method 1 : brute force approch
Time Complexity: O(N )  

Space Complexity: O(2N)



from queue import LifoQueue
# using LifoQueue which is a stack in python

class Queue:
    def __init__(self):
        self.input = LifoQueue()
        self.output = LifoQueue()


    def push(self, data: int) -> None:
        # Pop out all elements from the stack input
        while not self.input.empty():
            self.output.put(self.input.get())
        # Insert the desired element in the stack input
        print("The element pushed is", data)
        self.input.put(data)
        # Pop out elements from the stack output and push them into the stack input
        while not self.output.empty():
            self.input.put(self.output.get())


    # Pop the element from the Queue
    def pop(self) -> int:
        if self.input.qsize() == 0:
            print("Stack is empty")
            exit(0)
        val = self.input.get()
        return val


    def Top(self) -> int:
        if self.input.qsize() == 0:
            print("Stack is empty")
            exit(0)
        return self.input.queue[-1]


    def size(self) -> int:
        return self.input.qsize()




if __name__ == "__main__":
    q = Queue()
    q.push(3)
    q.push(4)
    print("The element poped is", q.pop())
    q.push(5)
    print("The top of the queue is", q.Top())
    print("The size of the queue is", q.size())


# method 2 : better approch
# TC     -      
# SC     -    
class QueueUsingTwoStacks:
    def __init__(self):
        """Initialize the queue using two stacks."""
        self.stack1 = []  # Stack used for enqueuing
        self.stack2 = []  # Stack used for dequeuing

    def enqueue(self, x):
        """Enqueue an element into the queue (push to stack1)."""
        self.stack1.append(x)
        print(f"Enqueued: {x}")

    def dequeue(self):
        """Dequeue an element from the queue (pop from stack2)."""
        if self.is_empty():
            print("Queue is empty! Cannot dequeue.")
            return None
        
        # If stack2 is empty, transfer all elements from stack1 to stack2
        if not self.stack2:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        
        # Pop the element from stack2, which is the front of the queue
        return self.stack2.pop()

    def peek(self):
        """Return the front element of the queue without removing it."""
        if self.is_empty():
            print("Queue is empty! Cannot peek.")
            return None
        
        # If stack2 is empty, transfer all elements from stack1 to stack2
        if not self.stack2:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        
        return self.stack2[-1]  # Peek the top element of stack2

    def is_empty(self):
        """Check if the queue is empty."""
        return len(self.stack1) == 0 and len(self.stack2) == 0

    def size(self):
        """Return the current size of the queue."""
        return len(self.stack1) + len(self.stack2)

# Test the QueueUsingTwoStacks class
if __name__ == "__main__":
    queue = QueueUsingTwoStacks()
    
    # Enqueue elements into the queue
    queue.enqueue(10)
    queue.enqueue(20)
    queue.enqueue(30)
    
    print("Front of the queue:", queue.peek())  # Expected output: 10
    print("Size of the queue:", queue.size())  # Expected output: 3
    
    # Dequeue an element from the queue
    print("Dequeued element:", queue.dequeue())  # Expected output: 10
    print("Front of the queue after dequeue:", queue.peek())  # Expected output: 20
    print("Size of the queue after dequeue:", queue.size())  # Expected output: 2
    
    # Enqueue more elements
    queue.enqueue(40)
    queue.enqueue(50)
    
    print("Front of the queue after more enqueues:", queue.peek())  # Expected output: 20
    print("Size of the queue after more enqueues:", queue.size())  # Expected output: 4
    
    # Dequeue all elements
    print("Dequeued element:", queue.dequeue())  # Expected output: 20
    print("Dequeued element:", queue.dequeue())  # Expected output: 30
    print("Dequeued element:", queue.dequeue())  # Expected output: 40
    print("Dequeued element:", queue.dequeue())  # Expected output: 50
    
    # Check if the queue is empty
    print("Is the queue empty?", queue.is_empty())  # Expected output: True
 


# method 3 : optimal solution
# TC     -      
# SC     -      


# 5 TODO : implement stack using linked list
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/data-structure/implement-stack-using-linked-list/

https://bit.ly/3w6PwVv




'''
# method 1 : brute force approch
# TC     -      
# SC     -  

# Node class to represent an element in the linked list
class Node:
    def __init__(self, data=None):
        self.data = data  # Data stored in the node
        self.next = None  # Reference to the next node

# Stack class using linked list
class Stack:
    def __init__(self):
        self.top = None  # Initialize the stack with no elements
        self.size = 0  # Initialize stack size to 0

    def push(self, data):
        """Push an element onto the stack"""
        new_node = Node(data)  # Create a new node with the given data
        new_node.next = self.top  # Link the new node to the top element of the stack
        self.top = new_node  # Update the top of the stack to the new node
        self.size += 1  # Increment the size of the stack
        print(f"Pushed {data} onto the stack.")

    def pop(self):
        """Pop an element from the stack"""
        if self.is_empty():
            print("Stack is empty! Cannot pop.")
            return None
        popped_node = self.top  # Get the top element
        self.top = self.top.next  # Update the top to the next element
        popped_data = popped_node.data  # Store the data of the popped node
        
        # Explicitly delete the popped node to free the memory
        popped_node.next = None  # Disconnect the node from the list (optional but good practice)
        popped_node = None  # Explicitly dereference the popped node (helpful for garbage collection)
        
        self.size -= 1  # Decrement the stack size
        return popped_data  # Return the popped data

    def peek(self):
        """Return the top element without removing it"""
        if self.is_empty():
            print("Stack is empty! Cannot peek.")
            return None
        return self.top.data  # Return the data of the top element

    def is_empty(self):
        """Check if the stack is empty"""
        return self.size == 0

    def get_size(self):
        """Return the size of the stack"""
        return self.size

# Driver code to test the stack implementation
if __name__ == "__main__":
    stack = Stack()
    
    # Test pushing elements onto the stack
    stack.push(10)
    stack.push(20)
    stack.push(30)
    
    # Test peek operation
    print(f"Top element is: {stack.peek()}")  # Should print 30
    
    # Test popping elements from the stack
    print(f"Popped element: {stack.pop()}")  # Should print 30
    print(f"Popped element: {stack.pop()}")  # Should print 20
    print(f"Popped element: {stack.pop()}")  # Should print 10
    
    # Test if the stack is empty
    print(f"Is stack empty? {stack.is_empty()}")  # Should print True
    
    # Test the size of the stack
    print(f"Stack size: {stack.get_size()}")  # Should print 0



# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 6 TODO : implement queue using linked list
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/implement-queue-using-linked-list/


https://bit.ly/3PA7mY0



'''
# method 1 : brute force approch
# TC     -      
# SC     -  
# Node class to represent an element in the linked list
class Node:
    def __init__(self, data=None):
        self.data = data  # Data stored in the node
        self.next = None  # Reference to the next node

# Queue class using a linked list
class Queue:
    def __init__(self):
        self.start = None  # Initialize start to None (empty queue)
        self.end = None    # Initialize end to None (empty queue)
        self.size = 0      # Initialize queue size to 0

    def enqueue(self, data):
        """Enqueue an element into the queue"""
        new_node = Node(data)  # Create a new node with the given data
        if self.end is None:
            # If the queue is empty, both start and end will point to the new node
            self.start = new_node
            self.end = new_node
        else:
            # Add the new node at the end and update the end pointer
            self.end.next = new_node
            self.end = new_node
        self.size += 1  # Increment the size of the queue
        print(f"Enqueued {data} into the queue.")

    def dequeue(self):
        """Dequeue an element from the start of the queue"""
        if self.is_empty():
            print("Queue is empty! Cannot dequeue.")
            return None
        dequeued_node = self.start  # Get the start node
        self.start = self.start.next  # Move the start pointer to the next node
        
        # Explicitly delete the data of the dequeued node
        dequeued_node.data = None  # Clear the data of the dequeued node
        
        if self.start is None:  # If the queue becomes empty, set end to None as well
            self.end = None
        self.size -= 1  # Decrement the size of the queue
        return dequeued_node.data  # Return the dequeued data (which is now None)

    def peek(self):
        """Return the start element without removing it"""
        if self.is_empty():
            print("Queue is empty! Cannot peek.")
            return None
        return self.start.data  # Return the data at the start node

    def is_empty(self):
        """Check if the queue is empty"""
        return self.size == 0

    def get_size(self):
        """Return the size of the queue"""
        return self.size

# Driver code to test the queue implementation
if __name__ == "__main__":
    queue = Queue()
    
    # Test enqueue operation
    queue.enqueue(10)
    queue.enqueue(20)
    queue.enqueue(30)
    
    # Test peek operation
    print(f"Start element is: {queue.peek()}")  # Should print 10
    
    # Test dequeue operation
    print(f"Dequeued element: {queue.dequeue()}")  # Should print 10
    print(f"Dequeued element: {queue.dequeue()}")  # Should print 20
    
    # Test if the queue is empty
    print(f"Is queue empty? {queue.is_empty()}")  # Should print False
    
    # Test the size of the queue
    print(f"Queue size: {queue.get_size()}")  # Should print 1
    
    # Test the final dequeue operation
    print(f"Dequeued element: {queue.dequeue()}")  # Should print 30
    print(f"Is queue empty? {queue.is_empty()}")  # Should print True
    print(f"Queue size: {queue.get_size()}")  # Should print 0
   


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -   


# 7 TODO : check for balanced paranthesis
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/check-for-balanced-parentheses/


https://leetcode.com/problems/valid-parentheses/



'''
# method 1 : brute force approch
'''
https://www.youtube.com/watch?v=xwjS0iZhw4I&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=298

Time Complexity: O(N)

Space Complexity: O(N)
'''

def isValid(s: str) -> bool:
  st = []
  for it in s:
    if it == '(' or it == '{' or it == '[':
      st.append(it)
    else:
      if len(st) == 0:
        return False
      ch = st[-1] # taking the top element
      st.pop()
      if (it == ')' and ch == '(') or (it == ']' and ch == '[') or (it == '}' and ch == '{'):
        continue
      else:
        return False
  return len(st) == 0




if __name__ == '__main__':
    s = "()[{}()]"
    if isValid(s):
        print("True")
    else:
        print("False") 


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 8 TODO : implement min stack
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://takeuforward.org/data-structure/implement-min-stack-o2n-and-on-space-complexity/


https://leetcode.com/problems/min-stack/


'''
# method 1 : brute force approch
'''
Time Complexity (TC):
push(x): O(1), since we are appending to the list.
pop(): O(1), since we are popping from the end.
top(): O(1), accessing the last element.
getMin(): O(n), because we are iterating through the stack to find the minimum.
Space Complexity (SC): O(n), where n is the number of elements in the stack.

'''
class MinStackBrute:
    def __init__(self):
        self.stack = []

    def push(self, x: int) -> None:
        self.stack.append(x)

    def pop(self) -> None:
        if self.stack:
            self.stack.pop()

    def top(self) -> int:
        if self.stack:
            return self.stack[-1]

    def getMin(self) -> int:
        return min(self.stack) if self.stack else None

# Example usage:
min_stack = MinStackBrute()
min_stack.push(3)
min_stack.push(1)
min_stack.push(2)
print("Top:", min_stack.top())  # 2
print("Min:", min_stack.getMin())  # 1
min_stack.pop()
print("Min after pop:", min_stack.getMin())  # 1


# method 2 : better approch
'''
Time Complexity (TC):

push(x): O(1), as both stack and min_stack operations are constant time.
pop(): O(1), removing from both stacks.
top(): O(1), accessing the last element in stack.
getMin(): O(1), accessing the last element in min_stack.
Space Complexity (SC): O(n), where n is the number of elements in the stack, since we are maintaining an auxiliary stack.

'''
class MinStackBetter:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, x: int) -> None:
        self.stack.append(x)
        # Push the current minimum to the min_stack
        if not self.min_stack:
            self.min_stack.append(x)
        else:
            self.min_stack.append(min(x, self.min_stack[-1]))

    def pop(self) -> None:
        if self.stack:
            self.stack.pop()
            self.min_stack.pop()

    def top(self) -> int:
        if self.stack:
            return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1] if self.min_stack else None

# Example usage:
min_stack = MinStackBetter()
min_stack.push(3)
min_stack.push(1)
min_stack.push(2)
print("Top:", min_stack.top())  # 2
print("Min:", min_stack.getMin())  # 1
min_stack.pop()
print("Min after pop:", min_stack.getMin())  # 1


# method 3 : optimal solution
'''
Time Complexity (TC):

push(x): O(1), as we are pushing a tuple onto the stack.
pop(): O(1), removing a tuple from the stack.
top(): O(1), accessing the value from the top tuple.
getMin(): O(1), accessing the minimum value from the top tuple.
Space Complexity (SC): O(n), where n is the number of elements in the stack, since we store both the value and the minimum in the stack.
'''
class MinStackOptimal:
    def __init__(self):
        self.stack = []

    def push(self, x: int) -> None:
        if not self.stack:
            self.stack.append((x, x))  # (value, min)
        else:
            current_min = self.stack[-1][1]
            self.stack.append((x, min(x, current_min)))

    def pop(self) -> None:
        if self.stack:
            self.stack.pop()

    def top(self) -> int:
        if self.stack:
            return self.stack[-1][0]

    def getMin(self) -> int:
        return self.stack[-1][1] if self.stack else None

# Example usage:
min_stack = MinStackOptimal()
min_stack.push(3)
min_stack.push(1)
min_stack.push(2)
print("Top:", min_stack.top())  # 2
print("Min:", min_stack.getMin())  # 1
min_stack.pop()
print("Min after pop:", min_stack.getMin())  # 1



# endregion








# region 9.2 STACK/QUEUE - PREFIX/POSTFIX
# ---------------------------------------
'''   
https://www.youtube.com/watch?v=4pIc9UBHJtk&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=299

- operator -  
- operand - 
- priority order of operators
**
*,//
+,-
- infix expression
usecase ??
(p+q)*(m-n)
- prefix expression
usecase ??
*+pq-mn
- postfix expression
usecase ??
pq+mn-*


'''

# 1 TODO :  Shunting Yard algorithm,, infix to postfix conversion using stack
# method 1 : brute force approch
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/infix-to-postfix/

https://bit.ly/3JWYj1P


- initiate i, stack st and and empty string ans
- iterate over the expression
- if encounter an operand, add it to the string ans
- if encounter an ( bracket, push the bracket ( into the stack
- if ancounter an ) bracket, keep popping out the operators until found ) bracket and adding those popped operators into the string ans
- if encounter an operator, then check if the top of the stack has less priority operator then push that current operator. If the top of the stack has operator of higher priority then keep popping that operator and add it to the string ans
- once iteration is closed, then again iterate over the stack st and keep popping and add those operators in string ans




TC     -      O(N) + O(N)
SC     -   O(N) + O(N)

'''

def priority(op):
    # Define the precedence of operators
    if op == '+' or op == '-':
        return 1
    if op == '*' or op == '/':
        return 2
    if op == '^':
        return 3  # ^ has the highest precedence
    return 0  # for parentheses or non-operator characters

def is_left_associative(op):
    # ^ is right-associative, other operators are left-associative
    return op != '^'

def main_function(s):
    i = 0
    st = []  # Stack for operators and parentheses
    ans = ""  # Output for the postfix expression
    n = len(s)

    while i < n:
        if s[i].isalnum():  # If the character is an operand (alphabetic or digit)
            ans += s[i]
        elif s[i] == "(":  # If it's a left parenthesis, push to stack
            st.append(s[i])
        elif s[i] == ")":  # If it's a right parenthesis, pop until left parenthesis is found
            while st and st[-1] != "(":
                ans += st.pop()
            st.pop()  # Pop the '(' from stack
        else:  # If it's an operator
            while st and priority(s[i]) < priority(st[-1]) or (priority(s[i]) == priority(st[-1]) and is_left_associative(s[i])):
                ans += st.pop()  # Pop operators from stack to output if their precedence is higher or equal
            st.append(s[i])  # Push the current operator to the stack
        i += 1

    # Pop the remaining operators from the stack
    while st:
        ans += st.pop()

    return ans

# Test the function with an expression containing ^
expression = "(p+q)*(m-n)^2"
print(main_function(expression))  # Output: pq+mn-2^*
  


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : prefix to infix conversion
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://bit.ly/3FwxK3j



'''
# method 1 : brute force approch
'''

- initiate two variables iterator i and stack stack
- iterate over the expression
- if encounter an operand, just push it into the stack
- if get an operator, pop last two operands and create small expression like (operand_1 operator operand_2) , and push this expression into the stack




TC     -  O(N) + O(N)
SC     -  O(N)
''' 

def is_operator(c):
    # Check if the character is an operator
    return c in '+-*/^'

def prefix_to_infix(prefix):
    stack = []
    # Reverse the prefix expression to process it from right to left
    prefix = prefix[::-1]
    i = 0

    # Loop through the reversed prefix expression using a while loop
    while i < len(prefix):
        char = prefix[i]

        # If the character is an operand, push it onto the stack
        if not is_operator(char):
            stack.append(char)
        else:
            # If the character is an operator, pop two operands from the stack
            operand1 = stack.pop()
            operand2 = stack.pop()

            # Form the infix expression with parentheses around the operands and operator
            infix_expr = f"({operand1} {char} {operand2})"

            # Push the resulting infix expression back onto the stack
            stack.append(infix_expr)

        # Increment the index
        i += 1

    # The final element in the stack will be the infix expression
    return stack[-1]

# Example usage
prefix_expr = "*+ab-cd"
infix_expr = prefix_to_infix(prefix_expr)
print(f"Prefix Expression: {prefix_expr}")
print(f"Infix Expression: {infix_expr}")




# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 3 TODO : prefix to postfix conversion
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://bit.ly/3DrwCLI


'''
# method 1 : brute force approch
'''
- initialize two variable stack and i
- iterate over the expression from the end
- if encounter an operand, just push it into the stack
- if get an operator, pop last two operands and create small expression like (operand_top_1 operand_top_2 operator ) , and push this expression into the stack


TC     -      O(2N)
SC     -     O(N)
'''
def is_operator(c):
    # Check if the character is an operator
    return c in '+-*/^'

def prefix_to_postfix(prefix):
    stack = []
    i = len(prefix) - 1  # Start from the last character of the prefix expression

    # Loop through the prefix expression in reverse order using a while loop
    while i >= 0:
        char = prefix[i]

        # If the character is an operand, push it onto the stack
        if not is_operator(char):
            stack.append(char)
        else:
            # If the character is an operator, pop two operands from the stack
            if len(stack) < 2:
                raise ValueError("Insufficient operands for the operator")
            operand1 = stack.pop()
            operand2 = stack.pop()

            # Form the postfix expression by placing the operands first, then the operator
            postfix_expr = f"{operand1}{operand2}{char}"

            # Push the resulting postfix expression back onto the stack
            stack.append(postfix_expr)

        # Decrement the index to process the next character from the right
        i -= 1

    # The final element in the stack will be the postfix expression
    if len(stack) != 1:
        raise ValueError("Invalid expression")
    return stack[-1]

# Example usage
prefix_expr = "*+ab-cd"
postfix_expr = prefix_to_postfix(prefix_expr)
print(f"Prefix Expression: {prefix_expr}")
print(f"Postfix Expression: {postfix_expr}")



# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 4 TODO : postfix to prefix conversion
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://bit.ly/3UaWJxk




'''
# method 1 : brute force approch
'''
- initiate two variables iterator i and stack stack
- iterate over the expression
- if encounter an operand, just push it into the stack
- if get an operator, pop last two operands and create small expression like (operator operand_top_2 operand_top_1) , and push this expression into the stack



TC     -      O(N)
SC     -  O(N)
'''

def is_operator(c):
    # Check if the character is an operator
    return c in '+-*/^'

def postfix_to_prefix(postfix):
    stack = []
    i = 0

    # Loop through the postfix expression using a while loop
    while i < len(postfix):
        char = postfix[i]

        # If the character is an operand, push it onto the stack
        if not is_operator(char):
            stack.append(char)
        else:
            # If the character is an operator, pop two operands from the stack
            operand2 = stack.pop()
            operand1 = stack.pop()

            # Form the prefix expression by placing the operator before the operands
            prefix_expr = f"{char}{operand1}{operand2}"

            # Push the resulting prefix expression back onto the stack
            stack.append(prefix_expr)

        # Increment the index
        i += 1

    # The final element in the stack will be the prefix expression
    return stack[-1]

# Example usage
postfix_expr = "ab+c*d+"
prefix_expr = postfix_to_prefix(postfix_expr)
print(f"Postfix Expression: {postfix_expr}")
print(f"Prefix Expression: {prefix_expr}")



# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 5 TODO : postfix to infix 
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://bit.ly/3sNZ1a2




'''
# method 1 : brute force approch
'''
- initiate two variables iterator i and stack stack
- iterate over the expression
- if encounter an operand, just push it into the stack
- if get an operator, pop last two operands and create small expression like (operand_1 operator operand_2) , and push this expression into the stack




TC     -      O(N) + O(N)
SC     -  O(N)
'''
def is_operator(c):
    # Check if the character is an operator
    return c in '+-*/^'

def postfix_to_infix(postfix):
    stack = []
    i = 0

    # Loop through the postfix expression using a while loop
    while i < len(postfix):
        char = postfix[i]

        # If the character is an operand (a number or letter), push it onto the stack
        if not is_operator(char):
            stack.append(char)
        else:
            # If the character is an operator, pop two operands from the stack
            operand2 = stack.pop()
            operand1 = stack.pop()

            # Form the infix expression with parentheses around the operands and operator
            infix_expr = f"({operand1} {char} {operand2})"

            # Push the resulting infix expression back onto the stack
            stack.append(infix_expr)

        # Increment the index
        i += 1

    # The final element in the stack will be the infix expression
    return stack[-1]

# Example usage
postfix_expr = "ab+c*d+"
infix_expr = postfix_to_infix(postfix_expr)
print(f"Postfix Expression: {postfix_expr}")
print(f"Infix Expression: {infix_expr}")



# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 6 TODO : convert infix to prefix notation
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/infix-to-prefix/

https://bit.ly/3T0gZ4P



'''
# method 1 : brute force approch
'''
Step 1: Reverse the input expression from end to start
Step 2: Replace parentheses in the reversed string, ( => ) and ) => (
Step 3: Convert the reversed infix to postfix
- initiate i, stack st and and empty string ans
- iterate over the expression
- if encounter an operand, add it to the string ans
- if encounter an ( bracket, push the bracket ( into the stack
- if ancounter an ) bracket, keep popping out the operators until found ) bracket and adding those popped operators into the string ans
- if encounter an operator, then check if the top of the stack has less priority operator then push that current operator. If the top of the stack has operator of higher priority then keep popping that operator and add it to the string ans
- once iteration is closed, then again iterate over the stack st and keep popping and add those operators in string ans
Step 4: Reverse the postfix expression to get prefix


TC     -      O(3N)
SC     -  O(N)

'''
def priority(op):
    # Define the precedence of operators
    if op == '+' or op == '-':
        return 1
    if op == '*' or op == '/':
        return 2
    if op == '^':
        return 3  # ^ has the highest precedence
    return 0

def is_left_associative(op):
    # ^ is right-associative, other operators are left-associative
    return op != '^'

def infix_to_postfix(s):
    st = []  # Stack for operators and parentheses using list
    ans = ""  # Output for the postfix expression
    n = len(s)

    for i in range(n):
        if s[i].isalnum():  # If the character is an operand (alphabetic or digit)
            ans += s[i]
        elif s[i] == "(":  # If it's a left parenthesis, push to stack
            st.append(s[i])
        elif s[i] == ")":  # If it's a right parenthesis, pop until left parenthesis is found
            while st and st[-1] != "(":
                ans += st.pop()
            st.pop()  # Pop the '(' from stack
        else:  # If it's an operator
            while st and (priority(s[i]) < priority(st[-1]) or 
                          (priority(s[i]) == priority(st[-1]) and is_left_associative(s[i]))):
                ans += st.pop()  # Pop operators from stack to output if their precedence is higher or equal
            st.append(s[i])  # Push the current operator to the stack
            # if s[i] == '^':
            #     while st and (priority(s[i]) <= priority(st[-1])):
            #       ans = ans + st.pop()
            # else:
            #     while st and priority(s[i]) < priority(st[-1]):
            #       ans = ans + st.pop()
            #     st.pop(s[i])

    # Pop the remaining operators from the stack
    while st:
        ans += st.pop()

    return ans

def infix_to_prefix(expression):
    # Step 1: Reverse the input expression
    expression = expression[::-1]
    
    # Step 2: Replace parentheses in the reversed string
    expression = expression.replace('(', 'temp').replace(')', '(').replace('temp', ')')

    # Step 3: Convert the reversed infix to postfix
    postfix = infix_to_postfix(expression)
    
    # Step 4: Reverse the postfix expression to get prefix
    prefix = postfix[::-1]
    
    return prefix

# Test the function
expression = "(p+q)*(m-n)^2"
print("Infix expression:", expression)
print("Prefix expression:", infix_to_prefix(expression))     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      




# endregion








# region 9.3 STACK/QUEUE - MONOTONIC
# ----------------------------------

# 1 TODO :  (NGE) next greater element - I
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://leetcode.com/problems/next-greater-element-i/


'''
# method 1 : brute force approch
'''

https://takeuforward.org/data-structure/next-greater-element-using-stack/


https://www.youtube.com/watch?v=e7XQLtOQM3I&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=301

- monolithis stack, a stack storing elements in a certain order like increasing or decreasing


Time Complexity: O(N^2)

Space Complexity: O(N)
'''
def main_function(arr):
    res = []
    # Loop through each element in the array
    for i in range(len(arr)):
        found = False  # Flag to track if a greater element is found
        # Check all elements after arr[i]
        for j in range(i + 1, len(arr)):
            if arr[j] > arr[i]:
                res.append(arr[j])  # NGE found
                found = True
                break  # Break as we've found the NGE
        if not found:
            res.append(-1)  # If no NGE found, append -1
    
    return res

# Example usage
arr = [6, 0, 8, 1, 3]
print(main_function(arr))






# method 2 : better approch
# TC     -      
# SC     -  






 


# method 3 : optimal solution
# TC     -  O(2N)    
# SC     -  O(N) + O(N)
from typing import List

class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        n = len(nums)
        nge = [-1] * n  # Initialize the result array with -1
        st = []  # Stack to store elements for which NGE is not found

        # Traverse the list from the end to the beginning
        for i in range(n - 1, -1, -1):
            # Pop all elements from the stack that are less than or equal to nums[i]
            while st and st[-1] <= nums[i]:
                st.pop()

            # If the stack is empty, no NGE exists, otherwise set nge[i] to the top element of the stack
            if len(st) > 0:
                nge[i] = st[-1]

            # Push the current element onto the stack
            st.append(nums[i])

        return nge

if __name__ == '__main__':
    obj = Solution()
    v = [5, 7, 1, 2, 6, 0]
    res = obj.nextGreaterElements(v)
    print("The next greater elements are")
    print(*res)
    


# 2 TODO : next greater element - II
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/next-greater-element-ii/

https://www.youtube.com/watch?v=7PrncD7v9YQ&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=302

If the next greater element is not found in the right side of the element then, find it in the left side also
'''
# method 1 : brute force approch
# TC     -     O(N**2) 
# SC     -   O(N)
class Solution:
  def nextGreaterElements(self, nums):
    n = len(nums)  # Get the length of the input array
    nge = [-1] * n  # Initialize the result array with -1, meaning no NGE found yet
    st = []  # Initialize an empty stack to keep track of elements for which NGE is not found

    for i in range(n - 1, -1, -1):  
      for j in range(i+ 1,i + n - 1, 1):
        index = j % n
        if nums[index] > nums[i]:
          nge[i] = nums[index]
          break
    return nge  

if __name__ == '__main__':
  obj = Solution()
  v = [5, 7, 1, 2, 6, 0]
  res = obj.nextGreaterElements(v)
  print("The next greater elements are")
  print(*res)  


# method 2 : better approch
# TC     -      O(4N)
# SC     -     O(2N)
class Solution:
  def nextGreaterElements(self, nums: List[int]) -> List[int]:
    n = len(nums)  # Get the length of the input array
    nge = [-1] * n  # Initialize the result array with -1, meaning no NGE found yet
    st = []  # Initialize an empty stack to keep track of elements for which NGE is not found

    # Traverse the array twice (2 * n times) to simulate the circular nature of the problem
    for i in range(2 * n - 1, -1, -1):  # Traverse from end to start, simulating the circular array
        # The key trick here is to use `i % n` to ensure the index wraps around when `i` exceeds `n - 1`
        while st and st[-1] <= nums[i % n]:  # While the stack is not empty and the element at the top of the stack is less than or equal to the current element
            st.pop()  # Pop elements from the stack that cannot be the Next Greater Element

        # If we are in the first pass (i < n), we want to record the NGE for the element at index `i % n`
        if i < n:
            if st:  # If the stack is not empty, the NGE is the top of the stack
                nge[i % n] = st[-1]  # Assign the NGE to the corresponding index in the result array

        # Push the current element to the stack (whether it was an NGE for an element or not)
        st.append(nums[i % n])

    return nge  # Return the result array containing the NGE for each element

if __name__ == '__main__':
    obj = Solution()
    v = [5, 7, 1, 2, 6, 0]
    res = obj.nextGreaterElements(v)
    print("The next greater elements are")
    print(*res)  

# method 3 : optimal solution
# TC     -      
# SC     -      


# 3 TODO : next smaller element
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://www.interviewbit.com/problems/nearest-smaller-element/



'''
# method 1 : brute force approch
'''
Time Complexity (TC): O(n^2), as for each element, we might need to check all subsequent elements.
Space Complexity (SC): O(n), for storing the result array.
'''
def next_smaller_element_brute(arr):
    n = len(arr)
    result = [-1] * n  # Initialize the result list with -1

    for i in range(n):
        for j in range(i + 1, n):
            if arr[j] < arr[i]:
                result[i] = arr[j]
                break  # Found the next smaller element, no need to check further
    
    return result

# Example usage:
arr = [4, 5, 2, 10, 8]
print("Next Smaller Elements (Brute Force):", next_smaller_element_brute(arr))


# method 2 : better approch
'''
Time Complexity (TC): O(n), because each element is pushed and popped from the stack at most once.
Space Complexity (SC): O(n), for storing the result array and the stack.
'''
def next_smaller_element_better(arr):
    n = len(arr)
    result = [-1] * n  # Initialize the result list with -1
    stack = []  # Stack to store indices of the elements

    for i in range(n):
        # Pop from the stack until we find a smaller element or the stack is empty
        while stack and arr[stack[-1]] > arr[i]:
            index = stack.pop()
            result[index] = arr[i]

        # Push the current index onto the stack
        stack.append(i)

    return result

# Example usage:
arr = [4, 5, 2, 10, 8]
print("Next Smaller Elements (Better):", next_smaller_element_better(arr))


# method 3 : optimal solution
'''
Time Complexity (TC): O(n), as each element is pushed and popped from the stack at most once.
Space Complexity (SC): O(n), for storing the result array and the stack.
'''
def next_smaller_element_optimal(arr):
    n = len(arr)
    result = [-1] * n  # Initialize the result list with -1
    stack = []  # Stack to store indices of the elements

    for i in range(n):
        # Pop from the stack until we find a smaller element or the stack is empty
        while stack and arr[stack[-1]] > arr[i]:
            index = stack.pop()
            result[index] = arr[i]

        # Push the current index onto the stack
        stack.append(i)

    return result

# Example usage:
arr = [4, 5, 2, 10, 8]
print("Next Smaller Elements (Optimal):", next_smaller_element_optimal(arr))


# 4 TODO : number of NGEs to the right
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://bit.ly/3Np2R2H




'''
# method 1 : brute force approch
'''
Time Complexity (TC): O(n^2), because for each element, we compare it with all subsequent elements.
Space Complexity (SC): O(n), for the result array.
''' 
def count_nges_brute(arr):
    n = len(arr)
    result = [0] * n  # Initialize the result array with 0s

    for i in range(n):
        count = 0
        for j in range(i + 1, n):
            if arr[j] > arr[i]:
                count += 1
        result[i] = count

    return result

# Example usage:
arr = [4, 5, 2, 10, 8]
print("Number of NGEs (Brute Force):", count_nges_brute(arr))


# method 2 : better approch
'''
Time Complexity (TC): O(n), because each element is pushed and popped from the stack at most once.
Space Complexity (SC): O(n), for the result array and the stack.
'''
def count_nges_better(arr):
    n = len(arr)
    result = [0] * n  # Initialize the result array with 0s
    stack = []  # Stack to store elements
    
    # Traverse from right to left
    for i in range(n - 1, -1, -1):
        count = 0
        # Pop smaller elements from the stack
        while stack and stack[-1] <= arr[i]:
            stack.pop()
            count += 1
        result[i] = count
        stack.append(arr[i])
    
    return result

# Example usage:
arr = [4, 5, 2, 10, 8]
print("Number of NGEs (Better Approach):", count_nges_better(arr))


# method 3 : optimal solution
'''
Time Complexity (TC): O(n), because each element is pushed and popped from the stack at most once.
Space Complexity (SC): O(n), for the result array and the stack.
'''
def count_nges_optimal(arr):
    n = len(arr)
    result = [0] * n  # Initialize the result array with 0s
    stack = []  # Stack to store elements
    
    # Traverse from right to left
    for i in range(n - 1, -1, -1):
        count = 0
        # Pop smaller elements from the stack
        while stack and stack[-1] <= arr[i]:
            stack.pop()
            count += 1
        result[i] = count
        stack.append(arr[i])
    
    return result

# Example usage:
arr = [4, 5, 2, 10, 8]
print("Number of NGEs (Optimal Approach):", count_nges_optimal(arr))


# 5 TODO : trapping rainwater
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/trapping-rainwater/


https://leetcode.com/problems/trapping-rain-water/


https://www.youtube.com/watch?v=1_5VuquLbXg&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=304

'''
# method 1 : brute force approch, 
'''
Time Complexity: O(N*N) as for each index we are calculating leftMax and rightMax so it is a nested loop.

Space Complexity: O(1).
'''
from typing import List

def trap(arr: List[int]) -> int:
    n = len(arr)
    waterTrapped = 0
    for i in range(n):
        j = i
        leftMax = 0
        rightMax = 0
        while j >= 0:
            leftMax = max(leftMax, arr[j])
            j -= 1
        j = i
        while j < n:
            rightMax = max(rightMax, arr[j])
            j += 1
        waterTrapped += min(leftMax, rightMax) - arr[i]
    return waterTrapped




if __name__ == "__main__":
    arr = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
    print(f"The water that can be trapped is {trap(arr)}")


# method 2 : better approch, using prefix Max and suffix Max method 
'''
Time Complexity: O(3*N) as we are traversing through the array only once. And O(2*N) for computing prefix and suffix array.

Space Complexity: O(N)+O(N) for prefix and suffix arrays.
'''

from typing import List

def trap(arr: List[int]) -> int:
    n = len(arr)  # Length of the input array (number of bars)
    
    # Step 1: Initialize prefix and suffix arrays to store the max heights to the left and right of each element
    prefix = [0] * n  # Array to store the max height from the left to the current index
    suffix = [0] * n  # Array to store the max height from the right to the current index
    
    # Step 2: Fill the prefix array
    prefix[0] = arr[0]  # The first element is its own maximum
    for i in range(1, n):
        prefix[i] = max(prefix[i - 1], arr[i])  # For each index, store the maximum height from the left
    
    # Step 3: Fill the suffix array
    suffix[n - 1] = arr[n - 1]  # The last element is its own maximum
    for i in range(n - 2, -1, -1):
        suffix[i] = max(suffix[i + 1], arr[i])  # For each index, store the maximum height from the right
    
    # Step 4: Calculate the trapped water
    waterTrapped = 0  # Variable to accumulate the total trapped water
    for i in range(n):
        # The trapped water at position `i` is determined by the min of the prefix and suffix values minus the height at that position
        waterTrapped += min(prefix[i], suffix[i]) - arr[i]
    
    # Step 5: Return the total amount of trapped water
    return waterTrapped





if __name__ == "__main__":
    arr = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
    print(f"The water that can be trapped is {trap(arr)}")
  


# method 3 : optimal solution, two pointer approch
'''
Time Complexity: O(N) because we are using 2 pointer approach.

Space Complexity: O(1) because we are not using anything extra.

'''
from typing import List


def trap(height: List[int]) -> int:
    n = len(height)  # Get the length of the input array (number of bars)
    
    left = 0  # Initialize the left pointer at the start
    right = n - 1  # Initialize the right pointer at the end
    res = 0  # Initialize the variable to store the result (total trapped water)
    
    maxLeft = 0  # Initialize the maximum height encountered from the left
    maxRight = 0  # Initialize the maximum height encountered from the right
    
    # Step 1: Loop through the array with two pointers, left and right
    while left <= right:
        # Step 2: Compare the heights at the left and right pointers
        if height[left] <= height[right]:
            # Step 3: If height[left] is less than or equal to height[right]
            if height[left] >= maxLeft:
                maxLeft = height[left]  # Update maxLeft if current left height is higher than maxLeft
            else:
                # If height[left] is lower than maxLeft, calculate the trapped water at left position
                res += maxLeft - height[left]
            left += 1  # Move the left pointer to the right
        else:
            # Step 4: If height[right] is less than height[left]
            if height[right] >= maxRight:
                maxRight = height[right]  # Update maxRight if current right height is higher than maxRight
            else:
                # If height[right] is lower than maxRight, calculate the trapped water at right position
                res += maxRight - height[right]
            right -= 1  # Move the right pointer to the left

    return res  # Return the total trapped water





if __name__ == "__main__":
    arr = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
    print(f"The water that can be trapped is {trap(arr)}")    

# â­â­â­ Patteren change
# ğŸ‘‰ğŸ‘‰ğŸ‘‰ previous smaller element 
https://www.youtube.com/watch?v=zMdbdGJNlh4&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=303

# 6 TODO : sum of subarray minimum
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/sum-of-subarray-minimums/


https://www.youtube.com/watch?v=v0e8p9JCgRc&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=305
'''
# method 1 : brute force approch
# TC     -      O(N**2)
# SC     -O(1)
def main_function(arr):
    sum = 0
    mod = 10**9 + 7
    for i in range(len(arr) - 1):
        mini = arr[i]  # Start with the current element as the minimum
        for j in range(i + 1, len(arr)):  # Start from i + 1 to compare remaining elements
            mini = min(mini, arr[j])  # Find the minimum of the current mini and arr[j]
            sum = (sum + mini) % mod  # Add to the sum, keeping it within the modulus
    return sum


arr = [3, 1, 2, 4]
print(main_function(arr))


# method 2 : better approch
# TC     -      O(5N)
# SC     -  O(5N)
def findPSE(arr):
    # PSE: Previous Smaller Element
    n = len(arr)
    pse = [-1] * n
    stack = []
    
    for i in range(n):
        while stack and arr[stack[-1]] >= arr[i]:
            stack.pop()
        
        if stack:
            pse[i] = stack[-1]
        
        stack.append(i)
    
    return pse

def findNSE(arr):
    # NSE: Next Smaller Element
    n = len(arr)
    nse = [n] * n
    stack = []
    
    for i in range(n - 1, -1, -1):
        while stack and arr[stack[-1]] >= arr[i]:
            stack.pop()
        
        if stack:
            nse[i] = stack[-1]
        
        stack.append(i)
    
    return nse

def main_function(arr):
    nse = findNSE(arr)  # Next Smaller Element indices
    pse = findPSE(arr)  # Previous Smaller Element indices
    total = 0
    mod = 10**9 + 7
    
    # Loop over each element of the array
    for i in range(len(arr)):
        left = i - pse[i]  # Number of subarrays to the left of i where arr[i] is the minimum
        right = nse[i] - i  # Number of subarrays to the right of i where arr[i] is the minimum
        # Add the contribution of arr[i] to the total
        total = (total + (right * left * arr[i]) % mod) % mod
    
    return total

# Example array
arr = [3, 1, 2, 4]
print(main_function(arr))
   


# method 3 : optimal solution
# TC     -      
# SC     -      


# 7 TODO : asteriod collision
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://leetcode.com/problems/asteroid-collision/


'''
# method 1 : brute force approch
# TC     -      O(2N)
# SC     -  O(N)   
def asteroidCollision(asteroids):
    stack = []

    for asteroid in asteroids:
        # If the current asteroid is moving left (negative), check for collision with stack
        while stack and asteroid < 0 and stack[-1] > 0:
            # There's a collision between the current asteroid and the top of the stack
            if abs(asteroid) > abs(stack[-1]):
                # The current asteroid destroys the one on the stack
                stack.pop()
                continue
            elif abs(asteroid) == abs(stack[-1]):
                # Both asteroids destroy each other
                stack.pop()
            # If abs(asteroid) < abs(stack[-1]), the current asteroid is destroyed
            break
        else:
            # No collision or asteroid is moving right, just add it to the stack
            stack.append(asteroid)

    return stack

# Example usage
asteroids = [5, 10, -5]
print(asteroidCollision(asteroids))  # Output: [5, 10]


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 8 TODO : sum of subarray ranges
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/sum-of-subarray-ranges/

https://www.youtube.com/watch?v=gIrMptNPf5M&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=306

'''

# method 1 : brute force approch
# TC     -      O(N**2)
# SC     -  O(1)
def main_function(arr):
    sum = 0
    n = len(arr)
    
    # Outer loop to select the starting element of the subarray
    for i in range(n - 1):
        largest = arr[i]
        smallest = arr[i]
        
        # Inner loop to consider all elements after arr[i]
        for j in range(i + 1, n):
            # Update the largest and smallest elements in the current subarray
            largest = max(largest, arr[j])
            smallest = min(smallest, arr[j])
            
            # Add the difference between the largest and smallest elements to sum
            sum += (largest - smallest)
    
    return sum

# Example array
arr = [1, 4, 3, 2]
print(main_function(arr))
   


# method 2 : better approch, sum of subarray maximums - sum of sub array minimums
# TC     -      O(N)
# SC     -     O(N)
# def sumSubarrayRanges(arr):
#     mod = 10**9 + 7  # To handle large numbers, we will use modulo operation to prevent overflow
#     n = len(arr)  # Length of the input array
    
#     # Helper function to calculate the sum of subarray maximums or minimums
#     def calculateSum(arr, isMax):
#         stack = []  # Stack to store indices
#         total_sum = 0  # Variable to accumulate the result
        
#         # Loop through each element in the array
#         for i in range(n):
#             # For maximums, we want elements in the stack to be in decreasing order,
#             # For minimums, we want elements in the stack to be in increasing order
#             while stack and (arr[stack[-1]] < arr[i] if isMax else arr[stack[-1]] > arr[i]):
#                 idx = stack.pop()  # Pop the element at the top of the stack
                
#                 # Calculate the previous index in the stack (or -1 if stack is empty)
#                 prev_idx = stack[-1] if stack else -1
                
#                 # Add the contribution of this element to the total sum:
#                 # The contribution of the element at arr[idx] is calculated by:
#                 # (arr[idx] * (i - idx) * (idx - prev_idx)) % mod
#                 # Where:
#                 #   (i - idx) -> The number of subarrays where arr[idx] is the maximum (or minimum).
#                 #   (idx - prev_idx) -> The number of subarrays that end at arr[idx] and have arr[idx] as the maximum (or minimum).
#                 total_sum += (arr[idx] * (i - idx) * (idx - prev_idx)) % mod
                
#             stack.append(i)  # Push the current index onto the stack
        
#         # Handle the remaining elements in the stack (those that didn't have a larger or smaller element on the right)
#         while stack:
#             idx = stack.pop()
#             prev_idx = stack[-1] if stack else -1
#             total_sum += (arr[idx] * (n - idx) * (idx - prev_idx)) % mod
        
#         return total_sum % mod  # Return the final result after applying modulo
    
#     # Calculate sum of subarray maximums
#     sum_max = calculateSum(arr, True)  # True indicates we want the maximums
    
#     # Calculate sum of subarray minimums
#     sum_min = calculateSum(arr, False)  # False indicates we want the minimums
    
#     # The result is the difference between sum of maximums and sum of minimums
#     return (sum_max - sum_min) % mod

# # Example usage
# arr = [1, 3, 2, 4]
# print(sumSubarrayRanges(arr))  # Output will be the sum of subarray ranges

def sumSubarrayMaximums(arr):
    mod = 10**9 + 7  # To handle large numbers and avoid overflow
    n = len(arr)
    stack = []  # Stack to store indices of elements
    total_sum = 0  # Variable to accumulate the sum of subarray maximums
    
    # Loop through each element in the array
    for i in range(n):
        # For maximums, we want elements in the stack to be in decreasing order
        while stack and arr[stack[-1]] < arr[i]:
            idx = stack.pop()  # Pop the element at the top of the stack
            
            prev_idx = stack[-1] if stack else -1  # Previous index in the stack or -1 if empty
            total_sum += (arr[idx] * (i - idx) * (idx - prev_idx)) % mod  # Add the contribution of this element to the sum
            
        stack.append(i)  # Push the current index onto the stack
    
    # Handle remaining elements in the stack that didn't have a larger element to their right
    while stack:
        idx = stack.pop()
        prev_idx = stack[-1] if stack else -1
        total_sum += (arr[idx] * (n - idx) * (idx - prev_idx)) % mod  # Add the contribution of this element
    
    return total_sum % mod  # Return the result modulo mod

def sumSubarrayMinimums(arr):
    mod = 10**9 + 7  # To handle large numbers and avoid overflow
    n = len(arr)
    stack = []  # Stack to store indices of elements
    total_sum = 0  # Variable to accumulate the sum of subarray minimums
    
    # Loop through each element in the array
    for i in range(n):
        # For minimums, we want elements in the stack to be in increasing order
        while stack and arr[stack[-1]] > arr[i]:
            idx = stack.pop()  # Pop the element at the top of the stack
            
            prev_idx = stack[-1] if stack else -1  # Previous index in the stack or -1 if empty
            total_sum += (arr[idx] * (i - idx) * (idx - prev_idx)) % mod  # Add the contribution of this element to the sum
            
        stack.append(i)  # Push the current index onto the stack
    
    # Handle remaining elements in the stack that didn't have a smaller element to their right
    while stack:
        idx = stack.pop()
        prev_idx = stack[-1] if stack else -1
        total_sum += (arr[idx] * (n - idx) * (idx - prev_idx)) % mod  # Add the contribution of this element
    
    return total_sum % mod  # Return the result modulo mod

def sumSubarrayRanges(arr):
    # Calculate sum of subarray maximums and minimums
    sum_max = sumSubarrayMaximums(arr)  # Sum of maximums
    sum_min = sumSubarrayMinimums(arr)  # Sum of minimums
    
    # The final result is the difference between the sum of maximums and sum of minimums
    return (sum_max - sum_min) % (10**9 + 7)

# Example usage
arr = [1, 3, 2, 4]
print(sumSubarrayRanges(arr))  # Output will be the sum of subarray ranges



# method 3 : optimal solution
# TC     -      
# SC     -      


# 9 TODO : remove k digits
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/remove-k-digits/

https://www.youtube.com/watch?v=jmbuRzYPGrg&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=310
'''
# method 1 : brute force approch
'''
STep 1 : keep smaller digits at the start

Step 2 : get rid of larger ones
'''
# TC     -      
# SC     -     
def removeKdigits(num: str, k: int) -> str:
    stack = []  # Stack to keep track of digits
    for digit in num:
        # While we have digits in the stack and the current digit is smaller than the stack's top
        while k > 0 and stack and stack[-1] > digit:
            stack.pop()  # Pop the larger digit
            k -= 1  # Decrease k since we removed a digit
        stack.append(digit)  # Push the current digit to the stack
    
    # If k is still greater than 0, pop the remaining digits from the end
    while k > 0:
        stack.pop()
        k -= 1
    
    # Join the digits in the stack and remove leading zeros
    result = ''.join(stack).lstrip('0')
    
    # If the result is empty, return "0" (in case we removed all digits)
    return result if result else "0"

# Example usage:
num = "1432219"
k = 3
print(removeKdigits(num, k))  # Output: "1219"



# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 10 TODO :  largest rectangle in a histogram
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/area-of-largest-rectangle-in-histogram/


https://leetcode.com/problems/largest-rectangle-in-histogram/


https://www.youtube.com/watch?v=Bzat9vgD0fs&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=308
'''
# method 1 : brute force approch
# TC     -      O(5N)
# SC     - O(4N)  
def largestRectangleArea(heights):
    n = len(heights)
    
    # Step 1: Find Previous Smaller Element (PSE)
    pse = [-1] * n
    stack = []
    for i in range(n):
        while stack and heights[stack[-1]] >= heights[i]:
            stack.pop()
        if stack:
            pse[i] = stack[-1]
        stack.append(i)
    
    # Step 2: Find Next Smaller Element (NSE)
    nse = [n] * n
    stack = []
    for i in range(n - 1, -1, -1):
        while stack and heights[stack[-1]] >= heights[i]:
            stack.pop()
        if stack:
            nse[i] = stack[-1]
        stack.append(i)
    
    # Step 3: Calculate the Maximum Area
    max_area = 0
    for i in range(n):
        width = nse[i] - pse[i] - 1
        area = heights[i] * width
        max_area = max(max_area, area)
    
    return max_area

# Example usage:
heights = [2, 1, 5, 6, 2, 3]
print(largestRectangleArea(heights))  # Output: 10
  


# method 2 : better approch
# TC     -      O(N) + O(N)
# SC     -   O(N)
def largestRectangleArea(heights):
    # Initialize variables
    n = len(heights)
    stack = []  # This will store indices of histogram bars in increasing height order
    max_area = 0  # To keep track of the maximum area
    
    # Traverse the histogram
    for i in range(n):
        # While the current bar is shorter than the bar at stack's top
        # Calculate the area for the rectangle with the height of the bar at the top of the stack
        while stack and heights[stack[-1]] > heights[i]:
            h = heights[stack.pop()]  # Height of the rectangle
            # If the stack is empty, it means the width extends from the start to the current index
            w = i if not stack else i - stack[-1] - 1  # Width of the rectangle
            max_area = max(max_area, h * w)  # Update the max_area with the area of the rectangle
        # Push the current index onto the stack
        stack.append(i)
    
    # After traversing all bars, process the remaining elements in the stack
    while stack:
        h = heights[stack.pop()]  # Height of the rectangle
        w = n if not stack else n - stack[-1] - 1  # Width of the rectangle
        max_area = max(max_area, h * w)  # Update the max_area with the area of the rectangle
    
    return max_area

# Example usage:
heights = [2, 1, 5, 6, 2, 3]
print(largestRectangleArea(heights))  # Output: 10
  


# method 3 : optimal solution
# TC     -      
# SC     -      


# 11 TODO : maximal rectangle
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://leetcode.com/problems/maximal-rectangle/

https://www.youtube.com/watch?v=ttVu6G7Ayik&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=309
'''
# method 1 : brute force approch
# TC     -      
# SC     -     
def maximalRectangle(matrix):
    # Step 1: Check if the matrix is empty. If so, return 0 as no rectangle can be formed.
    if not matrix:
        return 0
    
    # Step 2: Get the number of rows and columns in the matrix.
    rows = len(matrix)
    cols = len(matrix[0])
    
    # Step 3: Initialize a list to store heights of the histogram for each column.
    heights = [0] * cols  # This will be used to calculate the maximum area in each row's "histogram".
    
    # Step 4: Variable to store the maximum area found.
    max_area = 0

    # Step 5: Iterate through each row of the matrix to build the histogram.
    for row in range(rows):
        # Update the heights for the current row. 
        # For each column, increment the height if there's a '1' or reset to 0 if it's '0'.
        for col in range(cols):
            if matrix[row][col] == '1':  # If the cell contains '1', increase the height.
                heights[col] += 1
            else:  # If the cell contains '0', reset the height to 0.
                heights[col] = 0
        
        # Step 6: After updating the histogram, find the largest rectangle in the current "histogram".
        max_area = max(max_area, largestRectangleInHistogram(heights))
    
    # Step 7: Return the maximum rectangle area found.
    return max_area

def largestRectangleInHistogram(heights):
    # Step 1: Initialize a stack and a variable to keep track of the maximum area.
    stack = []
    max_area = 0
    n = len(heights)  # Number of columns (width of histogram)
    
    # Step 2: Iterate through the histogram (heights list).
    for i in range(n):
        # Step 3: While the stack is not empty and the current height is smaller than the height
        # at the index stored at the top of the stack, pop from the stack.
        # Calculate the area of the rectangle formed with the popped height as the smallest height.
        while stack and heights[stack[-1]] > heights[i]:
            h = heights[stack.pop()]  # The height of the rectangle
            w = i if not stack else i - stack[-1] - 1  # Width of the rectangle (distance between indices)
            max_area = max(max_area, h * w)  # Calculate the area and update the max_area if needed.
        
        # Step 4: Push the current index onto the stack.
        stack.append(i)
    
    # Step 5: After iterating through the histogram, there might still be some indices left in the stack.
    # We need to process those remaining heights to calculate the area.
    while stack:
        h = heights[stack.pop()]  # The height of the rectangle
        w = n if not stack else n - stack[-1] - 1  # Width of the rectangle (distance between indices)
        max_area = max(max_area, h * w)  # Calculate the area and update the max_area if needed.
    
    # Step 6: Return the largest rectangle area found.
    return max_area

# Example usage:
matrix = [
    ["0", "1", "1", "0"],
    ["1", "1", "1", "1"],
    ["1", "1", "1", "0"],
    ["1", "1", "0", "0"]
]

# Step 7: Call the maximalRectangle function and print the result.
print(maximalRectangle(matrix))  # Output: 6


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      



# endregion




# region 9.4 STACK/QUEUE - IMPLEMENTATION
# ---------------------------------------

# 1 TODO :  sliding window maximum
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/sliding-window-maximum/


https://leetcode.com/problems/sliding-window-maximum/


https://www.youtube.com/watch?v=NwBvene4Imo&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=312
'''
# method 1 : brute force approch
# TC     -  O(N - k) * k    
# SC     -  O(N - k)
def main_function(arr, k):
    result = []
    # Iterate over the array to consider each sliding window
    for i in range(len(arr) - k + 1):  # Ensure we don't go beyond the array length
        maxi = arr[i]  # Start with the first element of the window
        for j in range(i + 1, i + k):  # Iterate over the next k elements
            maxi = max(maxi, arr[j])  # Update the maximum of the window
        result.append(maxi)  # Add the maximum of the current window to the result
    return result

# Example usage
arr = [1, 3, -1, -3, 5, 3, 2, 1, 6]
k = 3
print(main_function(arr, k))
   


# method 2 : better approch, useing monotonic stack/dequeue
'''
Time Complexity: The algorithm runs in O(n) time, where n is the length of the array. Each element is added and removed from the deque at most once, making it very efficient.
Space Complexity: The space complexity is O(k) due to the deque storing up to k indices at any given time, where k is the window size.
'''
from collections import deque

def main_function(arr, k):
    result = []
    dq = deque()  # Deque to store indices of array elements
    
    for i in range(len(arr)):
        # Remove indices of elements that are out of the window (i.e., i - k >= dq[0])
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        
        # Remove elements from the back of deque that are smaller than the current element
        while dq and arr[dq[-1]] <= arr[i]:
            dq.pop()
        
        # Add the current element index at the back of the deque
        dq.append(i)
        
        # Start appending results to the output once we have processed at least k elements
        if i >= k - 1:
            result.append(arr[dq[0]])  # The front of the deque is the maximum for the current window
    
    return result

# Example usage
arr = [1, 3, -1, -3, 5, 3, 2, 1, 6]
k = 3
print(main_function(arr, k))  # Output: [3, 3, 5, 5, 5, 5, 6]



# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : stock span problem
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/online-stock-span/

https://www.youtube.com/watch?v=eay-zoSRkVc&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=311
'''
# method 1 : brute force approch
# TC     -      O(number of days)
# SC     -    O(total number of next calls)
def stock_span(arr):
    n = len(arr)
    span = [0] * n  # List to store the stock span values

    # Iterate through all days to calculate the span for each day
    for i in range(n):
        span[i] = 1  # Start with the span being 1 (the current day itself)
        
        # Compare the current day's price with the previous days
        for j in range(i - 1, -1, -1):  # Go backwards from the previous days
            if arr[j] <= arr[i]:  # If the price is less than or equal, increment the span
                span[i] += 1
            else:
                break  # Stop as soon as we find a price greater than arr[i]
    
    return span

# Example usage
prices = [100, 80, 60, 70, 60]
print(stock_span(prices))  # Output: [1, 1, 1, 2, 1]



# method 2 : better approch
# TC     -      O(2N)
# SC     -     O(N)
def stock_span(arr):
    n = len(arr)
    span = [0] * n  # List to store the stock span values
    stack = []  # Stack to store indices of the array elements
    
    # Loop through each day
    for i in range(n):
        # Pop elements from the stack while the price at the top of the stack is less than or equal to arr[i]
        while stack and arr[stack[-1]] <= arr[i]:
            stack.pop()
        
        # If the stack is empty, the span for day i is i + 1
        if not stack:
            span[i] = i + 1
        else:
            # The span is the difference between the current day and the last larger price
            span[i] = i - stack[-1]
        
        # Push the current day's index onto the stack
        stack.append(i)
    
    return span

# Example usage
prices = [100, 80, 60, 70, 60]
print(stock_span(prices))  # Output: [1, 1, 1, 2, 1]



# method 3 : optimal solution
# TC     -      
# SC     -      


# 3 TODO : the celebrity problem
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://leetcode.com/accounts/login/?next=/problems/find-the-celebrity/


'''
# method 1 : brute force approch
# TC     -   O(N**N) + O(N)   
# SC     -  O(2N)

def findCelebrity(matrix):
  n = len(matrix)  # Number of people
  knows_me = [0] * n  # Initialize a list of size n
  i_knows = [0] * n  # Initialize a list of size n

  # Step 1: Iterate through the matrix to count how many people know each person and how many people they know
  for i in range(n):
    for j in range(n):
      if matrix[i][j] == 1:
        knows_me[j] += 1  # Person j is known by person i
        i_knows[i] += 1   # Person i knows person j

  # Step 2: Check for the celebrity
  for i in range(n):
    if knows_me[i] == n - 1 and i_knows[i] == 0:
      return i  # Person i is the celebrity

  return -1  # No celebrity found


# Example Usage
matrix = [
    [0, 1, 0, 0],  # Person 0 knows Person 1
    [0, 0, 0, 0],  # Person 1 knows no one
    [0, 1, 0, 0],  # Person 2 knows Person 1
    [0, 1, 0, 0]   # Person 3 knows Person 1
]

celebrity = findCelebrity(matrix)

if celebrity == -1:
    print("No celebrity found")
else:
    print(f"The celebrity is Person {celebrity}")





# def findCelebrity(matrix, n):
#     # Step 1: Identify potential celebrity
#     candidate = 0
#     for i in range(1, n):
#         if matrix[candidate][i] == 1:  # candidate knows i, so candidate cannot be a celebrity
#             candidate = i  # update candidate to i

#     # Step 2: Verify if the candidate is a real celebrity
#     for i in range(n):
#         # Candidate should not know anyone else, and everyone should know the candidate
#         if i != candidate:
#             if matrix[candidate][i] == 1 or matrix[i][candidate] == 0:
#                 return -1  # Candidate cannot be a celebrity
    
#     return candidate  # Return the celebrity index if verified

# # Example Usage
# matrix = [
#     [0, 1, 0, 0],  # Person 0 knows Person 1
#     [0, 0, 0, 0],  # Person 1 knows no one
#     [0, 1, 0, 0],  # Person 2 knows Person 1
#     [0, 1, 0, 0]   # Person 3 knows Person 1
# ]
# n = 4  # Number of people in the party
# celebrity = findCelebrity(matrix, n)

# if celebrity == -1:
#     print("No celebrity found")
# else:
#     print(f"The celebrity is Person {celebrity}")
  


# method 2 : better approch, using two pointer
# TC     -      O(2N)
# SC     -   o(1)   
def findCelebrity(matrix):
    n = len(matrix)  # Number of people
    top = 0
    down = n - 1
    
    # Step 1: Narrow down to a potential celebrity
    while top < down:
        if matrix[top][down] == 1:  # top knows down, so top cannot be a celebrity
            top += 1
        elif matrix[down][top] == 1:  # down knows top, so down cannot be a celebrity
            down -= 1
        else:
            top += 1
            down -= 1
    
    # Step 2: Check if the found person is actually a celebrity
    # Now, `top` should be equal to `down`, and this is the candidate celebrity
    for i in range(n):
        if i != top:
            if matrix[top][i] == 1 or matrix[i][top] == 0:
                return -1  # If top knows someone or someone doesn't know top, not a celebrity
    
    # If the checks passed, `top` is the celebrity
    return top


# Example Usage
matrix = [
    [0, 1, 0, 0],  # Person 0 knows Person 1
    [0, 0, 0, 0],  # Person 1 knows no one
    [0, 1, 0, 0],  # Person 2 knows Person 1
    [0, 1, 0, 0]   # Person 3 knows Person 1
]

celebrity = findCelebrity(matrix)

if celebrity == -1:
    print("No celebrity found")
else:
    print(f"The celebrity is Person {celebrity}")


# method 3 : optimal solution
# TC     -      
# SC     -      


# 4 TODO : LRU (last recently used) cache (important)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/implement-lru-cache/


https://leetcode.com/problems/lru-cache/



'''
# method 1 : brute force approch
'''
Time Complexity (TC):
get: O(n) due to list removal and insertion.
put: O(n) due to list removal and insertion for both updating and evicting elements.
Space Complexity (SC): O(n), where n is the cache capacity (space for storing key-value pairs).
'''
class LRUCacheBrute:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = []  # To maintain the access order
        self.values = {}  # To store key-value pairs

    def get(self, key: int) -> int:
        if key in self.values:
            # Move the key to the front of the list to mark it as recently used
            self.cache.remove(key)
            self.cache.insert(0, key)
            return self.values[key]
        return -1

    def put(self, key: int, value: int) -> None:
        if key in self.values:
            # Update value and move it to the front
            self.values[key] = value
            self.cache.remove(key)
            self.cache.insert(0, key)
        else:
            if len(self.cache) >= self.capacity:
                # Remove the least recently used item
                lru_key = self.cache.pop()
                del self.values[lru_key]
            self.cache.insert(0, key)
            self.values[key] = value

# Example usage:
cache = LRUCacheBrute(2)
cache.put(1, 1)
cache.put(2, 2)
print(cache.get(1))  # Returns 1
cache.put(3, 3)  # Evicts key 2
print(cache.get(2))  # Returns -1 (not found)
cache.put(4, 4)  # Evicts key 1
print(cache.get(1))  # Returns -1 (not found)
print(cache.get(3))  # Returns 3
print(cache.get(4))  # Returns 4


# method 2 : better approch
'''
Time Complexity (TC):

get: O(1) for accessing and moving the element to the end.
put: O(1) for inserting, removing, and moving elements.
Space Complexity (SC): O(n), where n is the cache capacity.
'''
from collections import OrderedDict

class LRUCacheBetter:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key in self.cache:
            # Move the key to the end to mark it as recently used
            self.cache.move_to_end(key)
            return self.cache[key]
        return -1

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            # Update the value and move the key to the end
            self.cache.move_to_end(key)
        elif len(self.cache) >= self.capacity:
            # Pop the first (least recently used) item
            self.cache.popitem(last=False)
        self.cache[key] = value

# Example usage:
cache = LRUCacheBetter(2)
cache.put(1, 1)
cache.put(2, 2)
print(cache.get(1))  # Returns 1
cache.put(3, 3)  # Evicts key 2
print(cache.get(2))  # Returns -1 (not found)
cache.put(4, 4)  # Evicts key 1
print(cache.get(1))  # Returns -1 (not found)
print(cache.get(3))  # Returns 3
print(cache.get(4))  # Returns 4


# method 3 : optimal solution
'''
Time Complexity (TC):
get: O(1) for accessing the hash map and moving the node in the doubly linked list.
put: O(1) for adding, removing, and inserting nodes in the doubly linked list.
Space Complexity (SC): O(n), where n is the cache capacity, for storing the cache and the doubly linked list nodes.
'''
class Node:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUCacheOptimal:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}  # Map of key to node
        self.head = Node(0, 0)  # Dummy head
        self.tail = Node(0, 0)  # Dummy tail
        self.head.next = self.tail
        self.tail.prev = self.head

    def _remove(self, node: Node) -> None:
        prev_node = node.prev
        next_node = node.next
        prev_node.next = next_node
        next_node.prev = prev_node

    def _insert(self, node: Node) -> None:
        next_node = self.head.next
        self.head.next = node
        node.prev = self.head
        node.next = next_node
        next_node.prev = node

    def get(self, key: int) -> int:
        if key in self.cache:
            node = self.cache[key]
            self._remove(node)
            self._insert(node)
            return node.value
        return -1

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self._remove(self.cache[key])
        elif len(self.cache) >= self.capacity:
            # Evict the least recently used element (tail.prev)
            self._remove(self.tail.prev)
        node = Node(key, value)
        self.cache[key] = node
        self._insert(node)

# Example usage:
cache = LRUCacheOptimal(2)
cache.put(1, 1)
cache.put(2, 2)
print(cache.get(1))  # Returns 1
cache.put(3, 3)  # Evicts key 2
print(cache.get(2))  # Returns -1 (not found)
cache.put(4, 4)  # Evicts key 1
print(cache.get(1))  # Returns -1 (not found)
print(cache.get(3))  # Returns 3
print(cache.get(4))  # Returns 4


# 5 TODO : LFU cache
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://leetcode.com/problems/lfu-cache/




'''
# method 1 : brute force approch
'''
Time Complexity (TC):
get: O(1) for accessing the cache, but O(n) to update the access order.
put: O(n) for finding and removing the least frequently used element from the access_order list and freq dictionary.
Space Complexity (SC): O(n) for the cache, frequency dictionary, and access order list.
'''
class LFUCacheBrute:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}  # key -> value
        self.freq = {}  # key -> frequency of access
        self.access_order = []  # To keep track of keys in access order
    
    def get(self, key: int) -> int:
        if key in self.cache:
            # Update frequency and access order
            self.freq[key] += 1
            self.access_order.remove(key)
            self.access_order.append(key)
            return self.cache[key]
        return -1
    
    def put(self, key: int, value: int) -> None:
        if self.capacity == 0:
            return
        
        if key in self.cache:
            # Update the value and frequency
            self.cache[key] = value
            self.freq[key] += 1
            self.access_order.remove(key)
            self.access_order.append(key)
        else:
            if len(self.cache) >= self.capacity:
                # Evict the least frequently used element
                min_freq = min(self.freq.values())
                for key in self.access_order:
                    if self.freq[key] == min_freq:
                        del self.cache[key]
                        del self.freq[key]
                        self.access_order.remove(key)
                        break
            # Insert the new key
            self.cache[key] = value
            self.freq[key] = 1
            self.access_order.append(key)

# Example usage:
cache = LFUCacheBrute(2)
cache.put(1, 1)
cache.put(2, 2)
print(cache.get(1))  # Returns 1
cache.put(3, 3)  # Evicts key 2
print(cache.get(2))  # Returns -1 (not found)
print(cache.get(3))  # Returns 3


# method 2 : better approch
'''
Time Complexity (TC):

get: O(1) for accessing and updating the frequency.
put: O(1) for updating or inserting the key in the cache and updating the frequency.
Space Complexity (SC): O(n), where n is the cache capacity, for storing the cache and frequency dictionaries.
'''
from collections import OrderedDict, defaultdict

class LFUCacheBetter:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}  # key -> value
        self.freq = defaultdict(OrderedDict)  # frequency -> OrderedDict of key-value pairs
        self.min_freq = 0  # The current least frequency

    def _update_freq(self, key: int) -> None:
        # Get the current frequency of the key
        freq = self.cache[key][1]
        # Remove the key from the current frequency bucket
        del self.freq[freq][key]
        
        # If the current frequency bucket is empty, update the min_freq
        if not self.freq[freq]:
            if freq == self.min_freq:
                self.min_freq += 1
        
        # Increment the frequency and add the key to the new frequency bucket
        new_freq = freq + 1
        self.cache[key] = (self.cache[key][0], new_freq)
        self.freq[new_freq][key] = self.cache[key][0]

    def get(self, key: int) -> int:
        if key in self.cache:
            # Update the frequency of the key
            self._update_freq(key)
            return self.cache[key][0]
        return -1
    
    def put(self, key: int, value: int) -> None:
        if self.capacity == 0:
            return

        if key in self.cache:
            # Update the value and frequency if the key exists
            self.cache[key] = (value, self.cache[key][1])
            self._update_freq(key)
        else:
            if len(self.cache) >= self.capacity:
                # Evict the least frequently used element
                lfu_key, lfu_value = self.freq[self.min_freq].popitem(last=False)
                del self.cache[lfu_key]
            # Insert the new key-value pair
            self.cache[key] = (value, 1)
            self.freq[1][key] = value
            self.min_freq = 1

# Example usage:
cache = LFUCacheBetter(2)
cache.put(1, 1)
cache.put(2, 2)
print(cache.get(1))  # Returns 1
cache.put(3, 3)  # Evicts key 2
print(cache.get(2))  # Returns -1 (not found)
print(cache.get(3))  # Returns 3


# method 3 : optimal solution
'''
Time Complexity (TC):

get: O(1) for accessing and updating frequency.
put: O(1) for inserting or updating the key-value pair and updating the frequency.
Space Complexity (SC): O(n), where n is the cache capacity, for storing the cache and frequency maps.
'''
class Node:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.freq = 1
        self.prev = None
        self.next = None

class LFUCacheOptimal:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}  # key -> Node
        self.freq_map = defaultdict(OrderedDict)  # frequency -> OrderedDict of key-value pairs
        self.min_freq = 1

    def _remove(self, node: Node) -> None:
        self.freq_map[node.freq].pop(node.key)
        if not self.freq_map[node.freq]:
            del self.freq_map[node.freq]

    def _insert(self, node: Node) -> None:
        self.freq_map[node.freq][node.key] = node.value

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        node = self.cache[key]
        self._remove(node)
        node.freq += 1
        self._insert(node)
        return node.value

    def put(self, key: int, value: int) -> None:
        if self.capacity == 0:
            return

        if key in self.cache:
            node = self.cache[key]
            node.value = value
            self._remove(node)
            node.freq += 1
            self._insert(node)
        else:
            if len(self.cache) >= self.capacity:
                # Evict the least frequently used element
                lfu_key, lfu_value = self.freq_map[self.min_freq].popitem(last=False)
                del self.cache[lfu_key]
            node = Node(key, value)
            self.cache[key] = node
            self._insert(node)
            self.min_freq = 1

# Example usage:
cache = LFUCacheOptimal(2)
cache.put(1, 1)
cache.put(2, 2)
print(cache.get(1))  # Returns 1
cache.put(3, 3)  # Evicts key 2
print(cache.get(2))  # Returns -1 (not found)
print(cache.get(3))  # Returns 3


# endregion





# region 10.1 SLIDING WINDOW/TWO POINTER - MEDIUM
# -----------------------------------------------
'''
http://youtube.com/watch?v=9kdHxplyl5I&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=272

'''
# 1 TODO :  largest substring without repeating characters
"""
using hashing,
using sliding window,
"""
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

https://takeuforward.org/data-structure/length-of-longest-substring-without-any-repeating-character/

https://www.youtube.com/watch?v=-zSxTJkcdAo&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=274

https://leetcode.com/problems/longest-substring-without-repeating-characters/


'''
# method 1 : brute force approch
'''
Time Complexity: O(N^2)

Space Complexity:  

ord("a") -> 97

'''
def main_function(arr):
  max_len = 0  # Keep track of longest substring without repeating chars

  for i in range(len(arr)):
    seen = [0] * 256  # Track characters we've seen in this substring
    length = 0
    for j in range(i, len(arr)):
      char_code = ord(arr[j])  # Get ASCII code of character
      # If character is already seen, stop this substring
      if seen[char_code] == 1:
        break

      # Mark character as seen and update substring length
      seen[char_code] = 1
      length = j - i + 1

      # Update max length if needed
      if length > max_len:
        max_len = length

  return max_len

arr = "cadbzabcd"
print(main_function(arr))  # Output: 5



# method 2 : better approch
'''
Time Complexity: O( N ) 

Space Complexity: O(256) 

'''
def main_function(arr):
  l = 0                # Start of current substring window
  r = 0                # End of current substring window
  last_seen = [-1] * 256  # Stores last position of each character (ASCII)
  max_len = 0          # Longest substring length without repeats found so far
  
  while r < len(arr):
    char_pos = ord(arr[r])  # Get ASCII code of current character

    # If this character was seen before and inside the current window,
    # move the start pointer just after its last position to avoid duplicates
    if last_seen[char_pos] >= l:
      l = last_seen[char_pos] + 1

    # Update the last seen position of current character
    last_seen[char_pos] = r

    # Calculate current window length and update max length if bigger
    current_len = r - l + 1
    if current_len > max_len:
      max_len = current_len

    r += 1  # Move end pointer forward

  return max_len

arr = "cadbzabcd"
print(main_function(arr))  # Output: 5


# method 3 : optimal solution
'''
Time Complexity: O( N )

Space Complexity: O(N) where N represents the size of HashSet where we are storing our elements
'''


# 2 TODO : max consecutive ones - III
# longest subarray with atmost k 0s
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

https://www.youtube.com/watch?v=3E4JBHSLpYk&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=275


https://leetcode.com/problems/max-consecutive-ones-iii/


'''
# method 1 : brute force approch
'''
 TC     -      O(N^2) nearly 
 SC     -     O(1)
'''
def main_function(arr,k):
  max_len = 0
  for i in range(len(arr)):
    # hash_arr = [0] * 256  # Assuming ASCII characters
    zeros = 0
    for j in range(i, len(arr)):
      if arr[j] == 0:
        zeros +=1 
      if zeros <= k:
        length = j -i + 1 
        max_len = max(length, max_len)
      else:
        break
      

  return max_len

arr = [1,1,1,0,0,0,1,1,1,1,0]
k=2
print(main_function(arr,k))

# method 2 : better approch
# TC     -      O2N) nearly 
# SC     -     O(1)
def main_function(nums,k):
  l = 0
  r = 0
  zeros = 0
  max_len = 0
  
  while r < len(nums):
    if nums[r] == 0:
      zeros +=1 
    while zeros > k:
      if nums[l] == 0:
        zeros -=1 
      l +=1 
    if zeros <= k:
      length = r-l+1 
      max_len= max(max_len, length)
    r +=1

  return max_len

arr = [1,1,1,0,0,0,1,1,1,1,0]
k=2
print(main_function(arr,k))



# method 3 : optimal solution
# TC     -      O(N)
# SC     -   O(1)      
def main_function(nums,k):
  l = 0
  r = 0
  zeros = 0
  max_len = 0
  
  while r < len(nums):
    if nums[r] == 0:
      zeros +=1 
    if zeros > k:
      if nums[l] == 0:
        zeros -=1 
      l +=1 
    if zeros <= k:
      length = r-l+1 
      max_len= max(max_len, length)
    r +=1

  return max_len

arr = [1,1,1,0,0,0,1,1,1,1,0]
k=2
print(main_function(arr,k))



# 3 TODO : fruit into baskets
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://bit.ly/3D6d94w

maxlength suarray with atmost 2 types of numbers

https://www.youtube.com/watch?v=e3bs0uA1NhQ&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=276
'''
# method 1 : brute force approch
# TC     -      O(N^2)
# SC     -   O(3)  
def main_function(arr,k):
  max_len = 0
  for i in range(len(arr)):
    # hash_arr = [0] * 256  # Assuming ASCII characters
    st = set()
    for j in range(i, len(arr)):
      st.add(arr[j])
      if len(st) <= 2:
        length = j -i + 1 
        max_len = max(length, max_len)
      else:
        break
      

  return max_len

arr = [3,3,3,1,2,1,1,2,3,3,4]
k=2
print(main_function(arr,k))


# method 2 : better approch
# TC     -     O(2N) 
# SC     -    O(1)
def main_function(arr, k):
    l = 0
    r = 0
    mpp = {}  # Initialize mpp as an empty dictionary
    max_len = 0
    
    while r < len(arr):
        # Increment the count of the current element in the window
        mpp[arr[r]] = mpp.get(arr[r], 0) + 1
        
        # If the number of distinct elements exceeds k, shrink the window
        while len(mpp) > k:
            mpp[arr[l]] -= 1
            if mpp[arr[l]] == 0:
                del mpp[arr[l]]  # Remove the element from the dictionary if its count becomes 0
            l += 1  # Shrink the window from the left
        
        # Update max_len when the condition is satisfied
        if len(mpp) <= k:
            length = r - l + 1
            max_len = max(max_len, length)
        
        # Expand the window by moving the right pointer
        r += 1
    
    return max_len

arr = [3, 3, 3, 1, 2, 1, 1, 2, 3, 3, 4]
k = 2
print(main_function(arr, k))
     


# method 3 : optimal solution
# TC     -      O(N)
# SC     -      O(1)
def main_function(arr, k):
    l = 0
    r = 0
    mpp = {}  # Initialize mpp as an empty dictionary
    max_len = 0
    
    while r < len(arr):
        # Increment the count of the current element in the window
        mpp[arr[r]] = mpp.get(arr[r], 0) + 1
        
        # If the number of distinct elements exceeds k, shrink the window
        if len(mpp) > k:
            mpp[arr[l]] -= 1
            if mpp[arr[l]] == 0:
                del mpp[arr[l]]  # Remove the element from the dictionary if its count becomes 0
            l += 1  # Shrink the window from the left
        
        # Update max_len when the condition is satisfied
        if len(mpp) <= k:
            length = r - l + 1
            max_len = max(max_len, length)
        
        # Expand the window by moving the right pointer
        r += 1
    
    return max_len

arr = [3, 3, 3, 1, 2, 1, 1, 2, 3, 3, 4]
k = 2
print(main_function(arr, k))



# 4 TODO : longest repeating character replacement
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/longest-repeating-character-replacement/


https://www.youtube.com/watch?v=_eNhaDCr6P0&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=279
'''
# method 1 : brute force approch
# TC     -      O(N62)
# SC     -  O(26)   
def main_function(arr, k):
    max_len = 0
    for i in range(len(arr)):
        hash_arr = [0] * 26  # Array to track frequencies of characters (26 letters of the alphabet)
        maxf = 0  # Maximum frequency of a character in the current window
        for j in range(i, len(arr)):
            index = ord(arr[j]) - ord('A')  # Map character to its index (A -> 0, B -> 1, ..., Z -> 25)
            hash_arr[index] += 1
            maxf = max(maxf, hash_arr[index])  # Update max frequency of any character in the window
            
            changes = (j - i + 1) - maxf  # Number of changes needed to make all characters the same
            if changes <= k:  # If we can make the changes within the limit k
                max_len = max(max_len, j - i + 1)  # Update the max length
            else:
                break  # If changes exceed k, no need to continue expanding the window

    return max_len

arr = "AABABBA"
k = 2
print(main_function(arr, k))



# method 2 : better approch





# method 3 : optimal solution
# TC     -      
# SC     -  
## using map 
# TC     -      O(N)
# SC     -  O(1)   
# def main_function(s, k):
#     l = 0
#     r = 0
#     mpp = {}  # Initialize mpp as an empty dictionary
#     max_len = 0
#     maxf = 0
    
#     while r < len(s):
#         # Increment the count of the current element in the window
#         mpp[s[r]] = mpp.get(s[r], 0) + 1
#         maxf = max(maxf, mpp[s[r]])  # Track the max frequency of any character in the window
        
#         # If the number of changes exceeds k, shrink the window
#         if (r - l + 1) - maxf > k:
#             mpp[s[l]] -= 1  # Decrease the count of the character at the left of the window
#             if mpp[s[l]] == 0:
#                 del mpp[s[l]]  # Remove the character from the map if its count becomes 0
#             l += 1  # Shrink the window from the left
        
#         # Update max_len when the condition is satisfied
#         if (r - l + 1) - maxf <= k:
#             max_len = max(max_len, r - l + 1)
        
#         # Expand the window by moving the right pointer
#         r += 1
    
#     return max_len

# arr = "AABABBA"
# k = 2
# print(main_function(arr, k))

# using hash array 
def main_function(s, k):
    l = 0
    r = 0
    hash = [0] * 26  # Array to track frequencies of characters (26 letters of the alphabet)
    max_len = 0
    maxf = 0
    
    while r < len(s):
        # Increment the count of the current character in the window
        hash[ord(s[r]) - ord('A')] += 1
        maxf = max(maxf, hash[ord(s[r]) - ord('A')])  # Track the max frequency of any character in the window
        
        # If the number of changes exceeds k, shrink the window
        if (r - l + 1) - maxf > k:
            hash[ord(s[l]) - ord('A')] -= 1  # Decrease the count of the character at the left of the window
            l += 1  # Shrink the window from the left
        
        # Update max_len when the condition is satisfied
        if (r - l + 1) - maxf <= k:
            max_len = max(max_len, r - l + 1)
        
        # Expand the window by moving the right pointer
        r += 1
    
    return max_len    

arr = "AABABBA"
k = 2
print(main_function(arr, k))



# 5 TODO : binary subarray with sum
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://leetcode.com/problems/binary-subarrays-with-sum/


https://www.youtube.com/watch?v=XnMdNUkX6VM&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=280
'''
# method 1 : brute force approch
# TC     -      
# SC     -     
def longest_subarray_bruteforce(arr, k):
    n = len(arr)
    max_len = 0
    for i in range(n):
        current_sum = 0
        for j in range(i, n):
            current_sum += arr[j]
            if current_sum = k:
                max_len = max(max_len, j - i + 1)
            else:
                break
    return max_len

arr = [2, 5, 1, 7, 10]
k = 14
print(longest_subarray_bruteforce(arr, k))  

# method 2 : better approch
# TC     -      
# SC     -     
def main_function(arr, k):
    n = len(arr)
    l = 0  # left pointer
    r = 0  # right pointer
    sum = 0
    max_len = 0

    while r < n:
      sum = sum  + arr[r]
      while sum > k:
        sum = sum - arr[l]
        l +=1
      
      
      if sum <= k:
        max_len = max(max_len, r-l+1)
      r +=1
    
    return max_len

# Example usage
arr = [2, 5, 1, 7, 10]
k = 14
print(main_function(arr, k))  

# slight better approch
def main_function(arr, k):
    n = len(arr)
    l = 0  # left pointer
    r = 0  # right pointer
    sum = 0
    max_len = 0

    while r < n:
      sum = sum  + arr[r]
      if sum > k:
        sum = sum - arr[l]
        l +=1
      
      
      if sum <= k:
        max_len = max(max_len, r-l+1)
      r +=1
    
    return max_len

# Example usage
arr = [2, 5, 1, 7, 10]
k = 14
print(main_function(arr, k))  


# method 3 : optimal solution
# TC     -      O(2*2*N)
# SC     -     O(1)
def main_function(nums, goal):
    if goal <= 0:
      return 0
    n = len(arr)
    l = 0  # left pointer
    r = 0  # right pointer
    sum = 0
    count = 0

    while r < n:
      sum = sum  + nums[r]
      while sum > goal:
        sum = sum - nums[l]
        l +=1
      count = count + (r-l+1)
      r +=1
    
    return count

# Example usage
arr = [1,0,0,1,1,0]
k = 2
print(main_function(arr, k) - main_function(arr, k-1)) 


# 6 TODO : count number of nice subarrays
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/count-number-of-nice-subarrays/


https://www.youtube.com/watch?v=j_QOv9OT9Og&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=281
'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -   
def main_function(nums, goal):
    if goal <= 0:
      return 0
    n = len(arr)
    l = 0  # left pointer
    r = 0  # right pointer
    sum = 0
    count = 0

    while r < n:
      sum = sum  + (nums[r]%2)
      while sum > goal:
        sum = sum - (nums[l]%2)
        l +=1
      count = count + (r-l+1)
      r +=1
    
    return count

# Example usage
arr = [1,1,2,1,1]
k = 3
print(main_function(arr, k) - main_function(arr, k-1))   


# 7 TODO : number of substring containg all three characters
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/


https://www.youtube.com/watch?v=xtqN4qlgr8s&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=278
'''
# method 1 : brute force approch
# TC     -      O(N^2)
# SC     -  O(1)   
def main_function(arr):
  count = 0
  for i in range(len(arr)):
    hash_arr = [0] * 3
    for j in range(i, len(arr)):
      hash_arr[ord(arr[j]) - ord('a')] = 1  
      
      if hash_arr[0] + hash_arr[1] + hash_arr[2] == 3:  
          # count = count + 1
          count = count + (len(arr) - j)  # optimized
          break  # optimized
  return count

arr = "bbacba"
print(main_function(arr))



# method 2 : better approch
# TC     -     O(N) 
# SC     -     O(1)
def main_function(arr):
    count = 0
    lastSeen = [-1, -1, -1]  # Initialize lastSeen for 'a', 'b', and 'c' as -1
    
    for i in range(len(arr)):
        lastSeen[ord(arr[i]) - ord('a')] = i  # Update lastSeen for the current character
        
        # Check if all three characters have been seen
        if lastSeen[0] != -1 and lastSeen[1] != -1 and lastSeen[2] != -1:
            # The number of valid substrings that end at index i
            count += 1 + min(lastSeen[0], lastSeen[1], lastSeen[2])
    
    return count

arr = "bbacba"
print(main_function(arr))


# method 3 : optimal solution
# TC     -      
# SC     -      


# 8 TODO : maximun point you can obtain from cards
"""
using for loop
"""
'''
ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/

https://www.youtube.com/watch?v=pBWCOCS636U&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=273
'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
TC     -  O(2*k)
SC     -  O(1)  
'''
def main_function(arr, k):
  lsum = 0           # Sum of the "left" selected elements
  rsum = 0           # Sum of the "right" selected elements

  # Compute the sum of the first (k-1) elements from the start (left side)
  for i in range(k - 1):
    lsum += arr[i]

  maxSum = lsum      # Initialize maxSum with the sum of these first (k-1) elements
  rindex = len(arr) - 1  # Start from the last element of the array (right side)

  # Loop from index (k-1) down to 0 (inclusive) backwards
  for i in range(k - 1, -1, -1):
    lsum -= arr[i]        # Remove the element at index i from the left sum
    rsum += arr[rindex]   # Add the element at rindex from the right to right sum
    rindex -= 1           # Move the right index leftwards (towards front)
    # Update maxSum with the maximum sum between current maxSum and combined sums
    maxSum = max(maxSum, lsum + rsum)
  return maxSum

arr = [6, 2, 3, 4, 7, 2, 1, 7, 1]
k = 4
print(main_function(arr, k))  # Output: 21



# endregion





# region 10.2 SLIDING WINDOW/TWO POINTER - HARD
# ---------------------------------------------

# 1 TODO : largest substring with at most K distincet characters 
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/

https://www.youtube.com/watch?v=teM9ZsVRQyc&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=277
'''
# method 1 : brute force approch
# TC     -     O(N^2) 
# SC     -     
def main_function(s, k):
    maxlen = 0
    mpp = {}

    # Compute the sum of the first k-1 elements
    for i in range(len(s)):
      mpp = {}
      for j in range(len(s)):
        mpp[s[j]] = mpp.get(s[j], 0) + 1
        if len(mpp) <= k:
          maxlen = max(maxlen, j-i+1)
        else:
          break
    return maxlen


s = "aaabbccd"
k = 2
print(main_function(s, k))


# method 2 : better approch
# TC     -      
# SC     -   
def largest_substring_k_distinct(s, k):
    # Dictionary to store the frequency of characters in the current window
    char_count = {}
    left = 0  # Left pointer of the window
    max_len = 0  # Variable to store the maximum length of substring
    max_substr = ""  # To store the largest substring with at most k distinct characters
    
    right = 0  # Right pointer of the window

    # Iterate using a while loop for the right pointer
    while right < len(s):
        # Add the current character to the dictionary
        char_count[s[right]] = char_count.get(s[right], 0) + 1
        
        # If the number of distinct characters exceeds k, shrink the window from the left
        while len(char_count) > k:
            char_count[s[left]] -= 1
            if char_count[s[left]] == 0:
                del char_count[s[left]]  # Remove the character if its frequency becomes 0
            left += 1  # Move the left pointer
        
        # Update the maximum length and substring if needed
        if right - left + 1 > max_len:
            max_len = right - left + 1
            max_substr = s[left:right+1]
        
        # Move the right pointer to the next character
        right += 1

    return max_substr

# Example usage
s = "eceba"
k = 2
print("Largest substring with at most", k, "distinct characters:", largest_substring_k_distinct(s, k))
  


# method 3 : optimal solution
# TC     -      
# SC     -      
def largest_substring_k_distinct(s, k):
    # Dictionary to store the frequency of characters in the current window
    char_count = {}
    left = 0  # Left pointer of the window
    max_len = 0  # Variable to store the maximum length of substring
    max_substr = ""  # To store the largest substring with at most k distinct characters
    
    right = 0  # Right pointer of the window

    # Iterate using a while loop for the right pointer
    while right < len(s):
        # Add the current character to the dictionary
        char_count[s[right]] = char_count.get(s[right], 0) + 1
        
        # If the number of distinct characters exceeds k, shrink the window from the left
        if len(char_count) > k:
            char_count[s[left]] -= 1
            if char_count[s[left]] == 0:
                del char_count[s[left]]  # Remove the character if its frequency becomes 0
            left += 1  # Move the left pointer
        
        # Update the maximum length and substring if needed
        if right - left + 1 > max_len:
            max_len = right - left + 1
            max_substr = s[left:right+1]
        
        # Move the right pointer to the next character
        right += 1

    return max_substr

# Example usage
s = "eceba"
k = 2
print("Largest substring with at most", k, "distinct characters:", largest_substring_k_distinct(s, k))



# 2 TODO : subarray with k different integers
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://leetcode.com/problems/subarrays-with-k-different-integers/


https://www.youtube.com/watch?v=7wYGbV_LsX4&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=282
'''
# method 1 : brute force approch
# TC     -      O(n^2)
# SC     -     O(N)

def main_function(arr, k):
  count = 0
  for i  in range(len(arr)):
    mpp = {}
    for j in range(i,len(arr)):
      mpp[arr[j]] = 1 
      if len(mpp) == k:
        count += 1 
      elif len(mpp) > k:
        break
  return count        

arr = [1,2,1,3,4]
k = 3
print(main_function(arr, k))
# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      O(2N)
# SC     -      O(N)
def main_function(arr, k):
  l = 0
  count = 0
  mpp = {}
  for r in range(len(arr)):
    mpp[arr[r]] = mpp.get(arr[r], 0) + 1
    while len(mpp) > k:
      mpp[arr[l]] -= 1
      if mpp[arr[l]] == 0:
        del mpp[arr[l]]
      l += 1
    count += (r - l + 1)
  return count

arr = [1, 2, 1, 3, 4]
k = 3
print(main_function(arr, k) - main_function(arr, k - 1))


# 3 TODO : minimum window substring
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://leetcode.com/problems/minimum-window-substring/


https://www.youtube.com/watch?v=WJaij9ffOIY&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=283
'''
# method 1 : brute force approch
# TC     -      O(N^2)
# SC     -    O(256) 
def main_function(arr, k):
    min_len = 10**9
    s_index = -1
    k_set = set(k)  # Convert k to a set of distinct characters
    
    for i in range(len(arr)):
        hash_arr = [0] * 256  # Track frequency of characters (ASCII)
        count = 0
        for j in range(i, len(arr)):  # Iterate over the substring from i to j
            if hash_arr[ord(arr[j])] == 0 and arr[j] in k_set:  # New unique character
                count += 1
            hash_arr[ord(arr[j])] += 1

            if count == len(k_set):  # If we've found all distinct characters from k
                if j - i + 1 < min_len:
                    min_len = j - i + 1
                    s_index = i
                break  # No need to continue with this i, we found the result

    if s_index == -1:
        return ""  # No valid substring found
    return arr[s_index:s_index + min_len]

arr = "ddaaabbca"
k = "abc"
print(main_function(arr, k))


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      O(2N) + O(M)
# SC     -   O(256)   
def main_function(s, t):
    n = len(s)
    m = len(t)
    l = 0
    r = 0
    min_len = float('inf')  # Start with infinity for min_len
    count = 0
    s_index = -1
    hash_arr = [0] * 256  # To track frequency of characters (ASCII size)
    
    # Count frequency of characters in t
    for char in t:
        hash_arr[ord(char)] += 1  # Increment frequency for each character in t
    
    # Sliding window
    while r < n:
        # If the character in s[r] exists in t, we decrement the required count
        if hash_arr[ord(s[r])] > 0:
            count += 1
        
        # Decrease the frequency of the character in hash_arr
        hash_arr[ord(s[r])] -= 1
        r += 1
        
        # Once we have all characters needed, try to shrink the window
        while count == m:
            # Update the minimum length substring
            if r - l < min_len:
                min_len = r - l
                s_index = l
            
            # Try to shrink the window from the left
            hash_arr[ord(s[l])] += 1
            if hash_arr[ord(s[l])] > 0:
                count -= 1
            l += 1
    
    # If we found a valid substring, return it
    if s_index == -1:
        return ""  # No valid substring found
    return s[s_index:s_index + min_len]  # Return the smallest valid substring

arr = "ddaaabbca"
k = "abc"
print(main_function(arr, k))  # Output should be "abbc" (smallest substring containing "abc")


# 4 TODO : minimum window subsequence
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://leetcode.com/problems/minimum-window-subsequence/



'''
# method 1 : brute force approch
'''
Time Complexity: O(2^n * n) due to generating all subsequences of S and checking if each one contains T.
Space Complexity: O(n) for storing the subsequences.

'''
def is_subsequence(sub, t):
    t_idx = 0
    for char in sub:
        if char == t[t_idx]:
            t_idx += 1
            if t_idx == len(t):
                return True
    return False

def min_window_subsequence_brute(s, t):
    n, m = len(s), len(t)
    min_subseq = ""
    for i in range(1, 1 << n):  # All subsets of s
        subseq = "".join([s[j] for j in range(n) if (i & (1 << j))])
        if is_subsequence(subseq, t):
            if not min_subseq or len(subseq) < len(min_subseq):
                min_subseq = subseq
    return min_subseq


# method 2 : better approch
'''
Time Complexity: O(n * m) where n is the length of S and m is the length of T, since we use two pointers to scan S and find subsequences matching T.
Space Complexity: O(1) for extra space.
'''
def min_window_subsequence_better(s, t):
    n, m = len(s), len(t)
    start, end = -1, n
    i, j = 0, 0  # i for S, j for T

    while i < n:
        if s[i] == t[j]:
            j += 1
        if j == m:
            # Found a subsequence that matches T
            k = i
            while j > 0:
                if s[k] == t[j-1]:
                    j -= 1
                k -= 1
            if end - start > i - k:
                start, end = k, i
            j = 0  # reset j to 0 for the next subsequence
        i += 1

    return "" if start == -1 else s[start:end+1]


# method 3 : optimal solution
'''
Time Complexity: O(n * log n) where n is the length of S, because we perform a binary search for each character of T.
Space Complexity: O(n) to store the positions of characters in S.
'''
from collections import defaultdict
import bisect

def min_window_subsequence_optimal(s, t):
    n, m = len(s), len(t)
    
    # Step 1: Build a map of character indices for each character in S
    char_positions = defaultdict(list)
    for i, char in enumerate(s):
        char_positions[char].append(i)
    
    # Step 2: Use binary search to find the minimum window subsequence
    def find_next_position(start_idx, char):
        # Perform binary search to find the first position > start_idx
        positions = char_positions[char]
        pos = bisect.bisect_right(positions, start_idx)
        if pos < len(positions):
            return positions[pos]
        return -1  # If no valid position is found
    
    start_idx = -1
    result_start, result_end = -1, n
    
    for i in range(m):
        char = t[i]
        start_idx = find_next_position(start_idx, char)
        if start_idx == -1:
            return ""  # If no valid subsequence found
        result_start = start_idx if i == 0 else result_start
        if i == m - 1:
            result_end = start_idx
    
    return s[result_start:result_end + 1]




# endregion






# region 11.1 HEAP/PRIORITY QUEUE - LEARNING
# ------------------------------------------

# 1 TODO :  introduction to parity queue using binary heaps
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://bit.ly/3TSxAHd


'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : min heap and max heap replacement
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://bit.ly/3weGgP3

'''
# method 1 : brute force approch
'''end=
Time Complexity:

Heapify: O(n) where n is the number of elements in the heap.
Insertions (heapq.heappush): Each insertion takes O(log n) time.
Pop (heapq.heappop): Each pop operation takes O(log n) time.
Space Complexity:

Space Complexity is O(n) as we need to store the heap elements.

'''
import heapq

# Min-Heap Example
min_heap = [2, 4, 3, 5, 7, 6]
heapq.heapify(min_heap)  # Create a min-heap
print("Min-Heap:", min_heap)

# Replace Min-Heap with Max-Heap
max_heap = []
for num in min_heap:
    heapq.heappush(max_heap, -num)  # Negate the value for max-heap
print("Max-Heap:", [-num for num in max_heap])  # Negate the values to show original values

# Extract the maximum element from Max-Heap
max_element = -heapq.heappop(max_heap)  # Pop the negated max element and negate again
print("Extracted Max Element:", max_element)

# Max-Heap to Min-Heap Replacement
min_heap_after_max_heap = []
for num in [-num for num in max_heap]:  # Negate back to original values
    heapq.heappush(min_heap_after_max_heap, num)  # Now it's a min-heap
print("Min-Heap After Max-Heap Replacement:", min_heap_after_max_heap)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 3 TODO : check if an array represents a min-heap or not
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://bit.ly/3AbFrrI



'''
# method 1 : brute force approch
'''
Time Complexity: O(n)

We loop through all non-leaf nodes and perform constant-time comparisons for each node. Therefore, the overall time complexity is linear in terms of the number of elements n.
Space Complexity: O(1)

We are using only a few extra variables and do not require any extra space proportional to the input size, so the space complexity is constant.

'''
def isMinHeap(arr):
    n = len(arr)
    
    # Iterate through all nodes (except the leaves)
    for i in range((n // 2) - 1, -1, -1):
        # Get the left and right children indices
        left = 2 * i + 1
        right = 2 * i + 2
        
        # Check if the current node is greater than its left child
        if left < n and arr[i] > arr[left]:
            return False
        
        # Check if the current node is greater than its right child
        if right < n and arr[i] > arr[right]:
            return False
            
    return True

# Example usage:
arr1 = [1, 3, 2, 5, 4, 6]
arr2 = [1, 2, 3, 4, 5, 6]
arr3 = [3, 1, 2, 5, 4, 6]

print(isMinHeap(arr1))  # Output: True (represents a Min-Heap)
print(isMinHeap(arr2))  # Output: True (represents a Min-Heap)
print(isMinHeap(arr3))  # Output: False (does not represent a Min-Heap)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 4 TODO : convert min heap to max heap
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://bit.ly/3flmw7c


'''
# method 1 : brute force approch
'''
Time Complexity: O(n)

Negating all elements takes O(n) time, and heapifying the array takes O(n) time as well. Therefore, the overall time complexity is O(n).
Space Complexity: O(n)

We are using additional space to store the negated version of the array, which makes the space complexity O(n).

'''
import heapq

def convertMinHeapToMaxHeap(arr):
    # Negate all the elements to simulate a max-heap using min-heap.
    arr = [-x for x in arr]
    
    # Convert the array to a heap (this will be a "min-heap" of negative numbers, which represents a max-heap).
    heapq.heapify(arr)
    
    # Negate the elements back to get the correct max-heap
    arr = [-x for x in arr]
    
    return arr

# Example usage:
min_heap = [1, 3, 2, 5, 4, 6]
print("Min-Heap:", min_heap)

# Convert Min-Heap to Max-Heap
max_heap = convertMinHeapToMaxHeap(min_heap)
print("Max-Heap:", max_heap)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      



# endregion






# region 11.2 HEAP/PRIORITY QUEUE - MEDIUM
# ----------------------------------------

# 1 TODO :  Kth largest element in an array (use parity queue)
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/data-structure/kth-largest-smallest-element-in-an-array/


https://leetcode.com/problems/kth-largest-element-in-an-array/




'''
# method 1 : brute force approch
'''
Time complexity: O(nlogn)

Space complexity: O(1)
'''
from typing import List




class Solution:
    def kth_Largest_And_Smallest_By_AscendingOrder(self, arr: List[int], k: int) -> None:
        arr.sort()
        n = len(arr)


        print(
            f"kth Largest element {arr[n - k]}, kth Smallest element {arr[k - 1]}")




if __name__ == "__main__":
    arr = [1, 2, 6, 4, 5, 3]
    Solution().kth_Largest_And_Smallest_By_AscendingOrder(arr, 3) 


# method 2 : better approch
'''
Time complexity: O(k+(n-k)*log(k))  , n = size of array

Space complexity: O(k)
'''
import heapq




class Solution:
    def kth_Largest_MaxHeap(self, arr, k):
        pq = []
        n = len(arr)
        for i in range(n):
            heapq.heappush(pq, -arr[i])


        f = k - 1


        while f > 0:
            heapq.heappop(pq)
            f -= 1


        print("Kth Largest element", -pq[0])


    def kth_Smallest_MinHeap(self, arr, k):
        pq = []
        n = len(arr)


        for i in range(n):
            heapq.heappush(pq, arr[i])


        f = k - 1


        while f > 0:
            heapq.heappop(pq)
            f -= 1


        print("Kth Smallest element", pq[0])




if __name__ == "__main__":
    arr = [1, 2, 6, 4, 5, 3]


    obj = Solution()
    obj.kth_Largest_MaxHeap(arr, 3)
    obj.kth_Smallest_MinHeap(arr, 3)

 


# method 3 : optimal solution
'''
Time complexity: O(n) , where n = size of the array

Space complexity: O(1) 
'''
from typing import List




def partition(arr: List[int], left: int, right: int) -> int:
    pivot = arr[left]
    l = left + 1
    r = right
    while l <= r:
        if arr[l] < pivot and arr[r] > pivot:
            arr[l], arr[r] = arr[r], arr[l]
            l += 1
            r -= 1
        if arr[l] >= pivot:
            l += 1
        if arr[r] <= pivot:
            r -= 1


    arr[left], arr[r] = arr[r], arr[left]
    return r




def kth_Largest_Element(arr: List[int], k: int) -> int:
    left = 0
    right = len(arr) - 1
    kth = 0
    while 1:
        idx = partition(arr, left, right)
        if idx == k - 1:
            kth = arr[idx]
            break
        if idx < k - 1:
            left = idx + 1
        else:
            right = idx - 1


    return kth


# method 4 : optimized
'''
Time complexity: O(n) ,where n = size of the array

Space complexity: O(1)
'''
from typing import List




def partition(arr: List[int], l: int, r: int) -> int:
    f = arr[r]
    i = l
    for j in range(l, r):
        if arr[j] <= f:
            arr[i], arr[j] = arr[j], arr[i]
            i += 1
    arr[i], arr[r] = arr[r], arr[i]
    return i




def kth_Smallest_Element(arr: List[int], l: int, r: int, k: int) -> int:
    if k <= r - l + 1 and k > 0:
        ind = partition(arr, l, r)
        if ind - l == k - 1:
            return arr[ind]
        if ind - l > k - 1:
            return kth_Smallest_Element(arr, l, ind - 1, k)
        return kth_Smallest_Element(arr, ind + 1, r, k - ind + l - 1)
    return float("inf")




if __name__ == "__main__":
    arr = [12, 3, 5, 7, 4, 19, 26]
    n = len(arr)
    k = 1
    print(f"Kth smallest element is {kth_Smallest_Element(arr, 0, n - 1, k)}")





# 2 TODO : Kth smallest element in an array  (use parity queue)
'''


ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢



https://takeuforward.org/data-structure/kth-largest-smallest-element-in-an-array/


https://bit.ly/3PvAOhK




'''
# method 1 : brute force approch
'''
Time complexity: O(nlogn)

Space complexity: O(1)
'''
from typing import List




class Solution:
    def kth_Largest_And_Smallest_By_AscendingOrder(self, arr: List[int], k: int) -> None:
        arr.sort()
        n = len(arr)


        print(
            f"kth Largest element {arr[n - k]}, kth Smallest element {arr[k - 1]}")




if __name__ == "__main__":
    arr = [1, 2, 6, 4, 5, 3]
    Solution().kth_Largest_And_Smallest_By_AscendingOrder(arr, 3)


# method 2 : better approch
'''
Time complexity: O(k+(n-k)*log(k))  , n = size of array

Space complexity: O(k)
'''
import heapq




class Solution:
    def kth_Largest_MaxHeap(self, arr, k):
        pq = []
        n = len(arr)
        for i in range(n):
            heapq.heappush(pq, -arr[i])


        f = k - 1


        while f > 0:
            heapq.heappop(pq)
            f -= 1


        print("Kth Largest element", -pq[0])


    def kth_Smallest_MinHeap(self, arr, k):
        pq = []
        n = len(arr)


        for i in range(n):
            heapq.heappush(pq, arr[i])


        f = k - 1


        while f > 0:
            heapq.heappop(pq)
            f -= 1


        print("Kth Smallest element", pq[0])




if __name__ == "__main__":
    arr = [1, 2, 6, 4, 5, 3]


    obj = Solution()
    obj.kth_Largest_MaxHeap(arr, 3)
    obj.kth_Smallest_MinHeap(arr, 3)   


# method 3 : optimal solution
'''
Time complexity: O(n) , where n = size of the array

Space complexity: O(1) 
'''
from typing import List




def partition(arr: List[int], left: int, right: int) -> int:
    pivot = arr[left]
    l = left + 1
    r = right
    while l <= r:
        if arr[l] < pivot and arr[r] > pivot:
            arr[l], arr[r] = arr[r], arr[l]
            l += 1
            r -= 1
        if arr[l] >= pivot:
            l += 1
        if arr[r] <= pivot:
            r -= 1


    arr[left], arr[r] = arr[r], arr[left]
    return r




def kth_Largest_Element(arr: List[int], k: int) -> int:
    left = 0
    right = len(arr) - 1
    kth = 0
    while 1:
        idx = partition(arr, left, right)
        if idx == k - 1:
            kth = arr[idx]
            break
        if idx < k - 1:
            left = idx + 1
        else:
            right = idx - 1


    return kth




if __name__ == "__main__":
    arr = [12, 3, 5, 7, 4, 19, 26]
    n = len(arr)
    k = 1
    print(f"Kth Largest element is {kth_Largest_Element(arr, k)}")

# method 4
'''
Time complexity: O(n) ,where n = size of the array

Space complexity: O(1)
'''
from typing import List




def partition(arr: List[int], l: int, r: int) -> int:
    f = arr[r]
    i = l
    for j in range(l, r):
        if arr[j] <= f:
            arr[i], arr[j] = arr[j], arr[i]
            i += 1
    arr[i], arr[r] = arr[r], arr[i]
    return i




def kth_Smallest_Element(arr: List[int], l: int, r: int, k: int) -> int:
    if k <= r - l + 1 and k > 0:
        ind = partition(arr, l, r)
        if ind - l == k - 1:
            return arr[ind]
        if ind - l > k - 1:
            return kth_Smallest_Element(arr, l, ind - 1, k)
        return kth_Smallest_Element(arr, ind + 1, r, k - ind + l - 1)
    return float("inf")




if __name__ == "__main__":
    arr = [12, 3, 5, 7, 4, 19, 26]
    n = len(arr)
    k = 1
    print(f"Kth smallest element is {kth_Smallest_Element(arr, 0, n - 1, k)}")


# 3 TODO : sort K sorted array
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://bit.ly/3QLpaAs




'''
'''end=
Time Complexity:
Building the Heap:

Building the heap with the first K+1 elements takes O(K log K) time.
Processing Each Element:

For each of the remaining n - (K+1) elements:
Inserting into the heap takes O(log K) time.
Extracting the minimum from the heap also takes O(log K) time.
Thus, processing all the remaining elements takes O((n - (K+1)) * log K) time.
Final Extraction:

Extracting all elements from the heap takes O(K log K) time.
Therefore, the overall Time Complexity is:

O(n log K) where n is the number of elements in the array.
Space Complexity:
We are using a heap of size K+1, so the Space Complexity is O(K).



'''
import heapq

def heapSortKSortedArray(arr, k):
    # Min-Heap to store the first K+1 elements
    min_heap = []
    
    # Build the Min-Heap with first K+1 elements
    for i in range(k + 1):
        heapq.heappush(min_heap, arr[i])
    
    # Index to place sorted elements
    index = 0
    
    # Process the remaining elements of the array
    for i in range(k + 1, len(arr)):
        # Extract the smallest element from the heap and place it in the array
        arr[index] = heapq.heappop(min_heap)
        # Insert the next element into the heap
        heapq.heappush(min_heap, arr[i])
        index += 1
    
    # Now, extract the remaining elements from the heap and place them in the array
    while min_heap:
        arr[index] = heapq.heappop(min_heap)
        index += 1
    
    return arr

# Example usage:
arr = [2, 6, 3, 12, 56, 8]
k = 3

print("Original Array:", arr)
sorted_array = heapSortKSortedArray(arr, k)
print("Sorted Array:", sorted_array)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 4 TODO : merge M sorted lists
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://leetcode.com/problems/merge-k-sorted-lists/




'''
# method 1 : brute force approch
'''end=
Time Complexity (TC):
Heap Operations:
Inserting an element into the heap takes O(log K), where K is the number of lists.
Each list insertion operation is performed n times, where n is the total number of elements in all lists combined.
Total Operations:
For every element in the lists, we perform an insertion and extraction operation on the heap. Hence, the time complexity is:
O(n log K), where:
n is the total number of elements across all lists.
K is the number of lists (heap size).


Space Complexity (SC):
Heap:

The heap stores at most one element from each list at any time, so the space complexity for the heap is O(K) where K is the number of lists.
Result List:

The space required for the result list is O(n), where n is the total number of elements across all lists.
Therefore, the space complexity is O(n + K).

'''
import heapq

def mergeKSortedLists(lists):
    # Min-heap
    min_heap = []
    
    # Build the initial heap with the first element of each list
    for i in range(len(lists)):
        if lists[i]:
            # Push the element along with the list index and the element index
            heapq.heappush(min_heap, (lists[i][0], i, 0))
    
    # Resultant merged list
    merged_list = []
    
    # Process the heap
    while min_heap:
        # Get the smallest element from the heap
        val, list_idx, element_idx = heapq.heappop(min_heap)
        
        # Add the smallest element to the result list
        merged_list.append(val)
        
        # If there's a next element in the same list, push it to the heap
        if element_idx + 1 < len(lists[list_idx]):
            next_val = lists[list_idx][element_idx + 1]
            heapq.heappush(min_heap, (next_val, list_idx, element_idx + 1))
    
    return merged_list

# Example usage:
lists = [
    [1, 4, 5],
    [1, 3, 4],
    [2, 6]
]

merged_list = mergeKSortedLists(lists)
print("Merged List:", merged_list)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 5 TODO : replace each array element by it's corresponding rank
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

https://takeuforward.org/data-structure/replace-elements-by-its-rank-in-the-array/


https://bit.ly/3TS3jcg


'''
# method 1 : brute force approch
''' 
Time Complexity (TC):
Heap Operations: Building the heap takes O(n) time. Extracting from the heap n times, each extraction takes O(log n) time. Thus, heap operations contribute O(n log n) time complexity.

Overall Complexity: The overall time complexity of this algorithm is dominated by the heap operations, so the time complexity is O(n log n).

Space Complexity (SC):
We use extra space for the indexed_arr and the rank array, both of which have a size of n. Therefore, the space complexity is O(n).

''' 
import heapq

def replaceWithRank(arr):
    # Step 1: Create tuples of (value, original_index)
    indexed_arr = [(val, idx) for idx, val in enumerate(arr)]
    
    # Step 2: Build a min-heap based on the value of each tuple
    heapq.heapify(indexed_arr)
    
    # Step 3: Create a result array to store ranks
    rank = [0] * len(arr)
    
    # Step 4: Assign ranks based on the sorted order (min-heap)
    rank_counter = 1
    while indexed_arr:
        value, idx = heapq.heappop(indexed_arr)  # Pop the smallest element
        rank[idx] = rank_counter  # Assign rank to the element's original position
        rank_counter += 1
    
    return rank

# Example usage:
arr = [40, 10, 20, 30, 10]
print("Original Array:", arr)
result = replaceWithRank(arr)
print("Array with Ranks:", result)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 6 TODO : task scheduler
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/task-scheduler/




'''
# method 1 : brute force approch
'''end=
Time Complexity (TC):
Building the Heap: It takes O(M log M) time, where M is the number of unique tasks (because there are at most M tasks in the heap).
Processing the Heap: Each extraction from the heap takes O(log M) time. For each unit of time, we extract a task, which can happen n times for each task. In the worst case, this is O(T log M), where T is the total time.
Total Time Complexity: Thus, the time complexity is O(T log M), where T is the total time and M is the number of unique tasks.
Space Complexity (SC):
Heap Space: The space for the heap is O(M) where M is the number of unique tasks.
Cooldown List: The cooldown list can store at most M tasks at any time, so its space complexity is O(M).
Total Space Complexity: The space complexity is O(M).


'''
import heapq
from collections import Counter

def taskScheduler(tasks, n):
    # Step 1: Count the frequency of each task
    task_counts = Counter(tasks)
    
    # Step 2: Create a max heap based on the negative frequency
    max_heap = []
    for task, freq in task_counts.items():
        heapq.heappush(max_heap, (-freq, task))  # Push negative frequency to simulate max heap
    
    time = 0
    # This list will hold tasks in cooldown
    cooldown = []
    
    while max_heap or cooldown:
        time += 1
        
        if max_heap:
            # Step 3: Extract the task with the highest frequency
            freq, task = heapq.heappop(max_heap)
            # We reduce the frequency (remember it's negative)
            if freq + 1 < 0:  # Task still has remaining occurrences
                cooldown.append((freq + 1, task, time + n))  # We add it back after cooldown
        
        # Step 4: Process tasks in cooldown that are ready to be used again
        for i in range(len(cooldown) - 1, -1, -1):
            if cooldown[i][2] == time:
                # Move the task back to the heap if it's ready to run
                heapq.heappush(max_heap, cooldown.pop(i)[:2])
    
    return time

# Example usage:
tasks = ["A", "A", "A", "B", "B", "C"]
n = 2
print(f"Minimum units of time to schedule tasks: {taskScheduler(tasks, n)}")


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 7 TODO : hands of straights
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

- The problem of hands of straights involves determining whether you can form a sequence of "hands" (or straight sequences) from a collection of cards where each hand is a straight (i.e., consecutive numbers). The primary challenge is to efficiently check whether it is possible to arrange the cards into straight hands.


https://leetcode.com/problems/hand-of-straights/



'''
# method 1 : brute force approch
'''end=

Time Complexity:
Counting Frequencies: O(n), where n is the number of cards in the input list.
Heap Operations: In the worst case, each card will be pushed and popped from the heap at most once, so the heap operations (insertion and extraction) contribute O(n log n) time complexity.
Overall Time Complexity: O(n log n), where n is the total number of cards in the input list.
Space Complexity:
Heap Space: We store at most n cards in the heap.
Count Dictionary: The Counter also stores up to n cards.
Overall Space Complexity: O(n).


'''
import heapq
from collections import Counter

def isStraightHand(cards, W):
    # Step 1: If the total number of cards isn't a multiple of W, we can't form valid hands.
    if len(cards) % W != 0:
        return False
    
    # Step 2: Count the frequency of each card
    count = Counter(cards)
    
    # Step 3: Push all unique cards into a Min-Heap (priority queue)
    heap = list(count.keys())
    heapq.heapify(heap)
    
    # Step 4: Process each hand
    while heap:
        # Get the smallest card in the heap (min-heap ensures this)
        first = heapq.heappop(heap)
        
        # Check if there are enough cards to form a valid hand starting from 'first'
        for i in range(first, first + W):
            if count[i] == 0:  # If there are no cards left for 'i', it's not a valid hand
                return False
            count[i] -= 1  # Decrease the count of the card being used for the hand
            
            # If the count of a card goes to zero, we don't need it in the heap anymore
            if count[i] == 0 and i != first:
                heapq.heappush(heap, i)
    
    return True


# Example usage:
cards = [1, 2, 3, 3, 4, 5]
W = 3
print(isStraightHand(cards, W))  # Expected output: True (possible to form hands of length 3)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      




# endregion






# region 11.3 HEAP/PRIORITY QUEUE - HARD
# --------------------------------------

# 1 TODO :  design twitter
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/design-twitter/



'''
# method 1 : brute force approch
''' 

Time and Space Complexity:
Post Tweet: O(1) time to add a tweet to the user's list, but the time to add a tweet to the heap is dependent on the number of tweets in the heap.

Follow/Unfollow: O(1) for adding or removing a user from the following set.

Get Timeline: In the worst case, each user might have all their tweets in the timeline. Assuming a maximum of M tweets in total across all users, and each heap operation (push and pop) takes O(log M), getting the timeline will take O(M log M).

Space Complexity: Space for storing users, tweets, and the heap. Space complexity is O(M) for storing all tweets, where M is the total number of tweets in the system.



'''  
import heapq
import time

class Tweet:
    def __init__(self, tweet_id, user_id, content, timestamp):
        self.tweet_id = tweet_id
        self.user_id = user_id
        self.content = content
        self.timestamp = timestamp
    
    # We want the heap to prioritize the most recent tweets first
    def __lt__(self, other):
        return self.timestamp > other.timestamp


class User:
    def __init__(self, user_id):
        self.user_id = user_id
        self.following = set()  # Users that this user follows
        self.tweets = []  # List of tweets this user has posted
    
    def follow(self, other_user):
        self.following.add(other_user)
    
    def unfollow(self, other_user):
        if other_user in self.following:
            self.following.remove(other_user)
    
    def post_tweet(self, tweet):
        self.tweets.append(tweet)
    
    def get_timeline(self):
        # Max heap to retrieve the most recent tweets from the user's timeline
        timeline = []
        
        # Add the tweets from the user themselves
        for tweet in self.tweets:
            heapq.heappush(timeline, tweet)
        
        # Add the tweets from the users the user is following
        for follower in self.following:
            for tweet in follower.tweets:
                heapq.heappush(timeline, tweet)
        
        # Get top 10 tweets (most recent)
        recent_tweets = []
        while timeline and len(recent_tweets) < 10:
            recent_tweets.append(heapq.heappop(timeline))
        
        return recent_tweets


class Twitter:
    def __init__(self):
        self.users = {}  # Map user_id -> User
        self.tweet_counter = 0  # Counter for tweet IDs
    
    def create_user(self, user_id):
        if user_id not in self.users:
            self.users[user_id] = User(user_id)
    
    def post_tweet(self, user_id, content):
        if user_id not in self.users:
            print("User not found!")
            return
        timestamp = time.time()  # Current timestamp
        tweet = Tweet(self.tweet_counter, user_id, content, timestamp)
        self.users[user_id].post_tweet(tweet)
        self.tweet_counter += 1
    
    def follow(self, follower_id, followee_id):
        if follower_id not in self.users or followee_id not in self.users:
            print("User not found!")
            return
        self.users[follower_id].follow(self.users[followee_id])
    
    def unfollow(self, follower_id, followee_id):
        if follower_id not in self.users or followee_id not in self.users:
            print("User not found!")
            return
        self.users[follower_id].unfollow(self.users[followee_id])
    
    def get_timeline(self, user_id):
        if user_id not in self.users:
            print("User not found!")
            return
        user = self.users[user_id]
        tweets = user.get_timeline()
        return [tweet.content for tweet in tweets]  # Return the tweet content


# Example Usage:
twitter = Twitter()

# Create Users
twitter.create_user(1)  # User 1
twitter.create_user(2)  # User 2
twitter.create_user(3)  # User 3

# Post Tweets
twitter.post_tweet(1, "This is user 1's first tweet")
time.sleep(1)  # Sleep to ensure the tweets have different timestamps
twitter.post_tweet(2, "This is user 2's first tweet")
time.sleep(1)
twitter.post_tweet(1, "This is user 1's second tweet")
time.sleep(1)
twitter.post_tweet(3, "This is user 3's tweet")

# User 1 follows User 2 and User 3
twitter.follow(1, 2)
twitter.follow(1, 3)

# Get User 1's timeline (should include tweets from user 1, 2, and 3)
timeline = twitter.get_timeline(1)
print("User 1's Timeline:")
for tweet in timeline:
    print(tweet)

# Unfollow User 2
twitter.unfollow(1, 2)

# Get User 1's timeline again (should now exclude tweets from user 2)
timeline = twitter.get_timeline(1)
print("\nUser 1's Timeline After Unfollowing User 2:")
for tweet in timeline:
    print(tweet)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : connect "n" ropes with minimal cost
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://bit.ly/3QVb1jR




'''
# method 1 : brute force approch
'''end=
Time Complexity:

Heap operations (insertions and deletions) take O(log n) time, where n is the number of ropes.
Since we perform these operations n-1 times, the overall time complexity is O(n log n).
Space Complexity:

The space complexity is O(n) because we use a heap to store all n ropes.


'''
import heapq

def min_cost_to_connect_ropes(ropes):
    # Step 1: Create a min-heap
    heapq.heapify(ropes)
    
    total_cost = 0
    
    # Step 2: Continue combining ropes until we have one rope left
    while len(ropes) > 1:
        # Extract the two smallest ropes
        first_min = heapq.heappop(ropes)
        second_min = heapq.heappop(ropes)
        
        # Calculate the cost of combining the two ropes
        cost = first_min + second_min
        total_cost += cost
        
        # Push the combined rope back into the heap
        heapq.heappush(ropes, cost)
    
    return total_cost

# Example Usage:
ropes = [4, 3, 2, 6]
result = min_cost_to_connect_ropes(ropes)
print(f"Minimum cost to connect all ropes: {result}")


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 3 TODO : Kth largest element in a stream of running integers
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://leetcode.com/problems/kth-largest-element-in-a-stream/#:~:text=Implement%20KthLargest%20class%3A,largest%20element%20in%20the%20stream.



'''
# method 1 : brute force approch
''' 
Time Complexity:
Inserting an element into the heap takes O(log K) time, where K is the size of the heap.
Since we perform this operation for each new element in the stream, the total time complexity is O(log K) for each addition.
Space Complexity:
The heap stores at most K elements, so the space complexity is O(K).


'''
import heapq

class KthLargest:
    def __init__(self, k, stream):
        self.k = k
        self.min_heap = []
        
        # Initialize the heap with the first k elements from the stream
        for num in stream:
            self.add(num)
    
    def add(self, val):
        # Step 1: Add the new value to the heap
        heapq.heappush(self.min_heap, val)
        
        # Step 2: If heap size exceeds k, pop the smallest element
        if len(self.min_heap) > self.k:
            heapq.heappop(self.min_heap)
        
        # Step 3: The root of the heap is the Kth largest element
        return self.min_heap[0]

# Example usage:

# Initialize with k = 3 and an initial stream of values [4, 5, 8, 2]
kth_largest = KthLargest(3, [4, 5, 8, 2])

# Add new elements and get the Kth largest element after each addition
print(kth_largest.add(3))  # Returns 4
print(kth_largest.add(5))  # Returns 5
print(kth_largest.add(10)) # Returns 5
print(kth_largest.add(9))  # Returns 8
print(kth_largest.add(4))  # Returns 8


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 4 TODO : maximum sum combination
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://www.interviewbit.com/problems/maximum-sum-combinations/



'''
# method 1 : brute force approch
''' 
Time Complexity:

For each of the K largest sums, we perform a pop and push operation on the heap. Since each heap operation takes O(log K), the time complexity is O(K log K).
Space Complexity:

The space complexity is O(K) due to the heap and the visited set, which will store at most K index pairs.


''' 
import heapq

def max_sum_combinations(A, B, K):
    N = len(A)
    
    # Max-heap, Python's heapq is a min-heap, so we negate the sums to simulate a max-heap
    max_heap = []
    heapq.heapify(max_heap)
    
    # Initialize the heap with the largest sum combination (last elements of A and B)
    heapq.heappush(max_heap, (-(A[N-1] + B[N-1]), N-1, N-1))  # We store negative sums to simulate max-heap
    
    # To avoid duplicates, we use a set to track visited (i, j) pairs
    visited = set()
    visited.add((N-1, N-1))
    
    result = []
    
    # Extract K maximum sums
    while K > 0:
        # Get the current largest sum
        current_sum, i, j = heapq.heappop(max_heap)
        current_sum = -current_sum  # Convert it back to positive
        
        result.append(current_sum)
        K -= 1
        
        # Explore the next potential combinations:
        # (i-1, j) and (i, j-1) if they haven't been visited yet
        if i > 0 and (i-1, j) not in visited:
            heapq.heappush(max_heap, (-(A[i-1] + B[j]), i-1, j))
            visited.add((i-1, j))
        
        if j > 0 and (i, j-1) not in visited:
            heapq.heappush(max_heap, (-(A[i] + B[j-1]), i, j-1))
            visited.add((i, j-1))
    
    return result

# Example usage:
A = [9, 7, 5, 3, 2]
B = [8, 6, 4, 2]
K = 3

result = max_sum_combinations(A, B, K)
print(f"The {K} largest sum combinations are: {result}")


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 5 TODO : find median from data stream
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://leetcode.com/problems/find-median-from-data-stream/




'''
# method 1 : brute force approch
''' 

Time Complexity:
Inserting a number into the heaps takes O(log N) because heapq.heappush() has a time complexity of O(log N).
Balancing the heaps (if necessary) also takes O(log N).
Therefore, for each insertion, the time complexity is O(log N).
Space Complexity:
We use two heaps, each of size at most N, where N is the number of elements in the stream.
Thus, the space complexity is O(N).


'''
import heapq

class MedianFinder:
    def __init__(self):
        # Max-heap to store the lower half of numbers (invert values for max-heap behavior)
        self.max_heap = []
        # Min-heap to store the upper half of numbers
        self.min_heap = []
    
    def addNum(self, num: int):
        # Add to max-heap (lower half)
        heapq.heappush(self.max_heap, -num)
        
        # Ensure max element of max-heap is less than min element of min-heap
        if (self.max_heap and self.min_heap and -self.max_heap[0] > self.min_heap[0]):
            val = -heapq.heappop(self.max_heap)
            heapq.heappush(self.min_heap, val)
        
        # Balance the size of heaps
        if len(self.max_heap) > len(self.min_heap) + 1:
            val = -heapq.heappop(self.max_heap)
            heapq.heappush(self.min_heap, val)
        elif len(self.min_heap) > len(self.max_heap):
            val = heapq.heappop(self.min_heap)
            heapq.heappush(self.max_heap, -val)
    
    def findMedian(self) -> float:
        if len(self.max_heap) > len(self.min_heap):
            return -self.max_heap[0]  # Median is the root of the max-heap
        return (-self.max_heap[0] + self.min_heap[0]) / 2.0  # Median is the average of both roots

# Example usage:
medianFinder = MedianFinder()
medianFinder.addNum(1)
medianFinder.addNum(2)
print(medianFinder.findMedian())  # Returns 1.5
medianFinder.addNum(3)
print(medianFinder.findMedian())  # Returns 2


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 6 TODO : K most frequent elements
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/top-k-frequent-elements/




'''
# method 1 : brute force approch
''' 

Time Complexity:

Counting the frequency of elements using Counter takes O(N), where N is the number of elements in the input array.
Building the heap involves iterating over the frequency map and pushing k elements into the heap. The heap operations (push and pop) take O(log K) time. Since there are at most N distinct elements, this step takes O(N log K).
Extracting the result from the heap takes O(K) because we extract k elements.
Hence, the overall time complexity is: O(N log K).

Space Complexity:

We use a hash map to store the frequency counts, which requires O(N) space.
We also use a heap to store k elements, which takes O(K) space.
Hence, the overall space complexity is: O(N + K).


'''
import heapq
from collections import Counter

def topKFrequent(nums, k):
    # Step 1: Count the frequency of each element in the array
    freq_map = Counter(nums)
    
    # Step 2: Build a min-heap with the most frequent elements
    # heapq is a min-heap by default, so we need to push negative frequencies to simulate a max-heap
    min_heap = []
    
    # Step 3: Add (frequency, element) pairs to the heap
    for num, freq in freq_map.items():
        heapq.heappush(min_heap, (freq, num))
        if len(min_heap) > k:
            heapq.heappop(min_heap)  # Pop the smallest element to keep the heap size at k
    
    # Step 4: Extract the top K frequent elements
    result = [item[1] for item in min_heap]  # Extract only the elements from the heap
    return result

# Example usage:
nums = [1, 1, 1, 2, 2, 3]
k = 2
result = topKFrequent(nums, k)
print(f"The {k} most frequent elements are: {result}")


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      



# endregion





# region 12.1 GREEDY ALGORITHM - EASY
# -----------------------------------

# 1 TODO :  assign cookies
'''

https://takeuforward.org/Greedy/assign-cookies


https://leetcode.com/problems/assign-cookies/


'''
# method 1 : brute force method 
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://www.youtube.com/watch?v=DIX2p7vb9co&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=284

sort the cookies arrays and greed array
take l and r pointer where l iterate over cookies array and r iterate over greed array
iterate over the arrays and check weather the current cookie fulfill the greed of the current child ie greed <= cookie. if yes increase r. l will increase in any case to continue the iteration



Time Complexity: O(N logN + M logM + M) where N is the length of the greedy array, M is the length of the cookies array. To sort the greedy and cookies array, the complexity is O(N logN) and O(M logM).

After sorting, we iterate over the arrays at most M times as M is the total number of cookies.
Since each child and each cookie is considered at most once, the time complexity of this part is linear in terms of the size of the cookie array, which is O(M).

Space Complexity: O(1) as the algorithm uses only a constant amount of extra space regardless of the size of the input array. It does not require any additional data structures that scale with the input size.
'''
from typing import List

# Function to find the maximum
# number of content children
def findContentChildren(greed: List[int], cookieSize: List[int]) -> int:
    # Get the size of
    # the greed array
    n = len(greed)

    # Get the size of
    # the cookieSize array
    m = len(cookieSize)

    # Sort the greed factors in ascending
    # order to try and satisfy the
    # least greedy children first
    greed.sort()

    # Sort the cookie sizes in ascending
    # order to use the smallest cookies first
    cookieSize.sort()

    # Initialize a pointer for the
    # cookieSize array, starting
    # from the first cookie
    l = 0

    # Initialize a pointer for the
    # greed array, starting from
    # the first child
    r = 0

    # Iterate while there are
    # cookies and children
    # left to consider
    while l < m and r < n:
        # If the current cookie can
        # satisfy the current child's greed
        if greed[r] <= cookieSize[l]:
            # Move to the next child,
            # as the current child is satisfied
            r += 1
        # Always move to the next cookie
        # whether the current child
        # was satisfied or not
        l += 1

    # The value of r at the end of
    # the loop represents the number
    # of children that were satisfied
    return r

if __name__ == "__main__":
    greed = [1, 5, 3, 3, 4]
    cookieSize = [4, 2, 1, 2, 1, 3]
    
    print("Array Representing Greed: ", end="")
    for g in greed:
        print(g, end=" ")
    print()
    
    print("Array Representing Cookie Size: ", end="")
    for c in cookieSize:
        print(c, end=" ")
    print()
    
    ans = findContentChildren(greed, cookieSize)
    
    print(f"\nNo. of kids assigned cookies {ans}")


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : fractional knapsack approch
'''   

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/fractional-knapsack-problem-greedy-approach/


https://practice.geeksforgeeks.org/problems/fractional-knapsack-1587115620/1

http://youtube.com/watch?v=1ibsQrnuEEg&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=295
'''
# method 1 : brute force approch
'''
make an array containg the value for 1 weight (per weight)
sort that array in desc order so that max weight will be first to add in the bucket
iterate over that array and start adding the items and also check if the weight <= to given weight
if the next item cannot weight be added in the bucket then add the fraction of the item



Time Complexity: O(n log n + n). O(n log n) to sort the items and O(n) to iterate through all the items for calculating the answer.

Space Complexity: O(1), no additional data structure has been used.
'''
class Item:
  def __init__(self, value, weight):
    self.value = value
    self.weight = weight


class Solution:
  def fractionalKnapsack(self, W, arr, n):
    arr.sort(key=lambda x: x.value / x.weight, reverse=True)
    curWeight = 0
    finalvalue = 0.0
    for i in range(n):
      if curWeight + arr[i].weight <= W:
        curWeight += arr[i].weight
        finalvalue += arr[i].value
      else:
        remain = W - curWeight
        finalvalue += arr[i].value / arr[i].weight * remain
        break
    return finalvalue

if __name__ == '__main__':
  n = 3
  W = 50
  arr = [Item(60, 10), Item(100, 20), Item(120, 30)]
  obj = Solution()
  ans = obj.fractionalKnapsack(W, arr, n)
  print("The maximum value is", ans) 


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 3 TODO : greedy algorithm to find minimum number of coins
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/find-minimum-number-of-coins/


https://www.geeksforgeeks.org/find-minimum-number-of-coins-that-make-a-change/


'''
# method 1 : brute force approch
'''
https://www.youtube.com/watch?v=mVg9CfJvayM

iterate over the array in reverse order or larger to smaller
inside the for loop again iterate utill that item is repeatedly substractable withe the give target 


Time Complexity:O(V)

Space Complexity:O(1)
'''

if __name__ == '__main__':
  V = 49
  ans = []
  coins = [1, 2, 5, 10, 20, 50, 100, 500, 1000]
  n = 9
  for i in range(n - 1, -1, -1):
    while V >= coins[i]:
      V -= coins[i]
      ans.append(coins[i])
  print("The minimum number of coins is", len(ans))
  print("The coins are")
  for i in range(len(ans)):
    print(ans[i], end=" ")  


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 4 TODO : lemonade charge
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/Greedy/lemonade-change


https://leetcode.com/problems/lemonade-change/

https://www.youtube.com/watch?v=n_tmibEhO6Q&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=286
'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''

iterate overt the array
if item == 5, increment variable 5 
if item == 10, decrement variable 5 and increment variable 10
if item == other, decrement variable 5 and 10, if not possible then decrement variable 5 three times


Time Complexity: O(N) where N is the number of people in queue/ bills we will deal with. We iterate through each customerâ€™s bills exactly once. The loop runs for N iterations and at each iteration the operations performed are constant time.

Space Complexity: O(1) as the algorithm uses only a constant amount of extra space regardless of the size of the input array. It does not require any additional data structures that scale with the input size.
'''
# Function to find whether each customer can 
# be provided with correct change
def lemonadeChange(bills):
  # Initialize a counter
  # for $5 bills
  five = 0 
  # Initialize a counter
  # for $10 bills
  ten = 0   
  # Iterate through each customer's bill
  for bill in bills:
    # If the customer's
    # bill is $5
    if bill == 5:
      # Increment the
      # count of $5 bills
      five += 1  
    
    # If the customer's
    # bill is $10
    elif bill == 10:
      # Check if there are $5
      # bills available to give change
      if five:
        # Use one $5 bill
        # to give change
        five -= 1 
        # Receive one $10 bill
        ten += 1   
    
      # If no $5 bill
      # available, return false
      else:
          return False  
    
    # If the customer's
    # bill is $20
    else:
      # Check if there are both
      # $5 and $10 bills
      # available to give change
      if five and ten:
        # Use one $5 bill
        five -= 1 
        # Use one $10 bill
        ten -= 1   
      
      # If there are not enough $10 bills,
      # check if there are at least
      # three $5 bills available
      elif five >= 3:
        # Use three $5 bills
        # to give change
        five -= 3  
      
      # If unable to give
      # change, return false
      else:
        return False  

  # Return true if all customers
  # are served with correct change
  return True  

# Main function
def main():
  bills = [5, 5, 5, 10, 20]
  print("Queues of customers:", end=" ")
  for bill in bills:
    print(bill, end=" ")
  print()
  ans = lemonadeChange(bills)
  if ans:
    print("It is possible to provide change for all customers.")
  else:
    print("It is not possible to provide change for all customers.")

# Run the main function
if __name__ == "__main__":
  main()


# 5 TODO : valid paranthesis checker
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/valid-parenthesis-string/


https://www.youtube.com/watch?v=cHT6sG_hUZI&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=294
'''
# method 1 : brute force approch
# TC     -      O(3**N)
# SC     -  O(N)   
def main_function(s, index, count, n):
    # Base case: if count is negative, return False (invalid state)
    if count < 0:
        return False
    
    # If we've reached the end of the string, check if count is 0 (balanced)
    if index == n:
        return count == 0
    
    # If the current character is '(', increment the count
    if s[index] == '(':
        return main_function(s, index + 1, count + 1, n)
    
    # If the current character is ')', decrement the count
    elif s[index] == ')':
        return main_function(s, index + 1, count - 1, n)
    
    # If the current character is '*', it can be '(', ')', or an empty string.
    # Try all three possibilities and check if any result in valid parentheses.
    return (main_function(s, index + 1, count + 1, n) or 
            main_function(s, index + 1, count - 1, n) or 
            main_function(s, index + 1, count, n))

# Wrapper function to call the recursive function
def valid_parenthesis(s):
    n = len(s)
    return main_function(s, 0, 0, n)

# Test cases
print(valid_parenthesis("(*)"))    # True
print(valid_parenthesis("(*))"))   # True
print(valid_parenthesis("((**)"))  # True
print(valid_parenthesis("(((**)")) # False



# method 2 : better approch
# TC     -      O(N)
# SC     -     O(1)
def isValidParenthesis(s: str) -> bool:
    # Greedily assume '*' as '(' (optimistic) in max_balance and ')' (pessimistic) in min_balance
    min_balance = 0   # Minimum balance (treat '*' as ')')
    max_balance = 0   # Maximum balance (treat '*' as '(')
    
    for char in s:
        if char == '(':
            min_balance += 1
            max_balance += 1
        elif char == ')':
            min_balance -= 1
            max_balance += 1
        else:  # char == '*'
            min_balance -= 1  # '*' can be treated as ')'
            max_balance += 1  # '*' can be treated as '('
        
        # Ensure min_balance doesn't go below 0 (because negative balance means more closing than opening)
        if min_balance < 0:
            min_balance = 0
        
        # If max_balance is negative, it means there are more closing than opening parentheses
        if max_balance < 0:
            return False
    
    # After processing the whole string, ensure that min_balance is 0 for balanced parentheses
    return min_balance == 0

# Test cases
print(isValidParenthesis("(*)"))    # True
print(isValidParenthesis("(*))"))   # True
print(isValidParenthesis("((**)"))  # True
print(isValidParenthesis("(((**)")) # False


# method 3 : optimal solution
# TC     -      
# SC     -      



# endregion






# region 12.2 GREEDY ALGORITHM - MEDIUM/HARD
# ------------------------------------------

# 1 TODO :  N meetings in one room
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/n-meetings-in-one-room/


https://practice.geeksforgeeks.org/problems/n-meetings-in-one-room-1587115620/1



'''
# method 1 : brute force approch
'''
https://www.youtube.com/watch?v=mKfhTotEguk&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=290

create a data structure that has start, end and the position for each item of both arrays
sort that data structure list in asc order of end time
now traverse the list and check if the start time of the next meeting is greater than the end time of the previous meeting then increment the count and update the end time with the end time of the next meeting


Time Complexity: O(n) to iterate through every position and insert them in a data structure. O(n log n)  to sort the data structure in ascending order of end time. O(n)  to iterate through the positions and check which meeting can be performed.

Overall : O(n) +O(n log n) + O(n) ~O(n log n)

Space Complexity: O(n)  since we used an additional data structure for storing the start time, end time, and meeting no.
'''
from typing import List

# Defining a class 'meeting' that will hold details for each meeting.
class meeting:
    def __init__(self, start, end, pos):
        # Constructor to initialize the start time, end time, and position (index) of the meeting.
        self.start = start  # Start time of the meeting
        self.end = end      # End time of the meeting
        self.pos = pos      # Position (or index) of the meeting

# The Solution class contains the method to find the maximum number of meetings that can be held.
class Solution:
    def maxMeetings(self, s: List[int], e: List[int], n: int) -> None:
        # Step 1: Create a list of 'meeting' objects, where each meeting contains start time, end time, and its position.
        meet = [meeting(s[i], e[i], i + 1) for i in range(n)]
        
        # Step 2: Sort the meetings list by end time (then by position as a secondary criteria).
        # This ensures we try to finish meetings as early as possible.
        sorted(meet, key=lambda x: (x.end, x.pos))
        
        # Step 3: Initialize an empty list to store the meeting indices in the order they will be performed.
        answer = []
        
        # Step 4: Set the 'limit' to the end time of the first meeting (since it starts the schedule).
        limit = meet[0].end
        
        # Step 5: Add the first meeting to the answer as it's always included.
        answer.append(meet[0].pos)
        
        # Step 6: Loop through the rest of the meetings to check if they can be scheduled after the previous meeting.
        for i in range(1, n):
            # If the start time of the current meeting is greater than the 'limit' (i.e., the end time of the previous meeting),
            # then it means we can schedule this meeting.
            if meet[i].start > limit:
                limit = meet[i].end  # Update the limit to the end time of the current meeting.
                answer.append(meet[i].pos)  # Add this meeting to the answer list.
        
        # Step 7: Print the order of meetings that can be performed.
        print("The order in which the meetings will be performed is ")
        for i in answer:
            print(i, end=" ")  # Print each meeting's position (index).

# Driver code to test the Solution class.
if __name__ == "__main__":
    obj = Solution()  # Create an instance of the Solution class.
    
    # Input: start times and end times for the meetings.
    n = 6
    start = [1, 3, 0, 5, 8, 5]  # List of start times
    end = [2, 4, 5, 7, 9, 9]    # List of end times
    
    # Call the maxMeetings method to determine the maximum number of meetings that can be held.
    obj.maxMeetings(start, end, n)



# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : jump game - I
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://takeuforward.org/Greedy/jump-game-i


https://leetcode.com/problems/jump-game/



'''
# method 1 : brute force approch
'''
https://www.youtube.com/watch?v=tZAa_jJ3SwQ&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=287



Time Complexity: O(N) where N is the length of the input array. We iterate through the input array exactly once and at each element perform constant time operations.

Space Complexity: O(1) as the algorithm uses only a constant amount of extra space regardless of the size of the input array. It does not require any additional data structures that scale with the input size.
'''
                            
def can_jump(nums):
    # Initialize the maximum
    # index that can be reached
    max_index = 0

    # Iterate through each
    # index of the array
    for i in range(len(nums)):
        # If the current index is greater
        # than the maximum reachable index
        # it means we cannot move forward
        # and should return false
        if i > max_index:
            return False

        # Update the maximum index
        # that can be reached by comparing
        # the current max_index with the sum of
        # the current index and the
        # maximum jump from that index
        max_index = max(max_index, i + nums[i])

    # If we complete the loop,
    # it means we can reach the
    # last index
    return True


def main():
    nums = [4, 3, 7, 1, 2]

    print("Array representing maximum jump from each index: ", end="")
    for i in range(len(nums)):
        print(nums[i], end=" ")
    print()

    ans = can_jump(nums)

    if ans:
        print("It is possible to reach the last index.")
    else:
        print("It is not possible to reach the last index.")


if __name__ == "__main__":
  main()


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 3 TODO : jump game - II
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/jump-game-ii/


https://www.youtube.com/watch?v=7SBVnw7GSTk&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=288
'''
# method 1 : brute force approch
# TC     -     O(N^N) 
# SC     -     O(N)

def main_function(arr, index, jumps):
  if index >= len(arr) - 1:
      return jumps
  mini = float('inf')
  for i in range(1,arr[index]+1):
    mini = min(mini,main_function(arr,index+i,jumps+1))
  return mini

arr = [2,3,1,1,4]
print(main_function(arr,0,0))

# method 2 : better approch, use DP
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      O(N)
# SC     -      O(1)
def main_function(arr):
    jumps = 0
    left = 0
    right = 0
    
    # Continue jumping until you reach the end of the array
    while right < len(arr) - 1:
        fartest = 0
        
        # Check the farthest point we can reach from current range [left, right]
        for i in range(left, right + 1):
            fartest = max(fartest, i + arr[i])
        
        # Update the left boundary for the next jump
        left = right + 1
        # Update the right boundary for the next jump
        right = fartest
        
        # Increment the jump count
        jumps += 1
    
    return jumps

# Test the function
arr = [2, 3, 4, 1, 1, 2]
print(main_function(arr))  # Expected output: 3


# 4 TODO : minimum number of platforms required for a railway station
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡




https://takeuforward.org/data-structure/minimum-number-of-platforms-required-for-a-railway/


https://practice.geeksforgeeks.org/problems/minimum-platforms-1587115620/1#

https://www.youtube.com/watch?v=AsGzwR_FWok&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=293
'''
# method 1 : brute force approch
'''
try to find the intersection of one train timmings with another


Time Complexity: O(n^2)  (due to two nested loops).

Space Complexity: O(1)  (no extra space used).
'''
def countPlatforms(n, arr, dep):
    ans = 1  # final value
    for i in range(n):
        count = 1  # count of overlapping interval of only this iteration
        for j in range(i+1, n):
            if (arr[i] >= arr[j] and arr[i] <= dep[j]) or (arr[j] >= arr[i] and arr[j] <= dep[i]):
                count += 1
        ans = max(ans, count)  # updating the value
    return ans




if __name__ == "__main__":
    arr = [900, 945, 955, 1100, 1500, 1800]
    dep = [920, 1200, 1130, 1150, 1900, 2000]
    n = len(dep)
    print("Minimum number of Platforms required", countPlatforms(n, arr, dep))


# method 2 : better approch
'''
sort both arrays
then use two pointer approach 
increment/decrement count based on the arrival/departure time of the trains 

Time Complexity: O(nlogn) Sorting takes O(nlogn) and traversal of arrays takes O(n) so overall time complexity is O(nlogn).
2(nlogn + n)

Space complexity: O(1)  (No extra space used).
'''
def countPlatforms(arr, dep):
  arr.sort()
  dep.sort()

  ans = 1
  count = 1
  i = 1
  j = 0
  while i < len(arr) and j < len(dep):
    if arr[i] <= dep[j]:  # one more platform needed
      count += 1
      i += 1
    else:  # one platform can be reduced
      count -= 1
      j += 1
    ans = max(ans, count)  # updating the value with the current maximum
  return ans




if __name__ == "__main__":
  arr = [900, 945, 955, 1100, 1500, 1800]
  dep = [920, 1200, 1130, 1150, 1900, 2000]
  print("Minimum number of Platforms required ", countPlatforms(arr, dep))


# method 3 : optimal solution
# TC     -      
# SC     -      


# 5 TODO : job sequenceing problem
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/job-sequencing-problem/


https://practice.geeksforgeeks.org/problems/job-sequencing-problem-1587115620/1#



'''
# method 1 : brute force approch
'''
https://www.youtube.com/watch?v=QbwltemZbRg&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=289


- sort the array based on the profit asc
- create a slot array of size max deadline
- iterate through the array and check if the slot is empty or not
- if empty then fill the slot and add the profit to the answer
- if not empty then check for the next slot
- return the answer

Time Complexity: O(N log N) + O(N*M).

O(N log N ) for sorting the jobs in decreasing order of profit. O(N*M) since we are iterating through all N jobs and for every job we are checking from the last deadline, say M deadlines in the worst case.

Space Complexity: O(M) for an array that keeps track of which day job is performed if M is the maximum deadline available.
'''
class job:
  def __init__(self, id, deadline, profit):
    self.id = id
    self.deadline = deadline
    self.profit = profit




class Solution:
  def jobScheduling(self, jobs):
    jobs.sort(key=lambda x: x.profit, reverse=True)
    maxi = jobs[0].deadline
    for i in range(1, len(jobs)):
      maxi = max(maxi, jobs[i].deadline)


    slot = [-1] * (maxi + 1)
    countJobs = 0
    jobProfit = 0


    for i in range(len(jobs)):
      for j in range(jobs[i].deadline, 0, -1):
        if slot[j] == -1:
          slot[j] = i
          countJobs += 1
          jobProfit += jobs[i].profit
          break

    return countJobs, jobProfit




if __name__ == "__main__":
  jobs = [job(1, 4, 20), job(2, 1, 10), job(3, 2, 40), job(4, 2, 30)]
  count, profit = Solution().jobScheduling(jobs)
  print(count, profit)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 6 TODO : candy
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://leetcode.com/problems/candy/



https://www.youtube.com/watch?v=IIqVFvKE6RY&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=296
'''
# method 1 : brute force approch
# TC     -      O(3N)
# SC     -     O(2N)
def main_function(arr):
  left_arr = [0]*len(arr)
  right_arr = [0]*len(arr)
  left_arr[0] = 1 
  right_arr[len(arr) - 1] = 1 
  
  for i in range(1, len(arr)):
    if arr[i] > arr[i-1]:
      left_arr[i] = left_arr[i-1] + 1 
    else:
      left_arr[i] = 1
      
  for i in range(len(arr) - 2, 0, -1 ):
    if arr[i] > arr[i+1]:
      right_arr[i] = right_arr[i+1] + 1 
    else:
      left_arr[i] = 1
  
  sum = 0
  for i in range(len(arr)):
    sum = sum + max(left_arr[i], right_arr[i])
    
  return sum

arr = [0,2,4,3,2,1,1,3,5,6,4,0,0]
print(main_function(arr))

# method 2 : better approch
# TC     -      O(2N)
# SC     -     O(N)   
# âŒâŒâŒ
# def main_function(arr):
#   left_arr = [0]*len(arr)
#   right_arr = [0]*len(arr)
#   left_arr[0] = 1 
#   right_arr[len(arr) - 1] = 1 
  
#   for i in range(1, len(arr)):
#     if arr[i] > arr[i-1]:
#       left_arr[i] = left_arr[i-1] + 1 
#     else:
#       left_arr[i] = 1
  
#   current =  1 
#   sum  = max(1, left_arr[len(arr) - 1])
#   right = 1
#   for i in range(len(arr) - 2, -1, -1 ):
#     if arr[i] > arr[i+1]:
#       current = right + 1
#       right = current
#     else:
#       current = 1
#     sum = sum + max(current, left_arr[i])
  
    
#   return sum

# arr = [0,2,4,3,2,1,1,3,5,6,4,0,0]
# print(main_function(arr))

# method 3 : optimal solution
# TC     -      O(N)
# SC     -      O(1)
def main_function(arr):
  sum  = 1 
  i = 1
  n = len(arr)
  while i < n:
    if arr[i] == arr[i-1]:
      sum = sum + 1 
      i +=1
      continue
    peak = 1 
    while i < n and arr[i] > arr[i-1]:
      peak +=1 
      sum = sum + peak
      i +=1
    down = 1
    while i < n and arr[i] < arr[i-1]:
      down +=1 
      sum = sum + down
      i +=1
    if down > peak:
      sum = sum + (down -peak)
  
  return sum

arr = [0,2,4,3,2,1,1,3,5,6,4,0,0]
print(main_function(arr))


# 7 TODO : program for shortest job (one SNF) CPU scheduling
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/Greedy/shortest-job-first-or-sjf-cpu-scheduling


https://bit.ly/3DYCIFb




https://www.youtube.com/watch?v=3-QbX1iDbXs&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=285

SJF - scheduling policy that selects the waiting process with the smallest execution time to execute next.
'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''

- sort the array in asc
- create a variable to store the wait time, and a variable to store the total time
- iterate through the array and add the total time to the wait time then after that add the execution time to the total time
- return the wait time by averaging the wait time by the length of the array

Time Complexity: O(N logN + N) where N is the length of the jobs array. We sort the jobs array giving complexity O(N log N) and to calculate the waiting time we iterate through the sorted array taking O(N) complexity.

Space Complexity: O(1) as the algorithm uses only a constant amount of extra space regardless of the size of the input array. It does not require any additional data structures that scale with the input size.
'''
# Function to calculate average
# waiting time using Shortest
# Job First algorithm
def shortest_job_first(jobs):
    # Sort the jobs in ascending order
    jobs.sort()

    # Initialize total waiting time
    wait_time = 0
    # Initialize total time taken
    total_time = 0
    # Get the number of jobs
    n = len(jobs)

    # Iterate through each job
    # to calculate waiting time
    for i in range(n):

        # Add current total
        # time to waiting time
        wait_time += total_time

        # Add current job's
        # time to total time
        total_time += jobs[i]

    # Return the average waiting time
    return wait_time / n

if __name__ == "__main__":
    jobs = [4, 3, 7, 1, 2]

    print("Array Representing Job Durations:", end=" ")
    for job in jobs:
        print(job, end=" ")
    print()

    ans = shortest_job_first(jobs)
    print("Average waiting time:", ans)


# 8 TODO : program for least recently used (LRU) page replacement algorithm
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://bit.ly/3dtFqHG


'''
# method 1 : brute force approch
'''
Time Complexity:

get(page): O(1) â€” both accessing the page in the hash map and updating the deque are constant time operations.
put(page, value): O(1) â€” both adding a page to the cache and moving it in the deque are constant time operations.
Space Complexity:

O(capacity) â€” The space is used by both the cache (hash map) and the order deque, which together store up to the capacity number of pages.

''' 
from collections import deque

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity  # Maximum number of pages in memory
        self.cache = {}           # Stores page data
        self.order = deque()      # Stores the order of pages (most recently used at the front)

    def get(self, page: int) -> int:
        if page in self.cache:
            # If page is in memory, move it to the front (most recently used)
            self.order.remove(page)
            self.order.appendleft(page)
            return self.cache[page]
        return -1  # Return -1 if page is not found in memory

    def put(self, page: int, value: int) -> None:
        if page in self.cache:
            # If page is already in memory, update the value and move it to the front
            self.cache[page] = value
            self.order.remove(page)
        elif len(self.cache) >= self.capacity:
            # If the cache is full, evict the least recently used page
            lru_page = self.order.pop()  # Remove from the back (least recently used)
            del self.cache[lru_page]     # Delete from the cache
        # Add the new page to memory and mark it as most recently used
        self.cache[page] = value
        self.order.appendleft(page)

    def __str__(self):
        # Return the current state of cache and the order of pages
        return f"Cache: {self.cache}, Order: {list(self.order)}"

# Example usage
lru_cache = LRUCache(3)
lru_cache.put(1, 1)
lru_cache.put(2, 2)
lru_cache.put(3, 3)
print(lru_cache)  # Cache: {1: 1, 2: 2, 3: 3}, Order: [3, 2, 1]

lru_cache.get(1)  # Access page 1 (it becomes most recently used)
print(lru_cache)  # Cache: {1: 1, 2: 2, 3: 3}, Order: [1, 3, 2]

lru_cache.put(4, 4)  # Add new page and evict least recently used page (2)
print(lru_cache)  # Cache: {1: 1, 3: 3, 4: 4}, Order: [4, 1, 3]


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 9 TODO : insert interval
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/?s=Insert+Interval


https://leetcode.com/problems/insert-interval/


https://www.youtube.com/watch?v=xxRE-46OCC8&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=292
'''
# method 1 : brute force approch
# TC     -      O(N)
# SC     -     O(N)
def main_function(arr, new_interval):
    res = []
    i = 0  # Start from the first interval
    n = len(arr)
    
    # First loop: Add all intervals that end before the new_interval starts.
    while i < n and arr[i][1] < new_interval[0]:
        res.append(arr[i])
        i += 1
    
    # Second loop: Merge overlapping intervals.
    while i < n and arr[i][0] <= new_interval[1]:
        new_interval[0] = min(new_interval[0], arr[i][0])
        new_interval[1] = max(new_interval[1], arr[i][1])
        i += 1
    
    # Add the merged new_interval.
    res.append(new_interval)
    
    # Third loop: Add all remaining intervals.
    while i < n:
        res.append(arr[i])
        i += 1
    
    return res

# Test case
interval = [[1, 2], [3, 4], [5, 7], [8, 10], [12, 16]]
new_interval = [6, 8]
print(main_function(interval, new_interval))


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 10 TODO :  merge intervals
# method 1 : brute force approch
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/merge-overlapping-sub-intervals/


https://leetcode.com/problems/merge-intervals/


https://www.youtube.com/watch?v=2JzRBPFYbKE

- sort the array in asc order
- create a variable to store the result
- iterate through the array and check if the current interval's start is less than the previous interval's end. if yes then, merge the intervals by updating the end of the previous interval to the maximum of the current interval's end and the previous interval's end.
- else, append the current interval to the result
- return the result

Time Complexity: O(N*logN) + O(2*N), where N = the size of the given array.
Reason: Sorting the given array takes  O(N*logN) time complexity. Now, after that, we are using 2 loops i and j. But while using loop i, we skip all the intervals that are merged with loop j. So, we can conclude that every interval is roughly visited twice(roughly, once for checking or skipping and once for merging). So, the time complexity will be 2*N instead of N2.

Space Complexity: O(N), as we are using an answer list to store the merged intervals. Except for the answer array, we are not using any extra space.
'''


from typing import List

def mergeOverlappingIntervals(arr: List[List[int]]) -> List[List[int]]:
    n = len(arr) # size of the array

    # sort the given intervals:
    arr.sort()

    ans = []

    for i in range(n): # select an interval:
        start, end = arr[i][0], arr[i][1]

        # Skip all the merged intervals:
        if ans and end <= ans[-1][1]:
            continue

        # check the rest of the intervals:
        for j in range(i + 1, n):
            if arr[j][0] <= end:
                end = max(end, arr[j][1])
            else:
                break
        ans.append([start, end])
    return ans

if __name__ == '__main__':
    arr = [[1, 3], [8, 10], [2, 6], [15, 18]]
    ans = mergeOverlappingIntervals(arr)
    print("The merged intervals are:")
    for it in ans:
        print(f"[{it[0]}, {it[1]}]", end=" ")
    print()


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(N*logN) + O(N), where N = the size of the given array.
Reason: Sorting the given array takes  O(N*logN) time complexity. Now, after that, we are just using a single loop that runs for N times. So, the time complexity will be O(N).

Space Complexity: O(N), as we are using an answer list to store the merged intervals. Except for the answer array, we are not using any extra space.
'''



from typing import List

def mergeOverlappingIntervals(arr: List[List[int]]) -> List[List[int]]:
    n = len(arr) # size of the array

    # sort the given intervals:
    arr.sort()

    ans = []

    for i in range(n):
        # if the current interval does not
        # lie in the last interval:
        if not ans or arr[i][0] > ans[-1][1]:
            ans.append(arr[i])
        # if the current interval
        # lies in the last interval:
        else:
            ans[-1][1] = max(ans[-1][1], arr[i][1])
    return ans

if __name__ == '__main__':
    arr = [[1, 3], [8, 10], [2, 6], [15, 18]]
    ans = mergeOverlappingIntervals(arr)
    print("The merged intervals are:")
    for it in ans:
        print(f"[{it[0]}, {it[1]}]", end=" ")
    print()



# 11 TODO : non-overlapping intervals
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/non-overlapping-intervals/

https://www.youtube.com/watch?v=HDHQ8lAWakY&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=291



like question no 1 

sort the interval 
'''
# method 1 : brute force approch
'''
Time Complexity:

Sorting the intervals takes O(n log n) where n is the number of intervals.
The iteration through the intervals takes O(n).
Therefore, the overall time complexity is O(n log n).
Space Complexity:

The space complexity is O(1) if we only count the selected intervals in place (not using extra space for sorting). However, if sorting involves additional space, it will be O(n) due to the space used by the sorting algorithm.

'''  
def eraseOverlapIntervals(intervals):
    if not intervals:
        return 0
    
    # Step 1: Sort intervals based on their end time
    intervals.sort(key=lambda x: x[1])
    
    # Step 2: Initialize variables
    count = 1  # Start with the first interval
    last_end = intervals[0][1]  # End time of the first interval
    
    # Step 3: Iterate through the remaining intervals
    for i in range(1, len(intervals)):
        # If the start time of the current interval is >= last end time, we can include it
        if intervals[i][0] >= last_end:
            count += 1
            last_end = intervals[i][1]  # Update the end time
    
    # Step 4: Return the number of non-overlapping intervals
    return len(intervals) - count  # We need to remove the remaining intervals

# Example usage
intervals = [[1, 2], [2, 3], [3, 4], [1, 3]]
result = eraseOverlapIntervals(intervals)
print("Number of intervals to remove:", result)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      



# endregion






# region 13.1 BINARY TREES - TRAVERSALS
# -------------------------------------

# 1 TODO :  introduction to trees
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/data-structure/merge-overlapping-sub-intervals/


https://bit.ly/3EsRmTM

https://www.youtube.com/watch?v=_ANrF3FJm7I&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=73
'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : binary tree representation in C++
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/binary-tree/binary-tree-representation-in-c/


https://bit.ly/3gn5Soh

# https://www.youtube.com/watch?v=ctCpP0RFDFc&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=74
'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 3 TODO : binary tree representation in java
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/binary-tree/binary-tree-representation-in-java/


https://bit.ly/3gn5Soh


https://www.youtube.com/watch?v=hyLyW7rP24I&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=75
'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 4 TODO : binary tree traversals in binary tree
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/binary-tree/binary-tree-traversal-inorder-preorder-postorder/


https://www.codingninjas.com/codestudio/problems/tree-traversal_981269?utm_source=striver&utm_medium=website&utm_campaign=a_zcoursetuf

https://www.youtube.com/watch?v=jmy0LaGET1I&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=76

DFS (Depth First Search) - inorder (left root right), pre-order (root left right), post-order (left right root)
BFS (Breadth First Search) - write values levelwise
'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 5 TODO : preorder traversals of binary tree
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/data-structure/preorder-traversal-of-binary-tree/


https://leetcode.com/problems/binary-tree-preorder-traversal/


'''
# method 1 : brute force approch
'''
https://www.youtube.com/watch?v=EoAsWbO7sqg&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=77


Time Complexity: O(N) where N is the number of nodes in the binary tree as each node of the binary tree is visited exactly once.

Space Complexity: O(N) where N is the number of nodes in the binary tree as an additional space for array is allocated to store the values of all â€˜Nâ€™ nodes of the binary tree.
'''              
# Node class for
# the binary tree
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

# Function to perform preorder traversal of the tree and store values in 'arr'
def preorder(root, arr):
    # If the current node is None
    # (base case for recursion), return
    if not root:
        return
    # Append the current node's
    # value into the list
    arr.append(root.data)
    # Recursively traverse
    # the left subtree
    preorder(root.left, arr)
    # Recursively traverse
    # the right subtree
    preorder(root.right, arr)

# Function to initiate preorder traversal
# and return the resulting list
def preOrder(root):
    # Create an empty list to
    # store preorder traversal values
    arr = []
    # Call the preorder traversal function
    preorder(root, arr)
    # Return the resulting list
    # containing preorder traversal values
    return arr

# Main function
if __name__ == "__main__":
    # Creating a sample binary tree
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)

    # Getting preorder traversal
    result = preOrder(root)

    # Displaying the preorder traversal result
    print("Preorder Traversal:", end=" ")
    # Output each value in the
    # preorder traversal result
    for val in result:
        print(val, end=" ")
    print()


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 6 TODO : inorder traversal of binary tree
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/data-structure/inorder-traversal-of-binary-tree/


https://leetcode.com/problems/binary-tree-inorder-traversal/


'''
# method 1 : brute force approch
'''
https://www.youtube.com/watch?v=EoAsWbO7sqg&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=78
Time Complexity: O(N) where N is the number of nodes in the binary tree as each node of the binary tree is visited exactly once.

Space Complexity: O(N) where N is the number of nodes in the binary tree. This is because the recursive stack uses an auxiliary space which can potentially hold all nodes in the tree when dealing with a skewed tree (all nodes have only one child), consuming space proportional to the number of nodes.In the average case or for a balanced tree, the maximum number of nodes that could be in the stack at any given time would be roughly the height of the tree hence O(log2N).
'''
                            
# Node class for the binary tree
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

# Function to perform inorder traversal
# of the tree and store values in 'arr'
def inorder(root, arr):
    # If the current node is None
    # (base case for recursion), return
    if root is None:
        return
    # Recursively traverse the left subtree
    inorder(root.left, arr)
    # Append the current node's
    # value into the list
    arr.append(root.data)
    # Recursively traverse 
    # the right subtree
    inorder(root.right, arr)

# Function to initiate inorder traversal
# and return the resulting list
def in_order(root):
    # Create an empty list to
    # store inorder traversal values
    arr = []
    # Call the inorder traversal function
    inorder(root, arr)
    # Return the resulting list
    # containing inorder traversal values
    return arr

# Main function
if __name__ == "__main__":
    # Creating a sample binary tree
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)

    # Getting inorder traversal
    result = in_order(root)

    # Displaying the inorder traversal result
    print("Inorder Traversal:", end=" ")
    # Output each value in the
    # inorder traversal result
    for val in result:
        print(val, end=" ")
    print()


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 7 TODO : post order traversal of binary tree
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/data-structure/post-order-traversal-of-binary-tree/


https://leetcode.com/problems/binary-tree-postorder-traversal/


'''
# method 1 : brute force approch
'''
https://www.youtube.com/watch?v=EoAsWbO7sqg&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=79


Time Complexity: O(N) where N is the number of nodes in the binary tree as each node of the binary tree is visited exactly once.

Space Complexity: O(N) where N is the number of nodes in the binary tree as an additional space for array is allocated to store the values of all â€˜Nâ€™ nodes of the binary tree.
'''
# Node class for the binary tree
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

# Function to perform postorder
# traversal recursively
def postorder(root, arr):
    # Base case: if root is None, return
    if root is None:
        return
    # Traverse left subtree
    postorder(root.left, arr)
    # Traverse right subtree
    postorder(root.right, arr)
    # Visit the node
    # (append node's data to the list)
    arr.append(root.data)

# Function to get the postorder
# traversal of a binary tree
def postOrder(root):
    # Create a list to
    # store the traversal result
    arr = []
    # Perform postorder traversal
    # starting from the root
    postorder(root, arr)
    # Return the postorder
    # traversal result
    return arr

# Function to print the
# elements of a list
def printList(lst):
    # Iterate through the list
    # and print each element
    for num in lst:
        print(num, end=" ")
    print()

# Main function
if __name__ == "__main__":
    # Creating a sample binary tree
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)

    # Getting postorder traversal
    result = postOrder(root)

    # Printing the postorder
    # traversal result
    print("Postorder traversal: ", end="")
    printList(result)



# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 8 TODO : level order traversal / level order traversal in spiral form
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/data-structure/level-order-traversal-of-a-binary-tree/


https://leetcode.com/problems/binary-tree-level-order-traversal/



'''
# method 1 : brute force approch
'''
https://www.youtube.com/watch?v=EoAsWbO7sqg&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=80


Time Complexity: O(N) where N is the number of nodes in the binary tree. Each node of the binary tree is enqueued and dequeued exactly once, hence all nodes need to be processed and visited. Processing each node takes constant time operations which contributes to the overall linear time complexity.

Space Complexity: O(N) where N is the number of nodes in the binary tree. In the worst case, the queue has to hold all the nodes of the last level of the binary tree, the last level could at most hold N/2 nodes hence the space complexity of the queue is proportional to O(N).The resultant vector answer also stores the values of the nodes level by level and hence contains all the nodes of the tree contributing to O(N) space as well.
'''
from collections import deque

# TreeNode class represents
# a node in a binary tree
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def levelOrder(self, root):
        # Create a list to store levels
        ans = []
        if not root:
            # If the tree is empty,
            # return an empty list
            return ans

        # Create a queue to store nodes
        # for level-order traversal
        q = deque()
        # Enqueue the root node
        q.append(root)

        while q:
            # Get the size of the current level
            size = len(q)
            # Create a list to store
            # nodes at the current level
            level = []

            for i in range(size):
                # Get the front node in the queue
                node = q.popleft()
                # Store the node value
                # in the current level list
                level.append(node.val)

                # Enqueue the child nodes if they exist
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)

            # Store the current level
            # in the answer list
            ans.append(level)
        # Return the level-order
        # traversal of the tree
        return ans

# Function to print
# the elements of a list
def printList(lst):
    # Iterate through the
    # list and print each element
    for num in lst:
        print(num, end=" ")
    print()

# Main function
if __name__ == "__main__":
    # Creating a sample binary tree
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)

    # Create an instance
    # of the Solution class
    solution = Solution()
    # Perform level-order traversal
    result = solution.levelOrder(root)

    print("Level Order Traversal of Tree:")

    # Printing the level order traversal result
    for level in result:
        printList(level)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 9 TODO : iterative preorder traversal of binary tree
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/data-structure/iterative-preorder-traversal-of-binary-tree


https://leetcode.com/problems/binary-tree-preorder-traversal/


'''
# method 1 : brute force approch
'''
https://www.youtube.com/watch?v=Bfqd8BsPVuw&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=81


Time Complexity: O(N) where N is the number of nodes in the binary tree. Every node of the binary tree is visited exactly once, and for each node, , the operations performed (pushing and popping from the stack, accessing node values, etc.) are constant time operations.

Space Complexity: O(N) where N is the number of nodes in the binary tree. This is because the stack can potentially hold all nodes in the tree when dealing with a skewed tree (all nodes have only one child), consuming space proportional to the number of nodes.

'''
from typing import List

# Define the TreeNode structure
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    # Function to perform preorder traversal
    # of a binary tree iteratively
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        # Initialize list to store
        # the preorder traversal result
        preorder = []
        
        # If the root is None, return
        # an empty traversal result
        if root is None:
            return preorder
        
        # Create a stack to store
        # nodes during traversal
        st = []
        # Push the root node
        # onto the stack
        st.append(root)
        
        # Perform iterative preorder traversal
        while st:
            # Get the current node
            # from the top of the stack
            root = st.pop()
            
            # Add the node's value to
            # the preorder traversal result
            preorder.append(root.val)
            
            # Push the right child
            # onto the stack if exists
            if root.right:
                st.append(root.right)
            
            # Push the left child onto
            # the stack if exists
            if root.left:
                st.append(root.left)
        
        # Return the preorder
        # traversal result
        return preorder

# Creating a binary tree
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

# Initializing the Solution class
sol = Solution()

# Getting the preorder traversal
result = sol.preorderTraversal(root)

# Displaying the preorder traversal result
print("Preorder Traversal:", end=" ")
for val in result:
    print(val, end=" ")
print()



# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 10 TODO :  iterative inorder traversal of binary tree
'''


ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢



https://takeuforward.org/data-structure/inorder-traversal-of-binary-tree/


https://leetcode.com/problems/binary-tree-inorder-traversal/



'''
# method 1 : brute force approch
'''
https://www.youtube.com/watch?v=Bfqd8BsPVuw&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=82


Time Complexity: O(N) where N is the number of nodes in the binary tree as each node of the binary tree is visited exactly once.

Space Complexity: O(N) where N is the number of nodes in the binary tree. This is because the recursive stack uses an auxiliary space which can potentially hold all nodes in the tree when dealing with a skewed tree (all nodes have only one child), consuming space proportional to the number of nodes.In the average case or for a balanced tree, the maximum number of nodes that could be in the stack at any given time would be roughly the height of the tree hence O(log2N).
'''
from typing import List

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    # Function to perform inorder traversal
    # of a binary tree iteratively
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        # Initialize list to store
        # the inorder traversal result
        inorder = []
        
        # If the root is None, return
        # an empty traversal result
        if root is None:
            return inorder
        
        # Create a stack to store
        # nodes during traversal
        st = []
        
        # Set the current node to root
        current = root
        
        # Perform iterative inorder traversal
        while current is not None or st:
            # Reach the leftmost node of the current node
            while current:
                # Push the current node to the stack
                st.append(current)
                # Move to the left child
                current = current.left
            
            # Pop the node from the stack
            current = st.pop()
            
            # Add the node's value to the inorder traversal result
            inorder.append(current.val)
            
            # Move to the right child
            current = current.right
        
        # Return the inorder traversal result
        return inorder

# Creating a binary tree
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

# Initializing the Solution class
sol = Solution()

# Getting the inorder traversal
result = sol.inorderTraversal(root)

# Displaying the inorder traversal result
print("Inorder Traversal:", end=" ")
for val in result:
    print(val, end=" ")
print()

# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 11 TODO : post order traversal of binary tree using 2-stack
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/data-structure/iterative-postorder-traversal-of-binary-tree-using-2-stack


https://leetcode.com/problems/binary-tree-postorder-traversal/


https://www.youtube.com/watch?v=Bfqd8BsPVuw&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=82

'''
# method 1 : brute force approch
'''

Time Complexity: O(2N) where N is the number of nodes in the Binary Tree. The traversal process visits each node in the Binary Tree exactly once to push into stack1 and stack2. Then after the tree is traversed and the nodes are popped from stack2 to push into the postorder array.

Space Complexity: O(2N) where N is the number of nodes in the Binary Tree. The space occupied by the two stacks depend on the height of the binary tree. In the worst-case scenario, if the tree is skewed, the space complexity would be O(N) as both stacks could potentially hold all nodes at different points during traversal.The postorder array also holds all nodes from the binary tree hence giving another O(N) + O(N) ~ O(2N).
'''
                            
# Node class for the binary tree
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

# Function to return the postOrder
# traversal of a binary tree using
# two stacks
def postOrder(root):
    # Vector to store
    # postorder traversal
    postorder = []

    # If the tree is empty,
    # return an empty traversal
    if root is None:
        return postorder

    # Two stacks for
    # iterative traversal
    st1, st2 = [], []

    # Push the root node
    # onto the first stack
    st1.append(root)

    # Iterative traversal to populate
    # st2 with nodes in postorder
    while st1:
        # Get the top node from st1
        root = st1.pop()

        # Push the node onto st2
        st2.append(root)

        # Push left child onto st1 if exists
        if root.left is not None:
            st1.append(root.left)

        # Push right child onto st1 if exists
        if root.right is not None:
            st1.append(root.right)

    # Populate the postorder traversal
    # list by popping st2
    while st2:
        postorder.append(st2[-1].data)
        st2.pop()

    # Return the
    # postorder traversal
    return postorder


# Function to print the
# elements of a list
def printList(lst):
    # Iterate through the list
    # and print each element
    for num in lst:
        print(num, end=" ")
    print()

# Main function
if __name__ == "__main__":
    # Creating a sample binary tree
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)

    # Getting postorder traversal
    result = postOrder(root)

    # Printing the postorder
    # traversal result
    print("Postorder traversal: ", end="")
    printList(result)



# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 12 TODO : post-order traversal of binary tree using 1 stack
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/post-order-traversal-of-binary-tree/


https://leetcode.com/problems/binary-tree-postorder-traversal/


https://www.youtube.com/watch?v=Bfqd8BsPVuw&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=83

'''
# method 1 : brute force approch
'''

Time Complexity: O(N) where N is the number of nodes in the binary tree as each node of the binary tree is visited exactly once.

Space Complexity: O(N) where N is the number of nodes in the binary tree as an additional space for array is allocated to store the values of all â€˜Nâ€™ nodes of the binary tree.
'''
from typing import List

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    # Function to perform postorder traversal
    # of a binary tree iteratively using one stack
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        # Initialize list to store
        # the postorder traversal result
        postorder = []
        
        # If the root is None, return
        # an empty traversal result
        if root is None:
            return postorder
        
        # Create a stack to store nodes during traversal
        st = []
        # Push the root node onto the stack
        st.append(root)
        
        # Traverse the tree iteratively
        while st:
            # Get the current node from the top of the stack
            node = st.pop()
            
            # Add the node's value to the postorder result
            # We will add it in reverse order initially
            postorder.append(node.val)
            
            # Push the left child onto the stack if exists
            if node.left:
                st.append(node.left)
            
            # Push the right child onto the stack if exists
            if node.right:
                st.append(node.right)
        
        # Postorder is added in root-right-left order,
        # so we reverse it to get left-right-root order
        postorder.reverse()
        
        # Return the postorder traversal result
        return postorder

# Creating a binary tree
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

# Initializing the Solution class
sol = Solution()

# Getting the postorder traversal
result = sol.postorderTraversal(root)

# Displaying the postorder traversal result
print("Postorder Traversal:", end=" ")
for val in result:
    print(val, end=" ")
print()

# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 13 TODO : preorder, inorder and post order traversal in one traversal
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/preorder-inorder-postorder-traversals-in-one-traversal/


https://bit.ly/3T3oW9M


https://www.youtube.com/watch?v=ySp2epYvgTE&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=85

'''
# method 1 : brute force approch
'''

Time Complexity: O(3N) where N is the number of nodes in the Binary Tree. Each node is processed once for each traversal type (pre-order, in-order, and post-order). Hence, the algorithm effectively visits each node three times in total across the three traversal types.

Space Complexity: O(4N) where N is the number of nodes in the Binary Tree. The following additional data structures are used:A stack to maintain traversal states, requiring additional space proportional to the maximum number of nodes in the stack at any point during traversal.Three vectors to store the preorder, inorder and postorder traversal. These arrays collectively occupy space proportional to the total number of nodes in the tree. Hence, 3N is added to the space complexity.
'''

# Node class for the binary tree
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

# Function to get the Preorder,
# Inorder and Postorder traversal
# Of Binary Tree in One traversal
def pre_in_post_traversal(root):
    # Lists to store traversals
    pre, in_order, post = [], [], []

    # If the tree is empty,
    # return empty traversals
    if root is None:
        return []

    # Stack to maintain nodes
    # and their traversal state
    stack = [(root, 1)]

    while stack:
        node, state = stack.pop()

        # this is part of pre
        if state == 1:
            # Store the node's data
            # in the preorder traversal
            pre.append(node.data)
            # Move to state 2
            # (inorder) for this node
            state = 2
            # Push the updated state
            # back onto the stack
            stack.append((node, state))

            # Push left child onto
            # the stack for processing
            if node.left:
                stack.append((node.left, 1))

        # this is a part of in
        elif state == 2:
            # Store the node's data
            # in the inorder traversal
            in_order.append(node.data)
            # Move to state 3
            # (postorder) for this node
            state = 3
            # Push the updated state
            # back onto the stack
            stack.append((node, state))

            # Push right child onto
            # the stack for processing
            if node.right:
                stack.append((node.right, 1))

        # this is part of post
        else:
            # Store the node's data
            # in the postorder traversal
            post.append(node.data)

    # Returning the traversals
    return [pre, in_order, post]

# Function to print the
# elements of a list
def print_list(lst):
    # Iterate through the list
    # and print each element
    for num in lst:
        print(num, end=" ")
    print()

# Main function
if __name__ == "__main__":
    # Creating a sample binary tree
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)

    # Getting the pre-order, in-order,
    # and post-order traversals
    traversals = pre_in_post_traversal(root)

    # Extracting the traversals
    # from the result
    pre, in_order, post = traversals

    # Printing the traversals
    print("Preorder traversal: ", end="")
    print_list(pre)

    print("Inorder traversal: ", end="")
    print_list(in_order)

    print("Postorder traversal: ", end="")
    print_list(post)



# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# endregion






# region 13.2 BINARY TREES - MEDIUM
# ----------------------------------

# 1 TODO :  height/depth of a binary tree
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/maximum-depth-of-a-binary-tree/


https://leetcode.com/problems/maximum-depth-of-binary-tree/

https://www.youtube.com/watch?v=eD3tmO66aBA&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=86

'''
# method 1 : brute force approch
'''


1 + max(left_depth, right_depth)

Time Complexity: O(N) where N is the number of nodes in the Binary Tree. This complexity arises from visiting each node exactly once during the traversal to determine the maximum depth.

Space Complexity: O(N) where N is the number of nodes in the Binary Tree because in the worst case scenario the tree is balanced and has N/2 nodes in its last level which will have to be stored in the queue.
'''
# Iterative approch
from queue import Queue

# Node class for the binary tree
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

class Solution:
    # Function to find the
    # maximum depth of a binary tree
    # using level order traversal
    def maxDepth(self, root):
        # If the root is NULL
        # (empty tree), depth is 0
        if root is None:
            return 0
        
        # Create a queue for
        # level order traversal
        q = Queue()
        level = 0
        
        # Push the root node into the queue
        q.put(root)
        
        # While there are nodes in the queue
        while not q.empty():
            # Get the number of nodes
            # at the current level
            size = q.qsize()
            
            # Process all nodes
            # at the current level
            for i in range(size):
                # Get the front node in the queue
                front = q.get()
                
                # Enqueue left child if exists
                if front.left is not None:
                    q.put(front.left)
                
                # Enqueue right child if exists
                if front.right is not None:
                    q.put(front.right)
            
            # Increment level to
            # move to the next level
            level += 1
        
        # Return the level, which represents
        # the maximum depth of the tree
        return level

# Creating a sample binary tree
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
root.left.right.right = Node(6)
root.left.right.right.right = Node(7)

solution = Solution()
depth = solution.maxDepth(root)

print("Maximum depth of the binary tree:", depth)

# Recursive approch (recommended)
'''
1 + max(left_depth, right_depth)

Time Complexity: O(N) where N is the number of nodes in the Binary Tree. This complexity arises from visiting each node exactly once during the traversal to determine the maximum depth.

Space Complexity: O(N) where N is the number of nodes in the Binary Tree because in the worst case scenario the tree is balanced and has N/2 nodes in its last level which will have to be stored in the queue.
'''
# Node class for the binary tree
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

class Solution:
    # Function to find the maximum depth (height) of a binary tree using recursion
    def maxDepth(self, root):
        # If the root is None (empty tree), depth is 0
        if root is None:
            return 0
        
        # Recursively find the height of the left and right subtrees
        left_depth = self.maxDepth(root.left)
        right_depth = self.maxDepth(root.right)
        
        # The height of the current tree is 1 + the maximum of the left and right subtrees' heights
        return 1 + max(left_depth, right_depth)

# Creating a sample binary tree
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
root.left.right.right = Node(6)
root.left.right.right.right = Node(7)

solution = Solution()
depth = solution.maxDepth(root)

print("Maximum depth (height) of the binary tree:", depth)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : check if the binary tree is height-balanced or not
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://takeuforward.org/data-structure/check-if-the-binary-tree-is-balanced-binary-tree/


https://leetcode.com/problems/balanced-binary-tree/


https://www.youtube.com/watch?v=Yt50Jfbd8Po&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=87

'''
# method 1 : brute force approch
'''
balance binary tree -> for every node, height(left) - height(right) <= 1


abs(leftHeight - rightHeight) <= 1

Time Complexity: O(N2) where N is the number of nodes in the Binary Tree.This arises as we calculate the height of each node and to calculate the height for each node, we traverse the tree which is proportional to the number of nodes. Since this calculation is performed for each node in the tree, the complexity becomes: O(N x N) ~ O(N2).

Space Complexity : O(1) as no additional data structures or memory is allocated.O(H): Recursive Stack Space is used to calculate the height of the tree at each node which is proportional to the height of the tree.The recursive nature of the getHeight function, which incurs space on the call stack for each recursive call until it reaches the leaf nodes or the height of the tree.
'''

# Node structure for the binary tree
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

class Solution:
    # Function to check if a binary tree is balanced
    def isBalanced(self, root):
        # If the tree is empty, it's balanced
        if not root:
            return True
        
        # Calculate the height of left and right subtrees
        leftHeight = self.getHeight(root.left)
        rightHeight = self.getHeight(root.right)

        # Check if the absolute difference in heights
        # of left and right subtrees is <= 1
        if abs(leftHeight - rightHeight) <= 1 \
            and self.isBalanced(root.left) \
            and self.isBalanced(root.right):
            return True

        # If any condition fails, the tree is unbalanced
        return False

    # Function to calculate the height of a subtree
    def getHeight(self, root):
        # Base case: if the current node is NULL,
        # return 0 (height of an empty tree)
        if not root:
            return 0
        
        # Recursively calculate the height
        # of left and right subtrees
        leftHeight = self.getHeight(root.left)
        rightHeight = self.getHeight(root.right)
        
        # Return the maximum height of left and right subtrees
        # plus 1 (to account for the current node)
        return max(leftHeight, rightHeight) + 1

# Creating a sample binary tree
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
root.left.right.right = Node(6)
root.left.right.right.right = Node(7)

# Creating an instance of the Solution class
solution = Solution()

# Checking if the tree is balanced
if solution.isBalanced(root):
    print("The tree is balanced.")
else:
    print("The tree is not balanced.")


# method 2 : better approch
'''
Time Complexity: O(N) where N is the number of nodes in the Binary Tree. This complexity arises from visiting each node exactly once during the postorder traversal.

Space Complexity : O(1) as no additional space or data structures is created that is proportional to the input size of the tree. O(H) Recursive Stack Auxiliary Space : The recursion stack space is determined by the maximum depth of the recursion, which is the height of the binary tree denoted as H. In the balanced case it is log2N and in the worst case its N.
'''

# Node class for the binary tree
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

class Solution:
    # Function to check if a binary tree is balanced
    def isBalanced(self, root):
        # Check if the tree's height difference
        # between subtrees is less than 2
        # If not, return False; otherwise, return True
        return self.dfsHeight(root) != -1

    # Recursive function to calculate
    # the height of the tree
    def dfsHeight(self, root):
        # Base case: if the current node is None,
        # return 0 (height of an empty tree)
        if not root:
            return 0

        # Recursively calculate the
        # height of the left subtree
        left_height = self.dfsHeight(root.left)

        # If the left subtree is unbalanced,
        # propagate the unbalance status
        if left_height == -1:
            return -1

        # Recursively calculate the
        # height of the right subtree
        right_height = self.dfsHeight(root.right)

        # If the right subtree is unbalanced,
        # propagate the unbalance status
        if right_height == -1:
            return -1

        # Check if the difference in height between
        # left and right subtrees is greater than 1
        # If it's greater, the tree is unbalanced,
        # return -1 to propagate the unbalance status
        if abs(left_height - right_height) > 1:
            return -1

        # Return the maximum height of left and
        # right subtrees, adding 1 for the current node
        return max(left_height, right_height) + 1


# Creating a sample binary tree
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
root.left.right.right = Node(6)
root.left.right.right.right = Node(7)

# Creating an instance of the Solution class
solution = Solution()

# Checking if the tree is balanced
if solution.isBalanced(root):
    print("The tree is balanced.")
else:
    print("The tree is not balanced.")                                   




# method 3 : optimal solution
# TC     -      
# SC     -      


# 3 TODO : diameter of a binary tree
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

diameter of a tree - 
longest path between any two nodes in a tree. This path may or may not pass from the root.

https://takeuforward.org/data-structure/calculate-the-diameter-of-a-binary-tree/


https://leetcode.com/problems/diameter-of-binary-tree/

https://www.youtube.com/watch?v=Rezetez59Nk&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=88


self.diameter = max(self.diameter, left_height + right_height)


'''
# method 1 : brute force approch
'''
Time Complexity: O(N*N) where N is the number of nodes in the Binary Tree.

This arises as we calculate the diameter of each node and to calculate the height of its left and right children, we traverse the tree which is proportional to the number of nodes.
Since this calculation is performed for each node in the tree, the complexity becomes: O(N x N) ~ O(N2).

Space Complexity : O(1) as no additional data structures or memory is allocated.O(H): Recursive Stack Space is used to calculate the height of the tree at each node which is proportional to the height of the tree.The recursive nature of the getHeight function, which incurs space on the call stack for each recursive call until it reaches the leaf nodes or the height of the tree.
'''

# Node structure for
# the binary tree
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

class Solution:
    def __init__(self):
        # Global variable to
        # store the diameter
        self.diameter = 0  

    # Function to calculate
    # the height of a subtree
    def calculateHeight(self, node):
        if node is None:
            return 0

        # Recursively calculate the
        # height of left and right subtrees
        left_height = self.calculateHeight(node.left)
        right_height = self.calculateHeight(node.right)

        # Calculate the diameter at the current
        # node and update the global variable
        self.diameter = max(self.diameter, left_height + right_height)

        # Return the height
        # of the current subtree
        return 1 + max(left_height, right_height)

    # Function to find the
    # diameter of a binary tree
    def diameterOfBinaryTree(self, root):
        # Start the recursive
        # traversal from the root
        self.calculateHeight(root)

        # Return the maximum diameter
        # found during traversal
        return self.diameter

# Main function
if __name__ == "__main__":
    # Creating a sample binary tree
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)
    root.left.right.right = Node(6)
    root.left.right.right.right = Node(7)

    # Creating an instance of the Solution class
    solution = Solution()

    # Calculate the diameter of the binary tree
    diameter = solution.diameterOfBinaryTree(root)

    print("The diameter of the binary tree is:", diameter)




# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(N) where N is the number of nodes in the Binary Tree. This complexity arises from visiting each node exactly once during the postorder traversal.

Space Complexity : O(1) as no additional space or data structures is created that is proportional to the input size of the tree. O(H) Recursive Stack Auxiliary Space : The recursion stack space is determined by the maximum depth of the recursion, which is the height of the binary tree denoted as H. In the balanced case it is log2N and in the worst case its N.
'''

# Node class for the binary tree
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

# Solution class to find the diameter of the binary tree
class Solution:
    def diameterOfBinaryTree(self, root):
        # Initialize the variable to store the diameter of the tree
        diameter = [0]
        # Call the height function to traverse the tree and calculate diameter
        self.height(root, diameter)
        # Return the calculated diameter
        return diameter[0]

    # Function to calculate the height of the tree and update the diameter
    def height(self, node, diameter):
        # Base case: If the node is None, return 0 indicating the height of an empty tree
        if not node:
            return 0

        # Recursively calculate the height of left and right subtrees
        lh = self.height(node.left, diameter)
        rh = self.height(node.right, diameter)

        # Update the diameter with the maximum of current diameter or sum of left and right heights
        diameter[0] = max(diameter[0], lh + rh)

        # Return the height of the current node's subtree
        return 1 + max(lh, rh)


# Main function
if __name__ == "__main__":
    # Creating a sample binary tree
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)
    root.left.right.right = Node(6)
    root.left.right.right.right = Node(7)

    # Creating an instance of the Solution class
    solution = Solution()

    # Calculate the diameter of the binary tree
    diameter = solution.diameterOfBinaryTree(root)

    print("The diameter of the binary tree is:", diameter)
                                
                            


# 4 TODO : maximum path sum
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/data-structure/maximum-sum-path-in-binary-tree/


https://leetcode.com/problems/binary-tree-maximum-path-sum/

https://www.youtube.com/watch?v=WszrfSwMz58&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=89

'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''

maxi[0] = max(maxi[0], leftMaxPath + rightMaxPath + root.data)


Time Complexity: O(N) where N is the number of nodes in the Binary Tree. This complexity arises from visiting each node exactly once during the recursive traversal.

Space Complexity: O(1) as no additional space or data structures is created that is proportional to the input size of the tree. O(H) Recursive Stack Auxiliary Space : The recursion stack space is determined by the maximum depth of the recursion, which is the height of the binary tree denoted as H. In the balanced case it is log2N and in the worst case its N.
'''                            
class Node:
    def __init__(self, val):
        # Constructor to initialize
        # the node with a value
        self.data = val
        self.left = None
        self.right = None

class Solution:
    def findMaxPathSum(self, root, maxi):
        # Recursive function to find the maximum path sum
        # for a given subtree rooted at 'root'
        # The variable 'maxi' is a reference parameter
        # updated to store the maximum path sum encountered

        # Base case: If the current node is None, return 0
        if root is None:
            return 0

        # Calculate the maximum path sum
        # for the left and right subtrees
        leftMaxPath = max(0, self.findMaxPathSum(root.left, maxi))
        rightMaxPath = max(0, self.findMaxPathSum(root.right, maxi))

        # Update the overall maximum
        # path sum including the current node
        maxi[0] = max(maxi[0], leftMaxPath + rightMaxPath + root.data)

        # Return the maximum sum considering
        # only one branch (either left or right)
        # along with the current node
        return max(leftMaxPath, rightMaxPath) + root.data

    def maxPathSum(self, root):
        # Function to find the maximum
        # path sum for the entire binary tree

        # Initialize maxi to the
        # minimum possible integer value
        maxi = [float('-inf')] 
        # Call the recursive function to
        # find the maximum path sum
        self.findMaxPathSum(root, maxi)
        # Return the final maximum path sum
        return maxi[0]

# Creating a sample binary tree
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
root.left.right.right = Node(6)
root.left.right.right.right = Node(7)

# Creating an instance of the Solution class
solution = Solution()

# Finding and printing the maximum path sum
maxPathSum = solution.maxPathSum(root)
print("Maximum Path Sum:", maxPathSum)



# 5 TODO : check if two trees are identical or not
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/check-if-two-trees-are-identical/


https://leetcode.com/problems/same-tree/

https://www.youtube.com/watch?v=BhuvF_-PWS0&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=90

'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     

'''
Time Complexity: O(N+M) where N is the number of nodes in the first Binary Tree and M is the number of nodes in the second Binary Tree. This complexity arises from visiting each node of the two binary nodes during their comparison.

Space Complexity: O(1) as no additional space or data structures is created that is proportional to the input size of the tree. O(H) Recursive Stack Auxiliary Space : The recursion stack space is determined by the maximum depth of the recursion, which is the height of the binary tree denoted as H. In the balanced case it is log2N and in the worst case (its N).
'''                            
# Node structure for the binary tree
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

# Solution class with a function to check if two binary trees are identical
class Solution:
    def isIdentical(self, node1, node2):
        # If both nodes are None, they are identical
        if node1 is None and node2 is None:
            return True
        # If only one of the nodes is None, they are not identical
        if node1 is None or node2 is None:
            return False
        # Check if the current nodes have the same data value
        # and recursively check their left and right subtrees
        return (node1.data == node2.data
                and self.isIdentical(node1.left, node2.left)
                and self.isIdentical(node1.right, node2.right))

# Creating nodes for binary trees in Python
root1 = Node(1)
root1.left = Node(2)
root1.right = Node(3)
root1.left.left = Node(4)

root2 = Node(1)
root2.left = Node(2)
root2.right = Node(3)
root2.left.left = Node(4)

# Creating an instance of the Solution class
solution = Solution()

# Checking if the binary trees are identical
if solution.isIdentical(root1, root2):
    print("The binary trees are identical.")
else:
    print("The binary trees are not identical.")



# 6 TODO : zig-zag traversal of binary tree
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/data-structure/zig-zag-traversal-of-binary-tree/


https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/

https://www.youtube.com/watch?v=3OXWEdlIGl4&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=91


'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(N) where N is the number of nodes in the binary tree. Each node of the binary tree is enqueued and dequeued exactly once, hence all nodes need to be processed and visited. Processing each node takes constant time operations which contributes to the overall linear time complexity.

Space Complexity: O(N) where N is the number of nodes in the binary tree. In the worst case, the queue has to hold all the nodes of the last level of the binary tree, the last level could at most hold N/2 nodes hence the space complexity of the queue is proportional to O(N). The resultant vector answer also stores the values of the nodes level by level and hence contains all the nodes of the tree contributing to O(N) space as well.
'''                            
from collections import deque

# Node class for the binary tree
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

class Solution:
    # Function to perform zigzag level order traversal of a binary tree
    def ZigZagLevelOrder(self, root):
        # List to store the result of zigzag traversal
        result = []
        
        # Check if the root is None, return an empty result
        if not root:
            return result
        
        # Queue to perform level order traversal
        nodesQueue = deque()
        nodesQueue.append(root)
        
        # Flag to determine the direction of traversal (left to right or right to left)
        leftToRight = True
        
        # Continue traversal until the queue is empty
        while nodesQueue:
            # Get the number of nodes at the current level
            size = len(nodesQueue)
            
            # List to store the values of nodes at the current level
            row = [0] * size
            
            # Traverse nodes at the current level
            for i in range(size):
                # Get the front node from the queue
                node = nodesQueue.popleft()
                
                # Determine the index to insert the node's value based on the traversal direction
                index = i if leftToRight else (size - 1 - i)
                
                # Insert the node's value at the determined index
                row[index] = node.data
                
                # Enqueue the left and right children if they exist
                if node.left:
                    nodesQueue.append(node.left)
                if node.right:
                    nodesQueue.append(node.right)
            
            # Switch the traversal direction for the next level
            leftToRight = not leftToRight
            
            # Add the current level's values to the result list
            result.append(row)
        
        # Return the final result of zigzag level order traversal
        return result

# Helper function to print the result
def printResult(result):
    for row in result:
        for val in row:
            print(val, end=" ")
        print()

# Creating a sample binary tree
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
root.right.left = Node(6)
root.right.right = Node(7)

solution = Solution()

# Get the zigzag level order traversal
result = solution.ZigZagLevelOrder(root)

# Print the result
printResult(result)



# 7 TODO : boundary traversal of binary tree
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/boundary-traversal-of-a-binary-tree/


https://leetcode.com/problems/boundary-of-binary-tree/


https://www.youtube.com/watch?v=0ca1nvR0be4&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=92


'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''

left boundary without leaf nodes
leaf nodes
right boundary in reverse order without leaf nodes



Time Complexity: O(N) where N is the number of nodes in the Binary Tree.
Adding the left boundary of the Binary Tree results in the traversal of the left side of the tree which is proportional to the the height of the three hence O(H) ie. O(log2N). In the worst case that the tree is skewed the complexity would be O(N).
For the bottom traversal of the Binary Tree, traversing the leaves is proportional to O(N) as preorder traversal visits every node once.
Adding the right boundary of the Binary Tree results in the traversal of the right side of the tree which is proportional to the the height of the three hence O(H) ie. O(log2N). In the worst case that the tree is skewed the complexity would be O(N).
Since all these operations are performed sequentially, the overall time complexity is dominated by the most expensive operation, which is O(N).

Space Complexity: O(N) where N is the number of nodes in the Binary Tree to store the boundary nodes of the tree. O(H) or O(log2N) Recursive stack space while traversing the tree. In the worst case scenario the tree is skewed and the auxiliary recursion stack space would be stacked up to the maximum depth of the tree, resulting in an O(N) auxiliary space complexity.
'''                            
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

class Solution:
    def isLeaf(self, root):
        """
        Function to check if a node is a leaf
        """
        return not root.left and not root.right

    def addLeftBoundary(self, root, res):
        """
        Function to add the left boundary of the tree
        """
        curr = root.left
        while curr:
            if not self.isLeaf(curr):
                # If the current node is not a leaf,
                # add its value to the result
                res.append(curr.data)
            # Move to the left child if it exists,
            # otherwise move to the right child
            if curr.left:
                curr = curr.left
            else:
                curr = curr.right

    def addRightBoundary(self, root, res):
        """
        Function to add the right boundary of the tree
        """
        curr = root.right
        temp = []
        while curr:
            if not self.isLeaf(curr):
                # If the current node is not a leaf,
                # add its value to a temporary vector
                temp.append(curr.data)
            # Move to the right child if it exists,
            # otherwise move to the left child
            if curr.right:
                curr = curr.right
            else:
                curr = curr.left
        # Reverse and add the values from
        # the temporary vector to the result
        for i in range(len(temp) - 1, -1, -1):
            res.append(temp[i])

    def addLeaves(self, root, res):
        """
        Function to add the leaves of the tree
        """
        if self.isLeaf(root):
            # If the current node is a leaf,
            # add its value to the result
            res.append(root.data)
            return
        # Recursively add leaves of
        # the left and right subtrees
        if root.left:
            self.addLeaves(root.left, res)
        if root.right:
            self.addLeaves(root.right, res)

    def printBoundary(self, root):
        """
        Main function to perform the
        boundary traversal of the binary tree
        """
        res = []
        if not root:
            return res
        # If the root is not a leaf,
        # add its value to the result
        if not self.isLeaf(root):
            res.append(root.data)

        # Add the left boundary, leaves,
        # and right boundary in order
        self.addLeftBoundary(root, res)
        self.addLeaves(root, res)
        self.addRightBoundary(root, res)

        return res

# Helper function to
# print the result
def printResult(result):
    for val in result:
        print(val, end=" ")
    print()

# Creating a sample binary tree
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
root.right.left = Node(6)
root.right.right = Node(7)

solution = Solution()

# Get the boundary traversal
result = solution.printBoundary(root)

# Print the result
print("Boundary Traversal:", end=" ")
printResult(result)



# 8 TODO : vertical order traversal of binary tree
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/data-structure/vertical-order-traversal-of-binary-tree/


https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/


https://www.youtube.com/watch?v=q_a6lpbKJdw&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=93


'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(N * log2N * log2N * log2N) where N represents the number of nodes in the Binary Tree.

Postorder Traversal performed using BFS as a time complexity of O(N) as we are visiting each and every node once.
Multiset Operations to insert overlapping nodes at a specific vertical and horizontal level also takes O(log2N) complexity.
Map operations involve insertion and retrieval of nodes with their vertical and level as their keys. Since there are two nested maps, the total time complexity becomes O(log2N)*O(log2N).

Space Complexity: O(N + N/2) where N represents the number of nodes in the Binary Tree.

The map for storing nodes based on their vertical and level information occupies an additional space complexity of O(N) as it stores all N nodes of the Binary Tree.
The queue for breadth first traversal occupies a space proportional to the maximum level of the tree which can be O(N/2) in the worst case of a balanced tree.
'''                            

from collections import deque, defaultdict

# Node structure for the binary tree
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

class Solution:
    # Function to perform vertical order traversal
    # and return a 2D list of node values
    def findVertical(self, root):
        # Map to store nodes based on
        # vertical and level information
        nodes = defaultdict(lambda: defaultdict(lambda: set()))

        # Queue for BFS traversal, each
        # element is a pair containing node
        # and its vertical and level information
        todo = deque([(root, (0, 0))])

        # BFS traversal
        while todo:
            # Retrieve the node and its vertical
            # and level information from
            # the front of the queue
            temp, (x, y) = todo.popleft()

            # Insert the node value into the
            # corresponding vertical and level
            # in the map
            nodes[x][y].add(temp.data)

            # Process left child
            if temp.left:
                todo.append((temp.left, (x - 1, y + 1)))

            # Process right child
            if temp.right:
                todo.append((temp.right, (x + 1, y + 1)))

        # Prepare the final result list
        # by combining values from the map
        ans = []
        for x, y_vals in nodes.items():
            col = []
            for y, values in y_vals.items():
                # Insert node values
                # into the column list
                col.extend(sorted(values))
            # Add the column list
            # to the final result
            ans.append(col)

        return ans

# Helper function to
# print the result
def printResult(result):
    for level in result:
        for node in level:
            print(node, end=" ")
        print()
    print()

if __name__ == "__main__":
    # Creating a sample binary tree
    root = Node(1)
    root.left = Node(2)
    root.left.left = Node(4)
    root.left.right = Node(10)
    root.left.left.right = Node(5)
    root.left.left.right.right = Node(6)
    root.right = Node(3)
    root.right.right = Node(10)
    root.right.left = Node(9)

    solution = Solution()

    # Get the Vertical traversal
    verticalTraversal = solution.findVertical(root)

    # Print the result
    print("Vertical Traversal: ")
    printResult(verticalTraversal)



# 9 TODO : top view binary tree
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/data-structure/top-view-of-a-binary-tree/


https://practice.geeksforgeeks.org/problems/top-view-of-binary-tree/1


https://www.youtube.com/watch?v=Et9OCDNvJ78&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=94


'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(N) where N is the number of nodes in the Binary Tree. This complexity arises from visiting each node exactly once during the BFS traversal.

Space Complexity: O(N/2 + N/2) where N represents the number of nodes in the Binary Tree.

The main space consuming data structure is the queue used for BFS traversal. It acquires space proportional to the number of nodes in the level it is exploring hence in the worst case of a balanced binary tree, the queue will have at most N/2 nodes which is the maximum width.
Additionally, the map is used to store the top view nodes based on their vertical positions hence its complexity will also be proportional to the greatest width level. In the worst case, it may have N/2 entries as well.
'''                            
from collections import deque

# Node class for the binary tree
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

class Solution:
    # Function to return the top view of the binary tree
    def topView(self, root):
        # Vector to store the result
        ans = []
        
        # Check if the tree is empty
        if not root:
            return ans
        
        # Map to store the top view nodes
        # based on their vertical positions
        mpp = {}
        
        # Queue for BFS traversal, each element
        # is a pair containing node 
        # and its vertical position
        q = deque([(root, 0)])
        
        # Push the root node with its vertical
        # position (0) into the queue
        while q:
            # Retrieve the node and its vertical
            # position from the front of the queue
            node, line = q.popleft()
            
            # If the vertical position is not already
            # in the map, add the node's data to the map
            if line not in mpp:
                mpp[line] = node.data
            
            # Process left child
            if node.left:
                # Push the left child with a decreased
                # vertical position into the queue
                q.append((node.left, line - 1))
            
            # Process right child
            if node.right:
                # Push the right child with an increased
                # vertical position into the queue
                q.append((node.right, line + 1))
        
        # Transfer values from the
        # map to the result vector
        for value in sorted(mpp.items()):
            ans.append(value[1])
        
        return ans

# Creating a sample binary tree
root = Node(1)
root.left = Node(2)
root.left.left = Node(4)
root.left.right = Node(10)
root.left.left.right = Node(5)
root.left.left.right.right = Node(6)
root.right = Node(3)
root.right.right = Node(10)
root.right.left = Node(9)

solution = Solution()

# Get the top view traversal
topView = solution.topView(root)

# Print the result
print("Vertical Traversal:")
for node in topView:
    print(node, end=" ")


# 10 TODO :  bottom view binary tree
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/bottom-view-of-a-binary-tree/

https://practice.geeksforgeeks.org/problems/bottom-view-of-binary-tree/1

https://www.youtube.com/watch?v=0FtVY6I4pB8&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=95

'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(N) where N is the number of nodes in the Binary Tree. This complexity arises from visiting each node exactly once during the BFS traversal.

Space Complexity: O(N/2 + N/2) where N represents the number of nodes in the Binary Tree.

The main space consuming data structure is the queue used for BFS traversal. It acquires space proportional to the number of nodes in the level it is exploring hence in the worst case of a balanced binary tree, the queue will have at most N/2 nodes which is the maximum width.
Additionally, the map is used to store the top view nodes based on their vertical positions hence its complexity will also be proportional to the greatest width level. In the worst case, it may have N/2 entries as well.
'''                            
from queue import Queue
from collections import deque, defaultdict

# Node class to represent the binary tree
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

class Solution:
    def bottomView(self, root):
        """
        Function to return the
        bottom view of the binary tree
        """
        # Vector to store the result
        ans = []

        # Check if the tree is empty
        if root is None:
            return ans

        # Map to store the bottom view nodes
        # based on their vertical positions
        mpp = defaultdict(int)   # <line, node>

        # Queue for BFS traversal, each
        # element is a pair containing node
        # and its vertical position
        q = Queue()              # <node, line>

        # Push the root node with its vertical
        # position (0) into the queue
        q.put((root, 0))

        # BFS traversal
        while not q.empty():
            # Retrieve the node and its vertical
            # position from the front of the queue
            it = q.get()
            node, line = it[0], it[1]

            # Update the map with the node's data
            # for the current vertical position
            mpp[line] = node.data

            # Process left child
            if node.left:
                # Push the left child with a decreased
                # vertical position into the queue
                q.put((node.left, line - 1))

            # Process right child
            if node.right:
                # Push the right child with an increased
                # vertical position into the queue
                q.put((node.right, line + 1))

        # Transfer values from the
        # map to the result vector
        for key, value in sorted(mpp.items()):
            ans.append(value)

        return ans

# Creating a sample binary tree
root = Node(1)
root.left = Node(2)
root.left.left = Node(4)
root.left.right = Node(10)
root.left.left.right = Node(5)
root.left.left.right.right = Node(6)
root.right = Node(3)
root.right.right = Node(10)
root.right.left = Node(9)

# Creating a Solution object
solution = Solution()

# Get the Bottom View traversal
bottomView = solution.bottomView(root)

# Print the result
print("Bottom View Traversal:")
for node in bottomView:
    print(node, end=" ")



# 11 TODO : right/left view of a binary tree
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/right-left-view-of-binary-tree/


https://leetcode.com/problems/binary-tree-right-side-view/


https://www.youtube.com/watch?v=KV4mRzTjlAk&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=96

'''
# method 1 : brute force approch
'''
Time Complexity: O(N) where N is the number of nodes in the binary tree. Each node of the binary tree is enqueued and dequeued exactly once, hence all nodes need to be processed and visited. Processing each node takes constant time operations which contributes to the overall linear time complexity.

Space Complexity : O(N) where N is the number of nodes in the binary tree. In the worst case, the queue has to hold all the nodes of the last level of the binary tree, the last level could at most hold N/2 nodes hence the space complexity of the queue is proportional to O(N). The resultant vector answer also stores the values of the nodes level by level and hence contains all the nodes of the tree contributing to O(N) space as well.
'''                                
# Node class for the binary tree
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

# Solution class to get the left
# and right view of the binary tree
class Solution:
    def rightsideView(self, root):
        # Vector to store the result
        res = []
        
        # Call the recursive function
        # to populate the right-side view
        self.recursionRight(root, 0, res)
        
        return res

    def leftsideView(self, root):
        # Vector to store the result
        res = []
        
        # Call the recursive function
        # to populate the left-side view
        self.recursionLeft(root, 0, res)
        
        return res

    # Recursive function to traverse the
    # binary tree and populate the left-side view
    def recursionLeft(self, root, level, res):
        # Check if the current node is None
        if not root:
            return
        
        # Check if the size of the result list
        # is equal to the current level
        if len(res) == level:
            # If equal, add the value of the
            # current node to the result list
            res.append(root.data)
        
        # Recursively call the function for the
        # left child with an increased level
        self.recursionLeft(root.left, level + 1, res)
        
        # Recursively call the function for the
        # right child with an increased level
        self.recursionLeft(root.right, level + 1, res)

    # Recursive function to traverse the
    # binary tree and populate the right-side view
    def recursionRight(self, root, level, res):
        # Check if the current node is None
        if not root:
            return
        
        # Check if the size of the result list
        # is equal to the current level
        if len(res) == level:
            # If equal, add the value of the
            # current node to the result list
            res.append(root.data)
            
            # Recursively call the function for the
            # right child with an increased level
            self.recursionRight(root.right, level + 1, res)
            
            # Recursively call the function for the
            # left child with an increased level
            self.recursionRight(root.left, level + 1, res)

# Creating a sample binary tree
root = Node(1)
root.left = Node(2)
root.left.left = Node(4)
root.left.right = Node(10)
root.left.left.right = Node(5)
root.left.left.right.right = Node(6)
root.right = Node(3)
root.right.right = Node(10)
root.right.left = Node(9)

solution = Solution()

# Get the Right View traversal
rightView = solution.rightsideView(root)

# Print the result for Right View
print("Right View Traversal:", end=" ")
for node in rightView:
    print(node, end=" ")
print()

# Get the Left View traversal
leftView = solution.leftsideView(root)

# Print the result for Left View
print("Left View Traversal:", end=" ")
for node in leftView:
    print(node, end=" ")
print()



# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(log2N) where N is the number of nodes in the Binary Tree. This complexity arises as we travel along the height of the Binary Tree. For a balanced binary tree, the height is log2N but in the worst case when the tree is skewed, the complexity becomes O(N).

Space Complexity : O(log2N) where N is the number of nodes in the Binary Tree. This complexity arises because we store the leftmost and rightmost nodes in an additional vector. The size of this result vector is proportional to the height of the Binary Tree which will be log2N when the tree is balanced and O(N) in the worst case of a skewed tree.

O(H): Recursive Stack Space is used to calculate the height of the tree at each node which is proportional to the height of the tree.
The recursive nature of the getHeight function, which incurs space on the call stack for each recursive call until it reaches the leaf nodes or the height of the tree.
'''                                
                     
# Node class for the binary tree
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

# Solution class to get the left
# and right view of the binary tree
class Solution:
    def rightsideView(self, root):
        # Vector to store the result
        res = []
        
        # Call the recursive function
        # to populate the right-side view
        self.recursionRight(root, 0, res)
        
        return res

    def leftsideView(self, root):
        # Vector to store the result
        res = []
        
        # Call the recursive function
        # to populate the left-side view
        self.recursionLeft(root, 0, res)
        
        return res

    # Recursive function to traverse the
    # binary tree and populate the left-side view
    def recursionLeft(self, root, level, res):
        # Check if the current node is None
        if not root:
            return
        
        # Check if the size of the result list
        # is equal to the current level
        if len(res) == level:
            # If equal, add the value of the
            # current node to the result list
            res.append(root.data)
        
        # Recursively call the function for the
        # left child with an increased level
        self.recursionLeft(root.left, level + 1, res)
        
        # Recursively call the function for the
        # right child with an increased level
        self.recursionLeft(root.right, level + 1, res)

    # Recursive function to traverse the
    # binary tree and populate the right-side view
    def recursionRight(self, root, level, res):
        # Check if the current node is None
        if not root:
            return
        
        # Check if the size of the result list
        # is equal to the current level
        if len(res) == level:
            # If equal, add the value of the
            # current node to the result list
            res.append(root.data)
            
            # Recursively call the function for the
            # right child with an increased level
            self.recursionRight(root.right, level + 1, res)
            
            # Recursively call the function for the
            # left child with an increased level
            self.recursionRight(root.left, level + 1, res)

# Creating a sample binary tree
root = Node(1)
root.left = Node(2)
root.left.left = Node(4)
root.left.right = Node(10)
root.left.left.right = Node(5)
root.left.left.right.right = Node(6)
root.right = Node(3)
root.right.right = Node(10)
root.right.left = Node(9)

solution = Solution()

# Get the Right View traversal
rightView = solution.rightsideView(root)

# Print the result for Right View
print("Right View Traversal:", end=" ")
for node in rightView:
    print(node, end=" ")
print()

# Get the Left View traversal
leftView = solution.leftsideView(root)

# Print the result for Left View
print("Left View Traversal:", end=" ")
for node in leftView:
    print(node, end=" ")
print()



# 12 TODO : symmetric binary tree
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/check-for-symmetrical-binary-tree/


https://leetcode.com/problems/symmetric-tree/

https://www.youtube.com/watch?v=nKggNAiEpBE&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=97

'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(N) where N is the number of nodes in the Binary Tree. 

Space Complexity: O(N) if in worst case the tree is skewed.
'''
                            
# Node class for the binary tree
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

# Solution class to check if the tree is symmetric
class Solution:
    # Function to check if the tree is symmetric
    def isSymmetric(self, root):
        # If the root is None, the tree is symmetric (empty tree)
        if root is None:
            return True
        
        # Helper function to check symmetry of two subtrees
        def isMirror(t1, t2):
            # If both trees are empty, they are symmetric
            if not t1 and not t2:
                return True
            # If one tree is empty and the other is not, they are not symmetric
            if not t1 or not t2:
                return False
            # Check if the current nodes are equal and the subtrees are mirrors of each other
            return (t1.data == t2.data) and isMirror(t1.left, t2.right) and isMirror(t1.right, t2.left)
        
        # Check if the left and right subtrees are mirrors of each other
        return isMirror(root.left, root.right)

# Main function
if __name__ == "__main__":
    # Creating a sample binary tree
    root = Node(1)
    root.left = Node(2)
    root.right = Node(2)
    root.left.left = Node(3)
    root.left.right = Node(4)
    root.right.left = Node(4)
    root.right.right = Node(3)
    
    solution = Solution()
    result = solution.isSymmetric(root)
    
    if result:
        print("The binary tree is symmetric.")
    else:
        print("The binary tree is not symmetric.")



# endregion






# region 13.3 BINARY TREES - HARD
# --------------------------------


# 1 TODO : root to node in a binary tree  
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡




https://takeuforward.org/data-structure/print-root-to-node-path-in-a-binary-tree/


https://bit.ly/3QA600D

https://www.youtube.com/watch?v=fmflMqVOC7k&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=98

'''



# method 1 : brute force approch
'''
Time Complexity: O(N) where N is the number of nodes in the binary tree as each node of the binary tree is visited exactly once in the inorder traversal.

Space Complexity: O(N) awhere N is the number of nodes in the binary tree. This is because the stack can potentially hold all nodes in the tree when dealing with a skewed tree (all nodes have only one child), consuming space proportional to the number of nodes.

O(H): In the average case or for a balanced tree, the maximum number of nodes that could be in the stack at any given time would be roughly the height of the tree hence O(log2N).
'''                            
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def getPath(self, root, arr, x):
        """
        Function to find the path from the
        root to a given node with value 'x'
        """
        # Base case: If the current
        # node is None, return False
        if not root:
            return False

        # Add the current node's
        # value to the path list
        arr.append(root.val)

        # If the current node's value is equal
        # to the target value 'x', return True
        if root.val == x:
            return True

        # Recursively search for the target value
        # 'x' in the left and right subtrees
        if self.getPath(root.left, arr, x) or self.getPath(root.right, arr, x):
            return True

        # If the target value 'x' is not found
        # in the current path, backtrack
        arr.pop()
        return False

    def solve(self, A, B):
        """
        Function to find and return the path from
        the root to a given node with value 'B'
        """
        # Initialize an empty
        # list to store the path
        arr = []

        # If the root node is None,
        # return the empty path list
        if not A:
            return arr

        # Call the getPath function to find
        # the path to the node with value 'B'
        self.getPath(A, arr, B)

        # Return the path list
        return arr

if __name__ == "__main__":
    root = TreeNode(3)
    root.left = TreeNode(5)
    root.right = TreeNode(1)
    root.left.left = TreeNode(6)
    root.left.right = TreeNode(2)
    root.right.left = TreeNode(0)
    root.right.right = TreeNode(8)
    root.left.right.left = TreeNode(7)
    root.left.right.right = TreeNode(4)

    sol = Solution()

    target_leaf_value = 7

    path = sol.solve(root, target_leaf_value)

    print(f"Path from root to leaf with value {target_leaf_value}: ", end="")
    for i in range(len(path)):
        print(path[i], end="")
        if i < len(path) - 1:
            print(" -> ", end="")
                           
                        


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : LCA (Lowest Common Ancestor) in binary tree
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/lowest-common-ancestor-for-two-given-nodes/


https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/

https://www.youtube.com/watch?v=_-QHfMDde90&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=99

'''
# method 1 : brute force approch
# TC     -      
# SC     -     
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def getPath(self, root, arr, x):
        """
        Function to find the path from the
        root to a given node with value 'x'
        """
        # Base case: If the current
        # node is None, return False
        if not root:
            return False

        # Add the current node's
        # value to the path list
        arr.append(root.val)

        # If the current node's value is equal
        # to the target value 'x', return True
        if root.val == x:
            return True

        # Recursively search for the target value
        # 'x' in the left and right subtrees
        if self.getPath(root.left, arr, x) or self.getPath(root.right, arr, x):
            return True

        # If the target value 'x' is not found
        # in the current path, backtrack
        arr.pop()
        return False

    def findLCA(self, root, node1, node2):
        """
        Function to find the Lowest Common Ancestor (LCA)
        of two nodes in the binary tree
        """
        # Get the paths from root to node1 and node2
        path1 = []
        path2 = []
        
        # If either of the nodes are not found, return None
        if not self.getPath(root, path1, node1) or not self.getPath(root, path2, node2):
            return None
        
        # Find the last common node in the paths
        i = 0
        while i < len(path1) and i < len(path2) and path1[i] == path2[i]:
            i += 1

        # The last common node is the LCA
        return path1[i-1]

# Main function
if __name__ == "__main__":
    root = TreeNode(3)
    root.left = TreeNode(5)
    root.right = TreeNode(1)
    root.left.left = TreeNode(6)
    root.left.right = TreeNode(2)
    root.right.left = TreeNode(0)
    root.right.right = TreeNode(8)
    root.left.right.left = TreeNode(7)
    root.left.right.right = TreeNode(4)

    sol = Solution()

    node1 = 5
    node2 = 1

    # Find the LCA of node1 and node2
    lca = sol.findLCA(root, node1, node2)

    if lca:
        print(f"The Lowest Common Ancestor of {node1} and {node2} is: {lca}")
    else:
        print("One or both nodes are not present in the tree.")


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''

if the left and right both node returns null, retun null to parent node
if one node return null and other return value, retun value to parent node
if the left and right both node returns value, retun value to parent node



TC     -     O(N), where N is the number of nodes in the binary tree. We visit each node once during the recursion. 
SC     -     O(H), where H is the height of the tree. This is the space used by the recursion stack (in the worst case, the height is O(N) if the tree is skewed). 
'''
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def lowestCommonAncestor(self, root, p, q):
        """
        This function returns the lowest common ancestor of nodes p and q in the binary tree.
        """
        # Base case: if the root is None or matches one of the target nodes, return the root
        if not root or root == p or root == q:
            return root
        
        # Recurse on the left and right subtrees
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)

        # If both left and right are not None, it means p and q are found in different subtrees
        if left and right:
            return root
        
        # Otherwise, return the non-None child (if either left or right is None)
        return left if left else right

# Main function
if __name__ == "__main__":
    # Create the binary tree
    root = TreeNode(3)
    root.left = TreeNode(5)
    root.right = TreeNode(1)
    root.left.left = TreeNode(6)
    root.left.right = TreeNode(2)
    root.right.left = TreeNode(0)
    root.right.right = TreeNode(8)
    root.left.right.left = TreeNode(7)
    root.left.right.right = TreeNode(4)

    sol = Solution()

    # Define two nodes for which we want to find the LCA
    p = root.left  # Node with value 5
    q = root.right  # Node with value 1

    # Find the Lowest Common Ancestor (LCA)
    lca = sol.lowestCommonAncestor(root, p, q)

    if lca:
        print(f"The Lowest Common Ancestor of nodes {p.val} and {q.val} is: {lca.val}")
    else:
        print("LCA not found.")


# 3 TODO : maximum width of a binary tree
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

- width = number of nodes in a level between any two nodes
- width = last node - first node + 1
- for 0 based indexing
root = 0
left node = 2*i+1
right node = 2*i+2
- for 1 based indexing
root = 0
left node = 2*i
right node = 2*i+1
- due to this indexing method, overflow case arises 


https://takeuforward.org/data-structure/maximum-width-of-a-binary-tree/


https://leetcode.com/problems/maximum-width-of-binary-tree/

https://www.youtube.com/watch?v=ZbybYvcVLks&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=100

'''
# method 1 : brute force approch
'''
Time Complexity: O(N) where N is the number of nodes in the binary tree. Each node of the binary tree is enqueued and dequeued exactly once, hence all nodes need to be processed and visited. Processing each node takes constant time operations which contributes to the overall linear time complexity.

Space Complexity: O(N) where N is the number of nodes in the binary tree. In the worst case, the queue has to hold all the nodes of the last level of the binary tree, the last level could at most hold N/2 nodes hence the space complexity of the queue is proportional to O(N).
'''                            
from queue import Queue
from typing import Optional, Tuple


# TreeNode structure
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        # If the root is null,
        # the width is zero
        if not root:
            return 0

        # Initialize a variable 'ans'
        # to store the maximum width
        ans = 0

        # Create a queue to perform level-order
        # traversal, where each element is a tuple
        # of TreeNode and its position in the level
        q = Queue()
        # Push the root node and its
        # position (0) into the queue
        q.put((root, 0))

        # Perform level-order traversal
        while not q.empty():
            # Get the number of
            # nodes at the current level
            size = q.qsize()
            # Get the position of the front
            # node in the current level
            mmin = q.queue[0][1]

            # Store the first and last positions
            # of nodes in the current level
            first, last = None, None

            # Process each node
            # in the current level
            for i in range(size):
                # Calculate current position relative
                # to the minimum position in the level
                cur_id = q.queue[i][1] - mmin
                # Get the current node
                node = q.queue[i][0]

                # If this is the first node in the level,
                # update the 'first' variable
                if i == 0:
                    first = cur_id

                # If this is the last node in the level,
                # update the 'last' variable
                if i == size - 1:
                    last = cur_id

                # Enqueue the left child of the
                # current node with its position
                if node.left:
                    q.put((node.left, cur_id * 2 + 1))

                # Enqueue the right child of the
                # current node with its position
                if node.right:
                    q.put((node.right, cur_id * 2 + 2))

            # Update the maximum width by calculating
            # the difference between the first and last
            # positions, and adding 1
            ans = max(ans, last - first + 1)

        # Return the maximum
        # width of the binary tree
        return ans


def main():
    root = TreeNode(3)
    root.left = TreeNode(5)
    root.right = TreeNode(1)
    root.left.left = TreeNode(6)
    root.left.right = TreeNode(2)
    root.right.left = TreeNode(0)
    root.right.right = TreeNode(8)
    root.left.right.left = TreeNode(7)
    root.left.right.right = TreeNode(4)

    sol = Solution()

    maxWidth = sol.widthOfBinaryTree(root)

    print(f"Maximum width of the binary tree is: {maxWidth}")


if __name__ == "__main__":
    main()



# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 4 TODO : check for children sum property
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/check-for-children-sum-property-in-a-binary-tree/


https://bit.ly/3dEr73g

https://www.youtube.com/watch?v=fnmisPM6cVo&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=101

'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(N) where N is the number of nodes in the binary tree. This is because the algorithm traverses each node exactly once, performing constant-time operations at each node.

Space Complexity: O(N) where N is the number of nodes in the Binary Tree.

In the worst case scenario the tree is skewed and the auxiliary recursion stack space would be stacked up to the maximum height of the tree, resulting in a space complexity of O(N).
In the optimal case of a balanced tree, the auxiliary space would take up space proportional to O(log2N).
'''

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def changeTree(self, root):
        # Base case: If the current node
        # is None, return and do nothing.
        if root is None:
            return

        # Calculate the sum of the values of
        # the left and right children, if they exist.
        child = 0
        if root.left:
            child += root.left.val
        if root.right:
            child += root.right.val

        # Compare the sum of children with
        # the current node's value and update
        if child >= root.val:
            root.val = child
        else:
            # If the sum is smaller, update the
            # child with the current node's value.
            if root.left:
                root.left.val = root.val
            elif root.right:
                root.right.val = root.val

        # Recursively call the function
        # on the left and right children.
        self.changeTree(root.left)
        self.changeTree(root.right)

        # Calculate the total sum of the
        # values of the left and right
        # children, if they exist.
        tot = 0
        if root.left:
            tot += root.left.val
        if root.right:
            tot += root.right.val

        # If either left or right child
        # exists, update the current node's
        # value with the total sum.
        if root.left or root.right:
            root.val = tot


# Function to print the inorder
# traversal of the tree
def inorderTraversal(root):
    if root is None:
        return
    inorderTraversal(root.left)
    print(root.val, end=" ")
    inorderTraversal(root.right)


# Create the binary tree
root = TreeNode(3)
root.left = TreeNode(5)
root.right = TreeNode(1)
root.left.left = TreeNode(6)
root.left.right = TreeNode(2)
root.right.left = TreeNode(0)
root.right.right = TreeNode(8)
root.left.right.left = TreeNode(7)
root.left.right.right = TreeNode(4)

sol = Solution()

# Print the inorder traversal
# of tree before modification
print("Binary Tree before modification:", end=" ")
inorderTraversal(root)
print()

# Call the changeTree function
# to modify the binary tree
sol.changeTree(root)

# Print the inorder traversal
# after modification
print("Binary Tree after Children Sum Property:", end=" ")
inorderTraversal(root)
print()



# 5 TODO : print all the nodes at a distance of k in binary tree
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/

https://www.youtube.com/watch?v=i9ORlEy6EsI&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=102


'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(n), where n is the number of nodes in the tree.
Space Complexity: O(n), where n is the number of nodes in the tree


'''
from queue import Queue
from typing import Optional, Tuple, List, Dict


# TreeNode structure
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def nodesAtDistanceK(self, root: Optional[TreeNode], target: TreeNode, k: int) -> List[int]:
        if not root:
            return []
        
        # Dictionary to store parent references
        parent_map: Dict[TreeNode, TreeNode] = {}
        
        # Function to populate the parent map
        def dfs(node: Optional[TreeNode]):
            if node:
                if node.left:
                    parent_map[node.left] = node
                    dfs(node.left)
                if node.right:
                    parent_map[node.right] = node
                    dfs(node.right)

        # Step 1: Populate the parent_map using DFS
        dfs(root)
        
        # Step 2: BFS from the target node to find all nodes at distance k
        q = Queue()
        visited = set()
        visited.add(target)
        q.put((target, 0))  # (node, current_distance)
        result = []

        while not q.empty():
            node, distance = q.get()

            # If we reach the desired distance, add the node's value to result
            if distance == k:
                result.append(node.val)

            # Explore the neighbors: left, right, and parent
            for neighbor in [node.left, node.right, parent_map.get(node)]:
                if neighbor and neighbor not in visited:
                    visited.add(neighbor)
                    q.put((neighbor, distance + 1))

        return result


def main():
    # Construct the binary tree
    root = TreeNode(3)
    root.left = TreeNode(5)
    root.right = TreeNode(1)
    root.left.left = TreeNode(6)
    root.left.right = TreeNode(2)
    root.right.left = TreeNode(0)
    root.right.right = TreeNode(8)
    root.left.right.left = TreeNode(7)
    root.left.right.right = TreeNode(4)

    # Choose a target node
    target = root.left  # Node with value 5
    k = 2  # Distance from target node

    # Create the Solution object and call the function
    sol = Solution()
    nodes = sol.nodesAtDistanceK(root, target, k)

    print(f"Nodes at distance {k} from target node {target.val}: {nodes}")


if __name__ == "__main__":
    main()


# 6 TODO : minimum time taken to BURN the binary tree from a node
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://bit.ly/3wcg7k1

https://www.youtube.com/watch?v=2r5wLmQfD6g&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=103

'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''

Time Complexity: O(n), where n is the number of nodes in the tree.
Space Complexity: O(n), where n is the number of nodes in the tree

'''    
from queue import Queue
from typing import Optional, Dict


# TreeNode structure
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def minTimeToBurnTree(self, root: Optional[TreeNode], target: TreeNode) -> int:
        if not root:
            return 0

        # Dictionary to store parent references
        parent_map: Dict[TreeNode, TreeNode] = {}
        
        # Function to populate the parent map using DFS
        def dfs(node: Optional[TreeNode], parent: Optional[TreeNode]):
            if node:
                parent_map[node] = parent
                dfs(node.left, node)
                dfs(node.right, node)

        # Step 1: Populate the parent_map using DFS
        dfs(root, None)

        # Step 2: BFS to simulate the burn process
        q = Queue()
        visited = set()
        visited.add(target)
        q.put((target, 0))  # (node, time taken)
        max_time = 0

        while not q.empty():
            node, time = q.get()
            max_time = max(max_time, time)

            # Explore the neighbors: left child, right child, and parent
            for neighbor in [node.left, node.right, parent_map.get(node)]:
                if neighbor and neighbor not in visited:
                    visited.add(neighbor)
                    q.put((neighbor, time + 1))

        return max_time


def main():
    # Construct the binary tree
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)
    root.right.left = TreeNode(6)
    root.right.right = TreeNode(7)

    # Choose a target node
    target = root.left  # Node with value 2

    # Create the Solution object and call the function
    sol = Solution()
    time_to_burn = sol.minTimeToBurnTree(root, target)

    print(f"Minimum time to burn the entire tree from node {target.val}: {time_to_burn}")


if __name__ == "__main__":
    main()


# 7 TODO : count total nodes in a complete binary tree
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

- number of nodes = 2**(number of levels) - 1

https://takeuforward.org/binary-tree/count-number-of-nodes-in-a-binary-tree/


https://leetcode.com/problems/count-complete-tree-nodes/

https://www.youtube.com/watch?v=u-yWemKGWO0&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=104

'''
# method 1 : brute force approch
'''
Time Complexity: O(N) where N is the number of nodes in the binary tree as each node of the binary tree is visited exactly once.

Space Complexity : O(N) where N is the number of nodes in the binary tree. This is because the recursive stack uses an auxiliary space which can potentially hold all nodes in the tree when dealing with a skewed tree (all nodes have only one child), consuming space proportional to the number of nodes. In the average case or for a balanced tree, the maximum number of nodes that could be in the stack at any given time would be roughly the height of the tree hence O(log2N).
'''                                
# TreeNode class definition
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def inorder(self, root, count):
        """
        Function to perform inorder traversal and count nodes
        """
        # Base case: If the current node is None, return
        if root is None:
            return

        # Increment count for the current node
        count[0] += 1

        # Recursively call inorder on the left subtree
        self.inorder(root.left, count)

        # Recursively call inorder on the right subtree
        self.inorder(root.right, count)

    def countNodes(self, root):
        """
        Function to count nodes in the binary tree
        """
        # Base case: If the root is None, the tree is empty, return 0
        if root is None:
            return 0

        # Initialize count variable to store the number of nodes
        count = [0]

        # Call the inorder traversal function to count nodes
        self.inorder(root, count)

        # Return the final count of nodes in the binary tree
        return count[0]


# Main function
if __name__ == "__main__":
    # Create the binary tree
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)
    root.right.left = TreeNode(6)

    sol = Solution()

    # Call the countNodes function
    totalNodes = sol.countNodes(root)

    # Print the result
    print("Total number of nodes in the Complete Binary Tree:", totalNodes)
                                



# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(log N * log N) where N is the number of nodes in the Binary Tree.

The calculation of leftHeight and rightHeight takes O(log N) time.
In the worst case, when encountering the second case (leftHeight != rightHeight), the recursive calls are made at most log N times (the height of the tree).
Therefore, the total time complexity is O(log N * log N).
Space Complexity : O(H) ~ O(N) where N is the number of nodes in the Binary Tree.

The space complexity is determined by the maximum depth of the recursion stack, which is equal to the height of the binary tree.
Since the given tree is a complete binary tree, the height will always be log N.
Therefore, the space complexity is O(log N).
'''
                                
                     
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def countNodes(self, root):
        """
        Count the total number of nodes in the Complete Binary Tree.

        :param root: TreeNode, the root of the binary tree
        :return: int, total number of nodes in the binary tree
        """
        if not root:
            return 0

        lh = self.findHeightLeft(root)
        rh = self.findHeightRight(root)

        if lh == rh:
            return (1 << lh) - 1
        return 1 + self.countNodes(root.left) + self.countNodes(root.right)

    def findHeightLeft(self, node):
        """
        Find the height of the left subtree.

        :param node: TreeNode, the root of the subtree
        :return: int, height of the left subtree
        """
        hght = 0
        while node:
            hght += 1
            node = node.left
        return hght

    def findHeightRight(self, node):
        """
        Find the height of the right subtree.

        :param node: TreeNode, the root of the subtree
        :return: int, height of the right subtree
        """
        hght = 0
        while node:
            hght += 1
            node = node.right
        return hght


if __name__ == "__main__":
    # Create the binary tree
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)
    root.right.left = TreeNode(6)

    sol = Solution()

    # Call the countNodes function
    totalNodes = sol.countNodes(root)

    # Print the result
    print(f"Total number of nodes in the Complete Binary Tree: {totalNodes}")



# 8 TODO : requirements needed to construct a unique binary tree (theory)
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

can we construct a unique binary tree with the following ?
preorder and postorder -> No
inorder and preorder -> Yes

https://bit.ly/3UVCR1U

https://www.youtube.com/watch?v=9GMECGQgWrQ&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=105

'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 9 TODO : construct binary tree from inorder and preorder traversal
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/construct-a-binary-tree-from-inorder-and-preorder-traversal/


https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/

https://www.youtube.com/watch?v=aZNaLrVebKQ&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=106

'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(N) where N is the number of nodes in the Binary Tree. This is because each node of the Binary Tree is visited once.

Space Complexity: O(N) where N is the number of nodes in the Binary Tree. The inorder hashmap to store the inorder array for fast lookup takes up space proportional to the input nodes. An auxiliary stack space ~ O(H) where H is the height of the Binary Tree is used. This is the stack space used to build the tree recursively. In the case of a skewed tree, the height of the tree will be H ~ N hence the worst case auxiliary space is O(N).
'''                            
from typing import List

# TreeNode class definition
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        # Create a map to store indices of elements in the inorder traversal
        inMap = {val: idx for idx, val in enumerate(inorder)}
        
        # Call the private helper function to recursively build the tree
        root = self._buildTree(preorder, 0, len(preorder)-1, inorder, 0, len(inorder)-1, inMap)
        
        return root

    def _buildTree(self, preorder, preStart, preEnd, inorder, inStart, inEnd, inMap):
        # Base case: If the start indices exceed the end indices, return None
        if preStart > preEnd or inStart > inEnd:
            return None

        # Create a new TreeNode with value at the current preorder index
        root = TreeNode(preorder[preStart])

        # Find the index of the current root value in the inorder traversal
        inRoot = inMap[root.val]

        # Calculate the number of elements in the left subtree
        numsLeft = inRoot - inStart

        # Recursively build the left subtree
        root.left = self._buildTree(preorder, preStart + 1, preStart + numsLeft,
                                    inorder, inStart, inRoot - 1, inMap)

        # Recursively build the right subtree
        root.right = self._buildTree(preorder, preStart + numsLeft + 1, preEnd,
                                     inorder, inRoot + 1, inEnd, inMap)

        # Return the current root node
        return root

# Function to print the inorder traversal of a tree
def printInorder(root):
    if not root:
        return
    printInorder(root.left)
    print(root.val, end=" ")
    printInorder(root.right)

# Function to print the given list
def printList(lst):
    for val in lst:
        print(val, end=" ")
    print()

# Main function
if __name__ == "__main__":
    inorder = [9, 3, 15, 20, 7]
    preorder = [3, 9, 20, 15, 7]
    
    print("Inorder List: ", end="")
    printList(inorder)
    
    print("Preorder List: ", end="")
    printList(preorder)
    
    sol = Solution()

    root = sol.buildTree(preorder, inorder)
    
    print("Inorder of Unique Binary Tree Created:")
    printInorder(root)
    print()



# 10 TODO :  construct binary tree from postorder and inorder traversal
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/construct-binary-tree-from-inorder-and-postorder-traversal/


https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/

https://www.youtube.com/watch?v=LgLRTaEMRVc&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=108

'''
# method 1 : brute force approch
'''
Time Complexity: O(N) where N is the number of nodes in the Binary Tree. This is because each node is processed and visited exactly once.

The algorithm processes each element in the inorder traversal and for each element it performs constant-time operations (lookup in the hashmap, recursive calls and variable operations).
Space Complexity: O(N + log2N) where N is the number of elements in the iwhere N is the number of nodes in the Binary Tree.

This complexity arises from the space used by the recursion stack during the recursive calls. In the worst case, the maximum depth of the recursion stack would be equal to the height of the Binary Tree and in the optimal case the recursion stack complexity would be O(log2N).
'''
                            
from typing import List

# TreeNode class definition
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        """
        Function to build a binary tree
        from inorder and postorder traversals
        """
        if len(inorder) != len(postorder):
            return None

        # Create a map to store the indices
        # of elements in the inorder traversal
        hm = {val: i for i, val in enumerate(inorder)}

        # Call the recursive function
        # to build the binary tree
        return self.buildTreePostIn(inorder, 0, len(inorder) - 1, postorder, 0,
                                     len(postorder) - 1, hm)

    def buildTreePostIn(self, inorder: List[int], is_, ie, postorder: List[int], ps, pe, hm):
        """
        Recursive function to build a binary
        tree from inorder and postorder traversals
        """
        # Base case: If the subtree
        # is empty, return None
        if ps > pe or is_ > ie:
            return None

        # Create a new TreeNode
        # with the root value from postorder
        root = TreeNode(postorder[pe])

        # Find the index of the root
        # value in inorder traversal
        inRoot = hm[postorder[pe]]

        # Number of nodes in the left subtree
        numsLeft = inRoot - is_

        # Recursively build the
        # left and right subtrees
        root.left = self.buildTreePostIn(inorder, is_, inRoot - 1, postorder,
                                         ps, ps + numsLeft - 1, hm)

        root.right = self.buildTreePostIn(inorder, inRoot + 1, ie, postorder,
                                          ps + numsLeft, pe - 1, hm)

        # Return the root of
        # the constructed subtree
        return root

# Function to print the
# inorder traversal of a tree
def printInorder(root):
    if not root:
        return
    printInorder(root.left)
    print(root.val, end=" ")
    printInorder(root.right)

# Function to print the given list
def printList(lst):
    for item in lst:
        print(item, end=" ")
    print()

# Example input lists
inorder = [40, 20, 50, 10, 60, 30]
postorder = [40, 50, 20, 60, 30, 10]

# Display the input lists
print("Inorder List: ", end="")
printList(inorder)

print("Postorder List: ", end="")
printList(postorder)

sol = Solution()

# Build the binary tree and
# print its inorder traversal
root = sol.buildTree(inorder, postorder)

print("Inorder of Unique Binary Tree Created:")
printInorder(root)
print()




# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 11 TODO : serialize and deserialize binary tree
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/serialize-and-deserialize-a-binary-tree/


https://leetcode.com/problems/serialize-and-deserialize-binary-tree/

https://www.youtube.com/watch?v=-YbXySKJsX8&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=108

'''
'''
Time Complexity: O(N)

serialize function: O(N), where N is the number of nodes in the tree. This is because the function performs a level-order traversal of the tree, visiting each node once.
deserialize function: O(N), where N is the number of nodes in the tree. Similar to the serialize function, it processes each node once while reconstructing the tree.
Space Complexity: O(N)

serialize function: O(N), where N is the maximum number of nodes at any level in the tree. In the worst case, the queue can hold all nodes at the last level of the tree.
deserialize function: O(N), where N is the maximum number of nodes at any level in the tree. The queue is used to store nodes during the reconstruction process, and in the worst case, it may hold all nodes at the last level.
'''                            
from queue import Queue
from typing import Optional

# Definition for a
# binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def serialize(self, root: Optional[TreeNode]) -> str:
        # Check if the tree is empty
        if not root:
            return ""

        # Initialize an empty string
        # to store the serialized data
        s = ""
        # Use a queue for
        # level-order traversal
        q = Queue()
        # Start with the root node
        q.put(root)

        # Perform level-order traversal
        while not q.empty():
            # Get the front node in the queue
            cur_node = q.get()

            # Check if the current node is
            # null and append "#" to the string
            if not cur_node:
                s += "#,"
            else:
                # Append the value of the
                # current node to the string
                s += str(cur_node.val) + ","
                # Push the left and right children
                # to the queue for further traversal
                q.put(cur_node.left)
                q.put(cur_node.right)

        # Return the
        # serialized string
        return s

    def deserialize(self, data: str) -> Optional[TreeNode]:
        # Check if the
        # serialized data is empty
        if not data:
            return None

        # Use a queue for
        # level-order traversal
        q = Queue()
        # Use a list to store tokens
        tokens = data.split(',')
        # Read the root value
        # from the serialized data
        root_val = int(tokens.pop(0))
        root = TreeNode(root_val)
        q.put(root)

        # Perform level-order traversal
        # to reconstruct the tree
        while not q.empty():
            # Get the front node in the queue
            node = q.get()

            # Read the value of the left
            # child from the serialized data
            left_val = tokens.pop(0)
            # If the value is not "#", create a new
            # left child and push it to the queue
            if left_val != "#":
                left_node = TreeNode(int(left_val))
                node.left = left_node
                q.put(left_node)

            # Read the value of the right child
            # from the serialized data
            right_val = tokens.pop(0)
            # If the value is not "#", create a
            # new right child and push it to the queue
            if right_val != "#":
                right_node = TreeNode(int(right_val))
                node.right = right_node
                q.put(right_node)

        # Return the reconstructed
        # root of the tree
        return root

def inorder(root):
    if not root:
        return
    inorder(root.left)
    print(root.val, end=" ")
    inorder(root.right)

if __name__ == "__main__":
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.right.left = TreeNode(4)
    root.right.right = TreeNode(5)

    solution = Solution()
    print("Original Tree: ", end="")
    inorder(root)
    print()

    serialized = solution.serialize(root)
    print("Serialized: " + serialized)

    deserialized = solution.deserialize(serialized)
    print("Tree after deserialization: ", end="")
    inorder(deserialized)
    print()
                           
                        

# 12 TODO : morris preorder traversal of a binary tree
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/morris-preorder-traversal-of-a-binary-tree/


https://leetcode.com/problems/binary-tree-inorder-traversal/

https://www.youtube.com/watch?v=80Zug6D1_r4&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=109

'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(2N) where N is the number of nodes in the Binary Tree.

The time complexity is linear, as each node is visited at most twice (once for establishing the temporary link and once for reverting it).
In each step, we perform constant-time operations, such as moving to the left or right child and updating pointers.
Space Complexity: O(1) The space complexity is constant, as the algorithm uses only a constant amount of extra space irrespective of the input size.

Morris Traversal does not use any additional data structures like stacks or recursion, making it an in-place algorithm.
The only space utilised is for a few auxiliary variables, such as pointers to current and in-order predecessor nodes.
'''                            
# TreeNode class definition
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def getPreorder(self, root):
        # List to store the preorder traversal result
        preorder = []

        # Pointer to the current node, starting with the root
        cur = root

        # Iterate until the current node becomes None
        while cur is not None:
            # If the current node has no left child
            if cur.left is None:
                # Add the value of the current node to the preorder list
                preorder.append(cur.val)

                # Move to the right child
                cur = cur.right
            else:
                # If the current node has a left child
                # Create a pointer to traverse to the rightmost node in the left subtree
                prev = cur.left

                # Traverse to the rightmost node in the left subtree
                # or until we find a node whose right child is not yet processed
                while prev.right and prev.right != cur:
                    prev = prev.right

                # If the right child of the rightmost node is None
                if prev.right is None:
                    # Set the right child of the rightmost node to the current node
                    prev.right = cur

                    # Move to the left child
                    cur = cur.left
                else:
                    # If the right child of the rightmost node is not None
                    # Reset the right child to None
                    prev.right = None

                    # Add the value of the current node to the preorder list
                    preorder.append(cur.val)

                    # Move to the right child
                    cur = cur.right

        # Return the resulting preorder traversal list
        return preorder


# Main function
if __name__ == "__main__":
    # Construct the binary tree
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)
    root.left.right.right = TreeNode(6)

    # Create an instance of the Solution class
    sol = Solution()

    # Perform Morris Preorder Traversal
    preorder = sol.getPreorder(root)

    # Print the result
    print("Binary Tree Morris Preorder Traversal:", end=" ")
    for val in preorder:
        print(val, end=" ")
    print()



# 13 TODO : morris inorder traversal of a binary tree
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://takeuforward.org/data-structure/morris-inorder-traversal-of-a-binary-tree/


https://leetcode.com/problems/binary-tree-inorder-traversal/

https://www.youtube.com/watch?v=80Zug6D1_r4&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=109

'''


# method 1 : brute force approch
'''
Time Complexity: O(2N) where N is the number of nodes in the Binary Tree.

The time complexity is linear, as each node is visited at most twice (once for establishing the temporary link and once for reverting it).
In each step, we perform constant-time operations, such as moving to the left or right child and updating pointers.
Space Complexity: O(1) The space complexity is constant, as the algorithm uses only a constant amount of extra space irrespective of the input size.

Morris Traversal does not use any additional data structures like stacks or recursion, making it an in-place algorithm.
The only space utilised is for a few auxiliary variables, such as pointers to current and in-order predecessor nodes.
'''                            
# TreeNode structure
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def getInorder(self, root):
        # Vector to store the
        # inorder traversal result
        inorder = []
        # Pointer to the current node,
        # starting from the root
        cur = root

        # Loop until the current
        # node is not None
        while cur is not None:
            # If the current node's
            # left child is None
            if cur.left is None:
                # Add the value of the current
                # node to the inorder list
                inorder.append(cur.val)
                # Move to the right child
                cur = cur.right
            else:
                # If the left child is not None,
                # find the predecessor (rightmost node
                # in the left subtree)
                prev = cur.left
                while prev.right and prev.right != cur:
                    prev = prev.right

                # If the predecessor's right child
                # is None, establish a temporary link
                # and move to the left child
                if prev.right is None:
                    prev.right = cur
                    cur = cur.left
                else:
                    # If the predecessor's right child
                    # is already linked, remove the link,
                    # add the current node to inorder list,
                    # and move to the right child
                    prev.right = None
                    inorder.append(cur.val)
                    cur = cur.right

        # Return the inorder
        # traversal result
        return inorder


if __name__ == "__main__":
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)
    root.left.right.right = TreeNode(6)

    sol = Solution()

    inorder = sol.getInorder(root)

    print("Binary Tree Morris Inorder Traversal:", end=" ")
    for val in inorder:
        print(val, end=" ")
    print()



# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 14 TODO : flatten  binary tree to linked list
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/flatten-binary-tree-to-linked-list/


https://leetcode.com/problems/flatten-binary-tree-to-linked-list/

https://www.youtube.com/watch?v=sWf7k1x9XR4&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=110

'''
# method 1 : brute force approch
'''
Time Complexity: O(N) where N is the number of nodes in the Binary Tree. Each node of the binary node is visited exactly once. At each node, constant-time operations are performed. Hence the time complexity is O(N).

Space Complexity : O(log2N)where N is the number of nodes in the Binary Tree. There are no additional data structures or space used but the auxiliary stack space is used during recursion. Since the recursion depth can be at most equal to the height to the Binary Tree, the space complexity is O(H) where H is the height of the Binary Tree. In the ideal case, H = log2N and in the worst case H = N (skewed tree).
'''                                
# TreeNode structure
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def __init__(self):
        # Initialize a global variable
        # 'prev' to keep track of the
        # previously processed node.
        self.prev = None

    # Function to flatten a binary tree
    # to a right next Linked List structure
    def flatten(self, root):
        # Base case: If the current
        # node is None, return.
        if root is None:
            return

        # Recursive call to
        # flatten the right subtree
        self.flatten(root.right)

        # Recursive call to
        # flatten the left subtree
        self.flatten(root.left)

        # At this point, both left and right
        # subtrees are flattened, and 'prev'
        # is pointing to the rightmost node
        # in the flattened right subtree.

        # Set the right child of
        # the current node to 'prev'.
        root.right = self.prev

        # Set the left child of the
        # current node to None.
        root.left = None

        # Update 'prev' to the current
        # node for the next iteration.
        self.prev = root

# Print the preorder traversal of the
# Original Binary Tree
def print_preorder(root):
    if not root:
        return
    print(root.val, end=" ")
    print_preorder(root.left)
    print_preorder(root.right)

# Print the Binary Tree along the
# Right Pointers after Flattening
def print_flatten_tree(root):
    if not root:
        return
    print(root.val, end=" ")
    print_flatten_tree(root.right)

if __name__ == "__main__":
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)
    root.left.right.right = TreeNode(6)
    root.right.right = TreeNode(7)
    root.right.left = TreeNode(8)

    sol = Solution()

    print("Binary Tree Preorder: ", end="")
    print_preorder(root)
    print()

    sol.flatten(root)

    print("Binary Tree After Flatten: ", end="")
    print_flatten_tree(root)
    print()
    


# method 2 : better approch
'''
Time Complexity: O(N) where N is the number of nodes in the Binary Tree. Each node of the binary node is visited exactly once. At each node, constant-time operations are performed. Hence the time complexity is O(N).

Space Complexity : O(log2N) where N is the number of nodes in the Binary Tree. There are no additional data structures or space used but the auxiliary stack space is used during recursion. Since the recursion depth can be at most equal to the height to the Binary Tree, the space complexity is O(H) where H is the height of the Binary Tree. In the ideal case, H = log2N and in the worst case H = N (skewed tree).
'''                                
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def __init__(self):
        # Initialize a global variable
        # 'prev' to keep track of the
        # previously processed node.
        self.prev = None

    # Function to flatten a binary tree
    # to a right next Linked List structure
    def flatten(self, root):
        # Base case: If the current
        # node is None, return.
        if not root:
            return
        
        # Use a stack for
        # iterative traversal.
        stack = [root]

        # Continue the loop until
        # the stack is empty.
        while stack:
            # Get the top node from the stack.
            cur = stack.pop()

            if cur.right:
                # Push the right child
                # onto the stack.
                stack.append(cur.right)

            if cur.left:
                # Push the left child
                # onto the stack.
                stack.append(cur.left)

            if stack:
                # Connect the right child to
                # the next node in the stack.
                cur.right = stack[-1]

            # Set the left child to None to
            # form a right-oriented linked list.
            cur.left = None

# Print the preorder traversal of the
# Original Binary Tree
def print_preorder(root):
    if not root:
        return
    print(root.val, end=" ")
    print_preorder(root.left)
    print_preorder(root.right)

# Print the Binary Tree along the 
# Right Pointers after Flattening
def print_flatten_tree(root):
    if not root:
        return
    print(root.val, end=" ")
    print_flatten_tree(root.right)

if __name__ == "__main__":
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)
    root.left.right.right = TreeNode(6)
    root.right.right = TreeNode(7)
    root.right.left = TreeNode(8)

    sol = Solution()

    print("Binary Tree Preorder: ", end="")
    print_preorder(root)
    print()

    sol.flatten(root)

    print("Binary Tree After Flatten: ", end="")
    print_flatten_tree(root)
    print()



# method 3 : optimal solution
'''
Time Complexity: O(2N) where N is the number of nodes in the Binary Tree.

The time complexity is linear, as each node is visited at most twice (once for establishing the temporary link and once for reverting it).
In each step, we perform constant-time operations, such as moving to the left or right child and updating pointers.
Space Complexity: O(1) The space complexity is constant, as the algorithm uses only a constant amount of extra space irrespective of the input size.

Morris Traversal does not use any additional data structures like stacks or recursion, making it an in-place algorithm.
The only space utilised is for a few auxiliary variables, such as pointers to current and in-order predecessor nodes.
'''
                                
# TreeNode structure
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    # Function to flatten a binary tree
    # to a right next Linked List structure
    def flatten(self, root):
        # Initialize a pointer
        # 'curr' to the root of the tree
        curr = root

        # Iterate until 'curr'
        # becomes None
        while curr:
            # Check if the current
            # node has a left child
            if curr.left:
                # If yes, find the rightmost
                # node in the left subtree
                pre = curr.left
                while pre.right:
                    pre = pre.right

                # Connect the rightmost node in
                # the left subtree to the current
                # node's right child
                pre.right = curr.right

                # Move the entire left subtree to the
                # right child of the current node
                curr.right = curr.left

                # Set the left child of
                # the current node to None
                curr.left = None

            # Move to the next node
            # on the right side
            curr = curr.right

# Print the preorder traversal of the
# Original Binary Tree
def print_preorder(root):
    if not root:
        return
    print(root.val, end=" ")
    print_preorder(root.left)
    print_preorder(root.right)

# Print the Binary Tree along the
# Right Pointers after Flattening
def print_flatten_tree(root):
    if not root:
        return
    print(root.val, end=" ")
    print_flatten_tree(root.right)

if __name__ == "__main__":
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)
    root.left.right.right = TreeNode(6)
    root.right.right = TreeNode(7)
    root.right.left = TreeNode(8)

    sol = Solution()

    print("Binary Tree Preorder: ", end="")
    print_preorder(root)
    print()

    sol.flatten(root)

    print("Binary Tree After Flatten: ", end="")
    print_flatten_tree(root)
    print()






# endregion






# region 14.1 BINARY SEARCH TREES - CONCEPTS
# ------------------------------------------

# 1 TODO :  introduction to binary search tree
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/binary-search-tree/introduction-to-binary-search-trees/


https://bit.ly/3gprRLk

https://www.youtube.com/watch?v=p7-9UvDQZ3w&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=111

'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : search in a binary search tree
'''


ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢



https://takeuforward.org/data-structure/search-in-a-binary-search-tree-2/


https://leetcode.com/problems/search-in-a-binary-search-tree/

https://www.youtube.com/watch?v=KcNt6v_56cc&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=112

'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(log2N) where N is the number of nodes in the Binary Search Tree. In the best case scenario, where the tree is balanced, the time complexity is the height of the tree ie. log2N. In the worst-case scenario, where the tree is degenerate (linear), the time complexity becomes O(n), as it would require traversing all nodes along the path from the root to the leaf.

Space Complexity: O(1) since the algorithm does not use any additional space or data structures. The algorithm does use auxiliary stack space from recursion. In the average and worst-case scenarios, the space complexity for recursive stack space is O(h), where 'h' represents the height of the tree.
'''                            
# Definition of TreeNode structure
# for a binary tree node
class TreeNode:
    # Constructor to initialize the node with a
    # value and set left and right pointers to None
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    # This function searches for a node with
    # a specified value in a Binary Search Tree (BST).
    def searchBST(self, root, val):
        # Loop until either the tree is
        # exhausted (None) or the value is found.
        while root is not None and root.val != val:
            # Check if the target value is
            # less than the current node's value.
            # If so, move to the left subtree
            # (values smaller than the current node).
            # Otherwise, move to the right subtree
            # (values larger than the current node).
            root = root.left if val < root.val else root.right
        # Return the node containing the target value,
        # if found; otherwise, return None.
        return root

# Function to perform an in-order traversal
# of a binary tree and print its nodes
def printInOrder(root):
    # Check if the current node
    # is None (base case for recursion)
    if root is None:
        # If None, return and
        # terminate the function
        return

    # Recursively call printInOrder
    # for the left subtree
    printInOrder(root.left)

    # Print the value of the current node
    print(root.val, end=" ")

    # Recursively call printInOrder
    # for the right subtree
    printInOrder(root.right)

# Creating a BST
root = TreeNode(5)
root.left = TreeNode(3)
root.right = TreeNode(8)
root.left.left = TreeNode(2)
root.left.right = TreeNode(4)
root.right.left = TreeNode(6)
root.right.right = TreeNode(10)

print("Binary Search Tree:")
printInOrder(root)
print()

solution = Solution()

# Searching for a value in the BST
target = 6
result = solution.searchBST(root, target)

# Displaying the search result
if result is not None:
    print(f"Value {target} found in the BST!")
else:
    print(f"Value {target} not found in the BST.")




# 3 TODO : find min/max in BST
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://practice.geeksforgeeks.org/problems/minimum-element-in-bst/1


'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      



# endregion






# region 14.2 BINARY SEARCH TREES - PRACTICE PROBLEMS
# ---------------------------------------------------

# 1 TODO :  ceil in a BST
'''


ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/binary-search-tree/ceil-in-a-binary-search-tree/


https://practice.geeksforgeeks.org/problems/implementing-ceil-in-bst/1

https://www.youtube.com/watch?v=KSsk8AhdOZA&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=113

'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(log2N) where N is the number of nodes in the Binary Search Tree. In the best case scenario, where the tree is balanced, the time complexity is the height of the tree ie. log2N. In the worst-case scenario, where the tree is degenerate (linear), the time complexity becomes O(n), as it would require traversing all nodes along the path from the root to the leaf.

Space Complexity: O(1) since the algorithm does not use any additional space or data structures.
'''                            
# Definition of TreeNode structure
# for a binary tree node
class TreeNode:
    # Constructor to initialize the node with a
    # value and set left and right pointers to null
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    # Function to find the ceiling of
    # a key in a Binary Search Tree (BST)
    def findCeil(self, root, key):
        # Initialize the variable
        # to store the ceiling value
        ceil = -1
        
        # Traverse the BST until reaching
        # the end or finding the key
        while root:
            # If the key is found, assign it
            # as the ceiling and return
            if root.val == key:
                ceil = root.val
                return ceil
            
            # If the key is greater,
            # move to the right subtree
            if key > root.val:
                root = root.right
            else:
                # If the key is smaller, update ceil
                # and move to the left subtree
                ceil = root.val
                root = root.left
        
        # Return the computed ceiling value
        return ceil

# Function to perform an in-order traversal
# of a binary tree and print its nodes
def printInOrder(root):
    # Check if the current node
    # is null (base case for recursion)
    if not root:
        # If null, return and
        # terminate the function
        return
    
    # Recursively call printInOrder
    # for the left subtree
    printInOrder(root.left)
    
    # Print the value of the current node
    print(root.val, end=" ")
    
    # Recursively call printInOrder
    # for the right subtree
    printInOrder(root.right)

# Creating a BST
root = TreeNode(10)
root.left = TreeNode(5)
root.right = TreeNode(13)
root.left.left = TreeNode(3)
root.left.left.left = TreeNode(2)
root.left.left.right = TreeNode(4)
root.left.right = TreeNode(6)
root.left.right.right = TreeNode(9)
root.right.left = TreeNode(11)
root.right.right = TreeNode(14)

print("Binary Search Tree:")
printInOrder(root)
print()

solution = Solution()

# Searching for a value in the BST
target = 8
ciel = solution.findCeil(root, target)

if ciel != -1:
    print(f"Ceiling of {target} is: {ciel}")
else:
    print("No ceiling found!")



# 2 TODO : floor in a BST
'''


ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢

floor - val <= key

https://takeuforward.org/binary-search-tree/floor-in-a-binary-search-tree/


https://bit.ly/3TSbXXE

https://www.youtube.com/watch?v=xm_W1ub-K-w&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=114

'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(log2N) where N is the number of nodes in the Binary Search Tree. In the best case scenario, where the tree is balanced, the time complexity is the height of the tree ie. log2N. In the worst-case scenario, where the tree is degenerate (linear), the time complexity becomes O(N), as it would require traversing all nodes along the path from the root to the leaf.

Space Complexity: O(1) since the algorithm does not use any additional space or data structures.
'''                            
# Definition of TreeNode structure
# for a binary tree node
class TreeNode:
    # Constructor to initialize the node with a
    # value and set left and right pointers to null
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    # Function to find the floor of a key
    # in a Binary Search Tree (BST)
    def floorInBST(self, root, key):
        # Initialize the floor variable
        # to store the floor value
        floor = -1
        
        # Traverse the BST until reaching
        # the end or finding the key
        while root:
            # If the key is found, assign it 
            # as the floor value and return
            if root.val == key:
                floor = root.val
                return floor
            
            # If the key is greater than the current
            # node's value, move to the right subtree
            if key > root.val:
                # Update the floor with the current node's
                # value and move to the right subtree
                floor = root.val
                root = root.right
            else:
                # If the key is smaller than the current
                # node's value, move to the left subtree
                root = root.left
        
        # Return the computed floor value
        return floor

# Function to perform an in-order traversal
# of a binary tree and print its nodes
def printInOrder(root):
    # Check if the current node
    # is null (base case for recursion)
    if root is None:
        # If null, return and
        # terminate the function
        return
    
    # Recursively call printInOrder
    # for the left subtree
    printInOrder(root.left)
    
    # Print the value of the current node
    print(root.val, end=" ")
    
    # Recursively call printInOrder
    # for the right subtree
    printInOrder(root.right)

# Creating a BST
root = TreeNode(10)
root.left = TreeNode(5)
root.right = TreeNode(13)
root.left.left = TreeNode(3)
root.left.left.left = TreeNode(2)
root.left.left.right = TreeNode(4)
root.left.right = TreeNode(6)
root.left.right.right = TreeNode(9)
root.right.left = TreeNode(11)
root.right.right = TreeNode(14)

print("Binary Search Tree:")
printInOrder(root)
print()

solution = Solution()

# Searching for a value in the BST
target = 8
ciel = solution.floorInBST(root, target)

if ciel != -1:
    print(f"Floor of {target} is: {ciel}")
else:
    print("No floor found!")
                           
                          


# 3 TODO : insert a given node in BST
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://leetcode.com/problems/insert-into-a-binary-search-tree/

https://www.youtube.com/watch?v=FiFiNvM29ps&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=115

'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# Definition of TreeNode structure
# for a binary tree node
class TreeNode:
    # Constructor to initialize the node with a
    # value and set left and right pointers to null
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:

    # Iterative approach to insert a node in the BST
    def insertInBST(self, root, key):
        # Create a new node
        new_node = TreeNode(key)
        
        # If the tree is empty, the new node becomes the root
        if root is None:
            return new_node
        
        current = root
        while current:
            # If the key is smaller, go to the left subtree
            if key < current.val:
                # If there's no left child, insert here
                if current.left is None:
                    current.left = new_node
                    break
                else:
                    current = current.left
            # If the key is greater, go to the right subtree
            elif key > current.val:
                # If there's no right child, insert here
                if current.right is None:
                    current.right = new_node
                    break
                else:
                    current = current.right
        
        # Return the root of the tree
        return root

# Function to perform an in-order traversal
# of a binary tree and print its nodes
def printInOrder(root):
    # Check if the current node
    # is null (base case for recursion)
    if root is None:
        # If null, return and
        # terminate the function
        return
    
    # Recursively call printInOrder
    # for the left subtree
    printInOrder(root.left)
    
    # Print the value of the current node
    print(root.val, end=" ")
    
    # Recursively call printInOrder
    # for the right subtree
    printInOrder(root.right)

# Creating a BST
root = TreeNode(10)
root.left = TreeNode(5)
root.right = TreeNode(13)
root.left.left = TreeNode(3)
root.left.left.left = TreeNode(2)
root.left.left.right = TreeNode(4)
root.left.right = TreeNode(6)
root.left.right.right = TreeNode(9)
root.right.left = TreeNode(11)
root.right.right = TreeNode(14)

print("Binary Search Tree before insertion:")
printInOrder(root)
print()

# Insert a new node with value 8
solution = Solution()
root = solution.insertInBST(root, 8)

print("Binary Search Tree after insertion:")
printInOrder(root)
print()



# method 2 : better approch
# TC     -      
# SC     -     

# Definition of TreeNode structure
# for a binary tree node
class TreeNode:
    # Constructor to initialize the node with a
    # value and set left and right pointers to null
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    # Function to insert a node in the BST
    def insertInBST(self, root, key):
        # If the tree is empty, return a new node
        if root is None:
            return TreeNode(key)
        
        # Otherwise, recur down the tree
        if key < root.val:
            root.left = self.insertInBST(root.left, key)
        elif key > root.val:
            root.right = self.insertInBST(root.right, key)
        
        # Return the unchanged node pointer
        return root


# Function to perform an in-order traversal
# of a binary tree and print its nodes
def printInOrder(root):
    # Check if the current node
    # is null (base case for recursion)
    if root is None:
        # If null, return and
        # terminate the function
        return
    
    # Recursively call printInOrder
    # for the left subtree
    printInOrder(root.left)
    
    # Print the value of the current node
    print(root.val, end=" ")
    
    # Recursively call printInOrder
    # for the right subtree
    printInOrder(root.right)

# Creating a BST
root = TreeNode(10)
root.left = TreeNode(5)
root.right = TreeNode(13)
root.left.left = TreeNode(3)
root.left.left.left = TreeNode(2)
root.left.left.right = TreeNode(4)
root.left.right = TreeNode(6)
root.left.right.right = TreeNode(9)
root.right.left = TreeNode(11)
root.right.right = TreeNode(14)

print("Binary Search Tree before insertion:")
printInOrder(root)
print()

# Insert a new node with value 8
solution = Solution()
root = solution.insertInBST(root, 8)

print("Binary Search Tree after insertion:")
printInOrder(root)
print()




# method 3 : optimal solution
# TC     -      
# SC     -      


# 4 TODO : delete a node in BST
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/delete-node-in-a-bst/

https://www.youtube.com/watch?v=kouxiP_H5WE&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=116

'''
# method 1 : brute force approch
# TC     -      
# SC     -     

# ğŸ‘‰ğŸ‘‰ğŸ‘‰ NOT STRIVER'S SOLUTION
# Definition of TreeNode structure
# for a binary tree node
class TreeNode:
    # Constructor to initialize the node with a
    # value and set left and right pointers to null
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    # Iterative approach to delete a node in the BST
    def deleteNode(self, root, key):
        # Start with the root node
        current = root
        parent = None
        
        # Find the node to be deleted
        while current and current.val != key:
            parent = current
            if key < current.val:
                current = current.left
            else:
                current = current.right
        
        # If the node wasn't found, return the unchanged tree
        if not current:
            return root
        
        # Case 1: Node has no children (leaf node)
        if not current.left and not current.right:
            if parent is None:
                return None  # The tree only has one node
            if parent.left == current:
                parent.left = None
            else:
                parent.right = None
        
        # Case 2: Node has one child
        elif not current.left or not current.right:
            child = current.left if current.left else current.right
            if parent is None:
                return child  # The node to be deleted is the root
            if parent.left == current:
                parent.left = child
            else:
                parent.right = child
        
        # Case 3: Node has two children
        else:
            # Find the inorder successor (smallest node in the right subtree)
            successor_parent = current
            successor = current.right
            while successor.left:
                successor_parent = successor
                successor = successor.left
            
            # Replace current node with the successor's value
            current.val = successor.val
            
            # Delete the successor
            if successor_parent.left == successor:
                successor_parent.left = successor.right
            else:
                successor_parent.right = successor.right
        
        return root


# Function to perform an in-order traversal
# of a binary tree and print its nodes
def printInOrder(root):
    # Check if the current node
    # is null (base case for recursion)
    if root is None:
        # If null, return and
        # terminate the function
        return
    
    # Recursively call printInOrder
    # for the left subtree
    printInOrder(root.left)
    
    # Print the value of the current node
    print(root.val, end=" ")
    
    # Recursively call printInOrder
    # for the right subtree
    printInOrder(root.right)

# Creating a BST
root = TreeNode(10)
root.left = TreeNode(5)
root.right = TreeNode(13)
root.left.left = TreeNode(3)
root.left.left.left = TreeNode(2)
root.left.left.right = TreeNode(4)
root.left.right = TreeNode(6)
root.left.right.right = TreeNode(9)
root.right.left = TreeNode(11)
root.right.right = TreeNode(14)

print("Binary Search Tree before deletion:")
printInOrder(root)
print()

# Deleting a node with value 5
solution = Solution()
root = solution.deleteNode(root, 5)

print("Binary Search Tree after deletion:")
printInOrder(root)
print()



# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 5 TODO : find Kth smallest/largest element in BST
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/kth-largest-smallest-element-in-binary-search-tree/


https://leetcode.com/problems/kth-smallest-element-in-a-bst/

https://www.youtube.com/watch?v=9TJYWh0adfk&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=117

'''
# method 1 : brute force approch
'''
Time Complexity: O(N) where N is the number of nodes in the Binary Search Tree. because traversing the entire BST to perform an inorder traversal takes linear time. We visit each node once resulting in time complexity proportional to the number of nodes in the BST.

Space Complexity : O(N) where N is the number of nodes in the Binary Search Tree as additional space is required to store the elements of the BST in an array.
'''                                
# Definition of TreeNode structure
# for a binary tree node
class TreeNode:
    # Constructor to initialize the node with a
    # value and set left and right pointers to null
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    # Inorder traversal to populate
    # the list with BST elements
    def inorder(self, node, arr):
        if not node:
            return
        # Recursive call to the left subtree
        self.inorder(node.left, arr)
        
        # Append the value of current
        # node into the list
        arr.append(node.val)
        
        # Recursive call to the right subtree
        self.inorder(node.right, arr)
        return

    # Function to find the Kth
    # smallest and largest elements in BST
    def findKth(self, node, k):
        # List to store the
        # elements of the BST
        arr = []
        
        # Perform inorder traversal
        # to populate the list
        self.inorder(node, arr)
        
        # Calculate Kth largest
        # and smallest elements
        kLargest = arr[len(arr) - k]
        kSmallest = arr[k - 1]
        
        # Returning a tuple containing
        # Kth smallest and largest elements
        return (kSmallest, kLargest)


# Function to perform an in-order traversal
# of a binary tree and print its nodes
def printInOrder(root):
    # Check if the current node
    # is null (base case for recursion)
    if not root:
        # If null, return and
        # terminate the function
        return
    
    # Recursively call printInOrder
    # for the left subtree
    printInOrder(root.left)
    
    # Print the value of the current node
    print(root.val, end=" ")

    # Recursively call printInOrder
    # for the right subtree
    printInOrder(root.right)

# Creating a BST
root = TreeNode(10)
root.left = TreeNode(5)
root.right = TreeNode(13)
root.left.left = TreeNode(3)
root.left.left.left = TreeNode(2)
root.left.left.right = TreeNode(4)
root.left.right = TreeNode(6)
root.left.right.right = TreeNode(9)
root.right.left = TreeNode(11)
root.right.right = TreeNode(14)

print("Binary Search Tree:")
printInOrder(root)
print()

solution = Solution()

# Find the Kth smallest and largest elements
k = 3
print("k:", k)
kthElements = solution.findKth(root, k)

print("Kth smallest element:", kthElements[0])
print("Kth largest element:", kthElements[1])
                                
                              


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity: O(N) where N is the number of nodes in the Binary Search Tree as we traverse in inorder and reverse inorder fashion to get to the required nodes. We visit each node once resulting in time complexity proportional to the number of nodes in the BST.

Space Complexity : as no additional space is allocated or data structures used to store any values.
'''                                
                     
# Definition of TreeNode class
# for a binary tree node
class TreeNode:
    def __init__(self, x):
        # Value of the node
        self.val = x
        
        # Pointer to the left child node
        self.left = None
        
        # Pointer to the right child node
        self.right = None

# Solution class to find Kth smallest and largest elements
class Solution:
    def __init__(self):
        pass

    # Helper function to perform reverse inorder
    # traversal to find Kth largest element
    def reverse_inorder(self, node, counter, k, k_largest):
        if not node or counter[0] >= k:
            return
        
        # Traverse right subtree
        self.reverse_inorder(node.right, counter, k, k_largest)

        # Increment counter after
        # visiting right subtree
        counter[0] += 1

        # Check if current node
        # is the Kth largest
        if counter[0] == k:
            k_largest[0] = node.val
            return

        # Traverse left subtree if
        # Kth largest is not found yet
        self.reverse_inorder(node.left, counter, k, k_largest)

    # Helper function to perform inorder
    # traversal to find Kth smallest element
    def inorder(self, node, counter, k, k_smallest):
        if not node or counter[0] >= k:
            return

        # Traverse left subtree
        self.inorder(node.left, counter, k, k_smallest)

        # Increment counter after visiting left subtree
        counter[0] += 1

        # Check if current node is the Kth smallest
        if counter[0] == k:
            k_smallest[0] = node.val
            return

        # Traverse right subtree if
        # Kth smallest is not found yet
        self.inorder(node.right, counter, k, k_smallest)

    def find_kth(self, root, k):
        k_smallest = [float('inf')]
        k_largest = [float('-inf')]
        # Counter to track visited nodes
        counter = [0]

        # Find Kth smallest element
        # (perform inorder traversal)
        self.inorder(root, counter, k, k_smallest)
        
        # Reset counter for Kth largest element
        counter[0] = 0
        # Find Kth largest element
        # (perform reverse inorder traversal)
        self.reverse_inorder(root, counter, k, k_largest)

        return k_smallest[0], k_largest[0]


# Function to perform an in-order traversal
# of a binary tree and print its nodes
def print_in_order(root):
    # Check if the current node
    # is null (base case for recursion)
    if not root:
        # If null, return and
        # terminate the function
        return
    
    # Recursively call printInOrder
    # for the left subtree
    print_in_order(root.left)

    # Print the value of the current node
    print(root.val, end=" ")

    # Recursively call printInOrder
    # for the right subtree
    print_in_order(root.right)

# Creating a BST
root = TreeNode(10)
root.left = TreeNode(5)
root.right = TreeNode(13)
root.left.left = TreeNode(3)
root.left.left.left = TreeNode(2)
root.left.left.right = TreeNode(4)
root.left.right = TreeNode(6)
root.left.right.right = TreeNode(9)
root.right.left = TreeNode(11)
root.right.right = TreeNode(14)

print("Binary Search Tree:")
print_in_order(root)
print()

solution = Solution()

# Find the Kth smallest and largest elements
k = 3
print("k:", k)
kth_elements = solution.find_kth(root, k)

print("Kth smallest element:", kth_elements[0])
print("Kth largest element:", kth_elements[1])



# 6 TODO : check if a tree is BST or BT
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://leetcode.com/problems/validate-binary-search-tree/

https://www.youtube.com/watch?v=f-sj7I5oXEI&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=118


'''
# method 1 : brute force approch
# TC     -      
# SC     -     
# Definition of TreeNode class
class TreeNode:
    def __init__(self, x):
        # Value of the node
        self.val = x
        # Pointer to the left child node
        self.left = None
        # Pointer to the right child node
        self.right = None

# Solution class to find Kth smallest and largest elements
class Solution:
    def __init__(self):
        pass
    
    def is_bst_util(self, node, min_val, max_val):
        # If node is None, it's a valid BST by default (base case)
        if not node:
            return True

        # The current node's value must be between min_val and max_val
        if not (min_val < node.val < max_val):
            return False

        # Recursively check the left and right subtrees
        return (self.is_bst_util(node.left, min_val, node.val) and
                self.is_bst_util(node.right, node.val, max_val))

    def is_bst(self, root):
        # Call utility function with extreme values as initial min and max
        return self.is_bst_util(root, float('-inf'), float('inf'))


# Function to perform an in-order traversal of a binary tree and print its nodes
def print_in_order(root):
    # Check if the current node is null (base case for recursion)
    if not root:
        return
    
    # Recursively call print_in_order for the left subtree
    print_in_order(root.left)

    # Print the value of the current node
    print(root.val, end=" ")

    # Recursively call print_in_order for the right subtree
    print_in_order(root.right)


# Example Usage

# Creating a BST
root = TreeNode(10)
root.left = TreeNode(5)
root.right = TreeNode(13)
root.left.left = TreeNode(3)
root.left.left.left = TreeNode(2)
root.left.left.right = TreeNode(4)
root.left.right = TreeNode(6)
root.left.right.right = TreeNode(9)
root.right.left = TreeNode(11)
root.right.right = TreeNode(14)

print("Binary Tree In-order:")
print_in_order(root)
print()

# Create an instance of Solution
solution = Solution()

# Check if the tree is a BST
is_bst = solution.is_bst(root)
if is_bst:
    print("The tree is a Binary Search Tree (BST).")
else:
    print("The tree is not a Binary Search Tree (BST).")

# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 7 TODO : LCA in a BST
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

LCA -  lowest common ancestor

https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

https://www.youtube.com/watch?v=cX_kPV_foZc&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=119

'''
# method 1 : brute force approch
# TC     -      
# SC     -     

# Definition of TreeNode class for a binary tree node
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

# Solution class to find Kth smallest and largest elements, and LCA
class Solution:
    def __init__(self):
        pass

    # Function to find the Lowest Common Ancestor (LCA) of two nodes in a BST
    def lowest_common_ancestor(self, root, p, q):
        # If root is None, return None
        if not root:
            return None
        
        # If both p and q are greater than root, LCA lies in the right subtree
        if p.val > root.val and q.val > root.val:
            return self.lowest_common_ancestor(root.right, p, q)
        
        # If both p and q are smaller than root, LCA lies in the left subtree
        if p.val < root.val and q.val < root.val:
            return self.lowest_common_ancestor(root.left, p, q)
        
        # If one of p or q is equal to root or lies on opposite sides of root,
        # root is the LCA
        return root


# Function to perform an in-order traversal of a binary tree and print its nodes
def print_in_order(root):
    if not root:
        return
    print_in_order(root.left)
    print(root.val, end=" ")
    print_in_order(root.right)


# Example Usage

# Creating a BST
root = TreeNode(10)
root.left = TreeNode(5)
root.right = TreeNode(13)
root.left.left = TreeNode(3)
root.left.left.left = TreeNode(2)
root.left.left.right = TreeNode(4)
root.left.right = TreeNode(6)
root.left.right.right = TreeNode(9)
root.right.left = TreeNode(11)
root.right.right = TreeNode(14)

print("Binary Search Tree In-order:")
print_in_order(root)
print()

# Create an instance of Solution
solution = Solution()

# Find the Lowest Common Ancestor (LCA)
p = root.left.left.left  # Node with value 2
q = root.left.right      # Node with value 6

lca = solution.lowest_common_ancestor(root, p, q)
if lca:
    print(f"LCA of nodes {p.val} and {q.val} is: {lca.val}")
else:
    print("LCA not found.")



# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 8 TODO : construct a BST from preorder traversal
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/

https://www.youtube.com/watch?v=UmJT3j26t1I&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=120

'''
# method 1 : brute force approch
'''
create the inorder from the preorder of the BST, sort the preorder array in asc it will give inorder 
then create the BST from inorder and preorder using earlier example 


'''
# TC     -      
# SC     -     



# method 2 : better approch
# TC     -      
# SC     -     
# # Definition of TreeNode class for a binary tree node
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

# # Solution class to handle operations on BST
# class Solution:
#     def __init__(self):
#         pass

#     # Helper function to insert nodes in the BST from preorder traversal
#     def construct_bst_from_preorder(self, preorder):
#         # Helper function to insert the node while maintaining the BST property
#         def insert_bst(node, val, lower, upper):
#             if not node:
#                 return TreeNode(val)
#             if val < lower or val > upper:
#                 return node  # Return the current node if value is out of bounds
            
#             if val < node.val:
#                 node.left = insert_bst(node.left, val, lower, node.val)
#             else:
#                 node.right = insert_bst(node.right, val, node.val, upper)
            
#             return node

#         # Initialize bounds to (-infinity, infinity) and start inserting from the preorder list
#         root = None
#         for value in preorder:
#             root = insert_bst(root, value, float('-inf'), float('inf'))
        
#         return root

#     # Function to perform an in-order traversal of a binary tree and print its nodes
#     def print_in_order(self, root):
#         if not root:
#             return
#         self.print_in_order(root.left)
#         print(root.val, end=" ")
#         self.print_in_order(root.right)


# # Example Usage

# # Preorder traversal of the tree
# preorder = [10, 5, 3, 2, 4, 6, 9, 13, 11, 14]

# # Create an instance of Solution
# solution = Solution()

# # Construct the BST from preorder
# root = solution.construct_bst_from_preorder(preorder)

# # Print the tree in inorder to check if it is a valid BST
# print("Binary Search Tree In-order:")
# solution.print_in_order(root)

# method 3 : optimal solution
# TC     -      
# SC     -      
# Definition of TreeNode class for a binary tree node
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

# Solution class to handle operations on BST
class Solution:
    def __init__(self):
        pass

    # Helper function to insert nodes in the BST from preorder traversal using only upper bound
    def construct_bst_from_preorder(self, preorder):
        # Helper function to insert the node while maintaining the BST property
        def insert_bst(node, val, upper):
            # If node is None, create the node with the value
            if not node:
                return TreeNode(val)
            # If the value is greater than the upper bound, it's out of valid range
            if val > upper:
                return node  # Return the current node without making any change
            
            # Insert in the left subtree if the value is smaller than the node
            if val < node.val:
                node.left = insert_bst(node.left, val, node.val)
            # Insert in the right subtree if the value is greater than the node
            else:
                node.right = insert_bst(node.right, val, upper)
            
            return node

        # Initialize root as None and start inserting nodes from the preorder list
        root = None
        upper = float('inf')  # Start with the largest possible upper bound
        
        for value in preorder:
            root = insert_bst(root, value, upper)
        
        return root

    # Function to perform an in-order traversal of a binary tree and print its nodes
    def print_in_order(self, root):
        if not root:
            return
        self.print_in_order(root.left)
        print(root.val, end=" ")
        self.print_in_order(root.right)


# Example Usage

# Preorder traversal of the tree
preorder = [10, 5, 3, 2, 4, 6, 9, 13, 11, 14]

# Create an instance of Solution
solution = Solution()

# Construct the BST from preorder
root = solution.construct_bst_from_preorder(preorder)

# Print the tree in inorder to check if it is a valid BST
print("Binary Search Tree In-order:")
solution.print_in_order(root)


# 9 TODO : inorder successor/predecessor in BST
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/inorder-successor-in-bst/

https://www.youtube.com/watch?v=SXKAD2svfmI&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=121

'''
# method 1 : brute force approch
'''
store the inorder in an array and in that array next value than given is the successor 

'''
# TC     -    O(N)  
# SC     -     O(N)


# method 2 : better approch
# TC     -      
# SC     -     
# ğŸ‘‰ğŸ‘‰ğŸ‘‰ NOT STRIVER ANSWER 
# Definition of TreeNode class for a binary tree node
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

# Solution class to handle operations on BST
class Solution:
    def __init__(self):
        pass

    # Function to find the inorder successor of a node in the BST
    def inorder_successor(self, root, node):
        # If the node has a right child, successor is the leftmost node in the right subtree
        if node.right:
            return self._find_min(node.right)
        
        # If the node has no right child, the successor is one of the ancestors
        successor = None
        while root:
            if node.val < root.val:
                successor = root
                root = root.left
            elif node.val > root.val:
                root = root.right
            else:
                break
        return successor

    # Function to find the inorder predecessor of a node in the BST
    def inorder_predecessor(self, root, node):
        # If the node has a left child, predecessor is the rightmost node in the left subtree
        if node.left:
            return self._find_max(node.left)
        
        # If the node has no left child, the predecessor is one of the ancestors
        predecessor = None
        while root:
            if node.val < root.val:
                root = root.left
            elif node.val > root.val:
                predecessor = root
                root = root.right
            else:
                break
        return predecessor

    # Helper function to find the minimum node in a BST (leftmost node)
    def _find_min(self, node):
        while node.left:
            node = node.left
        return node

    # Helper function to find the maximum node in a BST (rightmost node)
    def _find_max(self, node):
        while node.right:
            node = node.right
        return node

    # Function to perform an in-order traversal of a binary tree and print its nodes
    def print_in_order(self, root):
        if not root:
            return
        self.print_in_order(root.left)
        print(root.val, end=" ")
        self.print_in_order(root.right)


# Example Usage

# Create a BST
root = TreeNode(10)
root.left = TreeNode(5)
root.right = TreeNode(15)
root.left.left = TreeNode(3)
root.left.right = TreeNode(7)
root.right.left = TreeNode(12)
root.right.right = TreeNode(18)

# Create an instance of Solution
solution = Solution()

# Example node to find the inorder successor and predecessor
node = root.left.right  # Node with value 7

# Find the inorder successor of the node
successor = solution.inorder_successor(root, node)
predecessor = solution.inorder_predecessor(root, node)

# Output the results
print(f"Inorder Successor of node {node.val}: {successor.val if successor else 'None'}")
print(f"Inorder Predecessor of node {node.val}: {predecessor.val if predecessor else 'None'}")


# method 3 : optimal solution
# TC     -      
# SC     -      


# 10 TODO :  merge 2 BSTs
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://leetcode.com/problems/binary-search-tree-iterator/

https://www.youtube.com/watch?v=D2jMcmxU4bs&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=122

'''
# method 1 : brute force approch
# TC     -      
# SC     -     
# Definition of TreeNode class for a binary tree node
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

# Solution class to implement the BST Iterator
class BSTIterator:
    def __init__(self, root: TreeNode):
        """
        Initialize the BSTIterator with the root of the binary search tree.
        We perform an initial in-order traversal to load the stack.
        """
        self.stack = []
        self._push_left(root)
    
    def _push_left(self, node: TreeNode):
        """
        Helper function to push all the left children of a node to the stack.
        This simulates the in-order traversal.
        """
        while node:
            self.stack.append(node)
            node = node.left
    
    def hasNext(self) -> bool:
        """
        Returns true if there is a next smallest number.
        We just check if the stack is non-empty.
        """
        return len(self.stack) > 0
    
    def next(self) -> int:
        """
        Returns the next smallest number in the BST.
        It pops the top of the stack, then pushes the leftmost child of the right subtree.
        """
        # Pop the top element which will be the next smallest element
        node = self.stack.pop()
        
        # If the current node has a right child, push all left children of the right subtree
        if node.right:
            self._push_left(node.right)
        
        return node.val


# Example Usage

# Create a sample Binary Search Tree
root = TreeNode(7)
root.left = TreeNode(3)
root.right = TreeNode(15)
root.right.left = TreeNode(9)
root.right.right = TreeNode(20)

# Initialize the iterator with the root of the BST
iterator = BSTIterator(root)

# Use the iterator to print the BST in in-order
while iterator.hasNext():
    print(iterator.next())


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 11 TODO : two sum in BST | check if there exists a pair with sum K
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/two-sum-iv-input-is-a-bst/

https://www.youtube.com/watch?v=ssL3sHwPeb4&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=123


'''
# method 1 : brute force approch
# TC     -      
# SC     -     
# ğŸ‘‰ğŸ‘‰ğŸ‘‰ NOT STRIVERS SOLUTION 
# Definition of TreeNode class for a binary tree node
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

# Solution class to implement Two Sum in BST
class Solution:
    def __init__(self):
        self.seen = set()
    
    def find_pair_with_sum(self, root: TreeNode, K: int) -> bool:
        """
        Returns True if there exists a pair of nodes in the BST such that their sum equals K.
        Otherwise, returns False.
        """
        return self._inorder_traversal(root, K)
    
    def _inorder_traversal(self, node: TreeNode, K: int) -> bool:
        """
        Helper function to perform in-order traversal of the BST.
        It checks if a pair exists with the sum equal to K.
        """
        if node is None:
            return False
        
        # Traverse the left subtree
        if self._inorder_traversal(node.left, K):
            return True
        
        # Check if the complement exists in the set
        complement = K - node.val
        if complement in self.seen:
            return True
        
        # Add the current node value to the set
        self.seen.add(node.val)
        
        # Traverse the right subtree
        return self._inorder_traversal(node.right, K)

# Example usage:
# Create a sample Binary Search Tree
root = TreeNode(5)
root.left = TreeNode(3)
root.right = TreeNode(8)
root.left.left = TreeNode(2)
root.left.right = TreeNode(4)
root.right.left = TreeNode(7)
root.right.right = TreeNode(9)

# Initialize the solution class
solution = Solution()

# Find if there's a pair with sum K
K = 10
print(solution.find_pair_with_sum(root, K))  # Output: True (5 + 5 = 10)

K = 15
print(solution.find_pair_with_sum(root, K))  # Output: True (7 + 8 = 15)

K = 20
print(solution.find_pair_with_sum(root, K))  # Output: False


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 12 TODO : recover BST | connest BST with two nodes swapped
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://leetcode.com/problems/recover-binary-search-tree/

https://www.youtube.com/watch?v=ZWGW7FminDM&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=124


'''
# method 1 : brute force approch
# TC     -      
# SC     -     
# ğŸ‘‰ğŸ‘‰ğŸ‘‰ NOT STRIVER SOLUTION
# Definition of TreeNode class for a binary tree node
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

# Solution class to recover the BST
class Solution:
    def __init__(self):
        self.first = None
        self.second = None
        self.prev = None

    def recoverTree(self, root: TreeNode) -> None:
        """
        Recover the BST by identifying two nodes that were swapped and fixing their values.
        """
        # Perform in-order traversal to find the two swapped nodes
        self.inorder_traversal(root)
        
        # Swap the values of the two nodes that were swapped
        if self.first and self.second:
            self.first.val, self.second.val = self.second.val, self.first.val

    def inorder_traversal(self, node: TreeNode) -> None:
        """
        Perform in-order traversal of the tree to find the two swapped nodes.
        """
        if not node:
            return
        
        # Traverse the left subtree
        self.inorder_traversal(node.left)
        
        # Check for violations in the in-order traversal
        if self.prev and self.prev.val > node.val:
            if not self.first:
                # First violation: Mark the first node
                self.first = self.prev
            # Second violation: Mark the second node
            self.second = node
        
        # Update prev to the current node
        self.prev = node
        
        # Traverse the right subtree
        self.inorder_traversal(node.right)

# Example usage:
# Create a sample Binary Search Tree with two nodes swapped
root = TreeNode(3)
root.left = TreeNode(1)
root.right = TreeNode(4)
root.right.left = TreeNode(2)  # Swapped nodes: 2 and 3

# Initialize the solution class
solution = Solution()

# Print the tree before recovery (in-order)
def print_in_order(root):
    if not root:
        return
    print_in_order(root.left)
    print(root.val, end=" ")
    print_in_order(root.right)

print("Tree before recovery (in-order):")
print_in_order(root)
print()

# Recover the BST
solution.recoverTree(root)

# Print the tree after recovery (in-order)
print("Tree after recovery (in-order):")
print_in_order(root)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 13 TODO : largest BST in binary tree
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://practice.geeksforgeeks.org/problems/largest-bst/1

https://www.youtube.com/watch?v=X0oXMdtUDwo&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=125

'''
# method 1 : brute force approch
# TC     -      
# SC     -     
# ğŸ‘‰ğŸ‘‰ğŸ‘‰ NOT STRIVERS SOLUTION 
# Definition of TreeNode class for a binary tree node
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

# Solution class to find the largest BST in a binary tree
class Solution:
    def largestBSTSubtree(self, root: TreeNode) -> int:
        # Helper function to perform post-order traversal and return the size of largest BST
        def postOrder(node):
            if not node:
                return True, 0, float('inf'), float('-inf')  # is_bst, size, min_val, max_val
            
            # Recursively check left and right subtrees
            left_is_bst, left_size, left_min, left_max = postOrder(node.left)
            right_is_bst, right_size, right_min, right_max = postOrder(node.right)
            
            # Check if current node's subtree is a valid BST
            if left_is_bst and right_is_bst and left_max < node.val < right_min:
                # If it's a valid BST, calculate the size of this subtree
                return True, 1 + left_size + right_size, min(node.val, left_min), max(node.val, right_max)
            else:
                # If it's not a valid BST, return the maximum size of the BSTs in the left or right subtrees
                return False, max(left_size, right_size), 0, 0
        
        # Get the result of the post-order traversal
        is_bst, largest_bst_size, _, _ = postOrder(root)
        return largest_bst_size

# Example usage:
# Create a sample binary tree with a mix of BST and non-BST nodes
root = TreeNode(10)
root.left = TreeNode(5)
root.right = TreeNode(15)
root.left.left = TreeNode(1)
root.left.right = TreeNode(8)
root.left.right.left = TreeNode(7)
root.right.left = TreeNode(6)
root.right.right = TreeNode(20)

# Initialize the solution class
solution = Solution()

# Find the size of the largest BST subtree
largest_bst_size = solution.largestBSTSubtree(root)
print(f"The size of the largest BST in the binary tree is: {largest_bst_size}")


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      



# endregion






# region 15.1 GRAPHS - LEARNING
# -----------------------------

# 1 TODO :  graphs and types
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/graph/introduction-to-graph/


https://bit.ly/3gpY19t


'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : graph implementation |c++
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://takeuforward.org/graph/graph-representation-in-c/


https://bit.ly/3dGuwyv



'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 3 TODO : graph implementation | java
'''

ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://bit.ly/3dGuwyv



'''

# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 4 TODO : connected components | logic explanation
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/graph/connected-components-in-graphs/


https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/



'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 5 TODO : BFS
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/graph/breadth-first-search-bfs-level-order-traversal/


https://practice.geeksforgeeks.org/problems/bfs-traversal-of-graph/1



'''
# method 1 : brute force approch
'''
Time Complexity: O(V + E), where:

V is the number of vertices (nodes) in the graph.
E is the number of edges.
In the worst case, we visit every vertex and edge exactly once during the BFS traversal.
Space Complexity: O(V) for storing the visited nodes and the queue. The visited dictionary requires O(V) space to store each node's visited status, and the queue may hold up to V nodes in the worst case.

''' 
from collections import deque

# BFS function implementation
def bfs(graph, start):
    visited = {node: False for node in graph}  # Mark all nodes as unvisited
    queue = deque([start])  # Initialize queue with the starting node
    visited[start] = True

    while queue:
        node = queue.popleft()  # Dequeue a node
        print(node, end=" ")  # Print or process the node

        # Visit all unvisited neighbors
        for neighbor in graph[node]:
            if not visited[neighbor]:
                visited[neighbor] = True
                queue.append(neighbor)

# Example usage:
graph = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0],
    3: [1],
    4: [1]
}

start_node = 0
print("BFS traversal starting from node", start_node)
bfs(graph, start_node)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 6 TODO : DFS
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´



https://takeuforward.org/data-structure/depth-first-search-dfs/


https://practice.geeksforgeeks.org/problems/depth-first-traversal-for-a-graph/1



'''
# method 1 : brute force approch
'''  
Time Complexity: O(V + E)
V is the number of vertices (nodes) and E is the number of edges. Each node is visited once, and each edge is explored once.
Space Complexity: O(V) for the visited array (to store the visited status of each node) and the recursion stack. In the worst case (deep recursion), the space complexity is O(V) due to the recursion stack depth.


''' 
# Recursive DFS Implementation
def dfs(graph, node, visited):
    # Mark the current node as visited
    visited[node] = True
    print(node, end=" ")  # Print or process the current node

    # Visit all unvisited neighbors
    for neighbor in graph[node]:
        if not visited[neighbor]:
            dfs(graph, neighbor, visited)

def dfs_graph(graph, start):
    visited = {node: False for node in graph}  # Initialize all nodes as unvisited
    dfs(graph, start, visited)

# Example usage:
graph = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0],
    3: [1],
    4: [1]
}

start_node = 0
print("DFS traversal starting from node", start_node)
dfs_graph(graph, start_node)


# method 2 : better approch
'''  
Time Complexity: O(V + E)
Similar to recursive DFS, each node and edge is processed once.
Space Complexity: O(V) for the visited array and the stack. In the worst case, the stack may store all the nodes in the graph (if the graph is connected and the traversal visits all nodes).



'''
# Iterative DFS Implementation using Stack
def dfs_iterative(graph, start):
    visited = {node: False for node in graph}  # Initialize all nodes as unvisited
    stack = [start]  # Initialize stack with the starting node

    while stack:
        node = stack.pop()  # Pop a node from the stack
        if not visited[node]:
            visited[node] = True
            print(node, end=" ")  # Print or process the current node

            # Add all unvisited neighbors to the stack
            for neighbor in graph[node]:
                if not visited[neighbor]:
                    stack.append(neighbor)

def dfs_graph(graph, start):
    dfs_iterative(graph, start)

# Example usage:
graph = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0],
    3: [1],
    4: [1]
}

start_node = 0
print("DFS traversal starting from node", start_node)
dfs_graph(graph, start_node)


# method 3 : optimal solution
# TC     -      
# SC     -      




# endregion






# region 15.2 GRAPHS - BFS/DFS
# ----------------------------
# 1 TODO :  number of provinces (leetcode)
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

- Given a n x n matrix isConnected where isConnected[i][j] = 1 means that the ith and jth cities are directly connected, and isConnected[i][j] = 0 means that they are not directly connected.

A province is a group of directly or indirectly connected cities. You need to find the total number of provinces.

https://takeuforward.org/data-structure/number-of-provinces/


https://leetcode.com/problems/number-of-provinces/#:~:text=A%20province%20is%20a%20group,the%20total%20number%20of%20provinces.



'''
# method 1 : brute force approch
''' 
Time Complexity: O(V + E), where V is the number of cities (vertices) and E is the number of connections (edges). Each city and each connection is explored at most once.
Space Complexity: O(V) for the visited list and recursion stack.


'''
# Depth-First Search to explore the graph
def dfs(isConnected, visited, node):
    visited[node] = True
    # Visit all the directly connected nodes (neighbors)
    for neighbor in range(len(isConnected)):
        if isConnected[node][neighbor] == 1 and not visited[neighbor]:
            dfs(isConnected, visited, neighbor)

def findCircleNum(isConnected):
    n = len(isConnected)
    visited = [False] * n
    provinces = 0
    
    # Loop through all nodes
    for i in range(n):
        if not visited[i]:
            # Start a DFS to mark all nodes in the same connected component
            dfs(isConnected, visited, i)
            provinces += 1
    
    return provinces

# Example usage:
isConnected = [
    [1, 1, 0],
    [1, 1, 0],
    [0, 0, 1]
]
print("Number of Provinces:", findCircleNum(isConnected))


# method 2 : better approch
''' 
Time Complexity: O(V + E), where V is the number of cities and E is the number of connections.
Space Complexity: O(V) for the visited list and the queue.


'''
from collections import deque

# Breadth-First Search to explore the graph
def bfs(isConnected, visited, node):
    queue = deque([node])
    visited[node] = True
    
    while queue:
        current = queue.popleft()
        for neighbor in range(len(isConnected)):
            if isConnected[current][neighbor] == 1 and not visited[neighbor]:
                visited[neighbor] = True
                queue.append(neighbor)

def findCircleNum(isConnected):
    n = len(isConnected)
    visited = [False] * n
    provinces = 0
    
    # Loop through all nodes
    for i in range(n):
        if not visited[i]:
            # Start a BFS to mark all nodes in the same connected component
            bfs(isConnected, visited, i)
            provinces += 1
    
    return provinces

# Example usage:
isConnected = [
    [1, 1, 0],
    [1, 1, 0],
    [0, 0, 1]
]
print("Number of Provinces:", findCircleNum(isConnected))


# method 3 : optimal solution
''' 
Time Complexity: O((V + E) * Î±(V)), where V is the number of cities, E is the number of connections, and Î±(V) is the inverse Ackermann function, which grows very slowly. In practice, this is nearly constant.
Space Complexity: O(V) for the parent and rank arrays.


'''
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))  # Initially each node is its own parent
        self.rank = [1] * n  # Initialize the rank of each node

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # Path compression
        return self.parent[x]

    def union(self, x, y):
        rootX = self.find(x)
        rootY = self.find(y)
        
        if rootX != rootY:
            # Union by rank
            if self.rank[rootX] > self.rank[rootY]:
                self.parent[rootY] = rootX
            elif self.rank[rootX] < self.rank[rootY]:
                self.parent[rootX] = rootY
            else:
                self.parent[rootY] = rootX
                self.rank[rootX] += 1

def findCircleNum(isConnected):
    n = len(isConnected)
    uf = UnionFind(n)
    
    for i in range(n):
        for j in range(i + 1, n):
            if isConnected[i][j] == 1:
                uf.union(i, j)
    
    # Count the number of unique parents, i.e., the number of provinces
    provinces = len(set(uf.find(i) for i in range(n)))
    
    return provinces

# Example usage:
isConnected = [
    [1, 1, 0],
    [1, 1, 0],
    [0, 0, 1]
]
print("Number of Provinces:", findCircleNum(isConnected))


# 2 TODO : connected components problem in matrix
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

- Given an m x n binary matrix, where 1 represents land and 0 represents water, the goal is to find the number of connected components (groups of 1s that are connected either horizontally or vertically). Each group represents a connected component of land.

https://bit.ly/3AxzhDG



'''
# method 1 : brute force approch
''' 
Time Complexity: O(m * n), where m is the number of rows and n is the number of columns. We visit each cell at most once.
Space Complexity: O(m * n) for the visited matrix and the recursion stack.

'''
# Depth-First Search (DFS) to explore the graph
def dfs(matrix, visited, i, j, m, n):
    # Directions: Up, Down, Left, Right
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    visited[i][j] = True  # Mark current cell as visited
    
    for dir_x, dir_y in directions:
        new_x, new_y = i + dir_x, j + dir_y
        
        # Check if the new cell is within bounds and is land (1) and not visited
        if 0 <= new_x < m and 0 <= new_y < n and not visited[new_x][new_y] and matrix[new_x][new_y] == 1:
            dfs(matrix, visited, new_x, new_y, m, n)

def numOfConnectedComponents(matrix):
    if not matrix:
        return 0
    
    m, n = len(matrix), len(matrix[0])
    visited = [[False] * n for _ in range(m)]
    components = 0
    
    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 1 and not visited[i][j]:
                # Start a DFS for a new connected component
                dfs(matrix, visited, i, j, m, n)
                components += 1  # Increment component count
    
    return components

# Example usage
matrix = [
    [1, 1, 0, 0, 0],
    [1, 1, 0, 1, 0],
    [0, 0, 0, 1, 1],
    [0, 0, 1, 0, 0],
]
print("Number of connected components:", numOfConnectedComponents(matrix))


# method 2 : better approch
''' 
Time Complexity: O(m * n), where m is the number of rows and n is the number of columns. We visit each cell at most once.
Space Complexity: O(m * n) for the visited matrix and the queue.


'''
from collections import deque

# Breadth-First Search (BFS) to explore the graph
def bfs(matrix, visited, i, j, m, n):
    queue = deque([(i, j)])
    visited[i][j] = True  # Mark current cell as visited
    
    # Directions: Up, Down, Left, Right
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    while queue:
        x, y = queue.popleft()
        for dir_x, dir_y in directions:
            new_x, new_y = x + dir_x, y + dir_y
            
            # Check if the new cell is within bounds and is land (1) and not visited
            if 0 <= new_x < m and 0 <= new_y < n and not visited[new_x][new_y] and matrix[new_x][new_y] == 1:
                visited[new_x][new_y] = True
                queue.append((new_x, new_y))

def numOfConnectedComponents(matrix):
    if not matrix:
        return 0
    
    m, n = len(matrix), len(matrix[0])
    visited = [[False] * n for _ in range(m)]
    components = 0
    
    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 1 and not visited[i][j]:
                # Start a BFS for a new connected component
                bfs(matrix, visited, i, j, m, n)
                components += 1  # Increment component count
    
    return components

# Example usage
matrix = [
    [1, 1, 0, 0, 0],
    [1, 1, 0, 1, 0],
    [0, 0, 0, 1, 1],
    [0, 0, 1, 0, 0],
]
print("Number of connected components:", numOfConnectedComponents(matrix))


# method 3 : optimal solution
''' 
Time Complexity: O((m * n) * Î±(m * n)), where m is the number of rows and n is the number of columns, and Î± is the inverse Ackermann function. This is nearly constant for practical inputs.
Space Complexity: O(m * n) for the Union-Find data structure (parent and rank arrays).

''' 
class UnionFind:
    def __init__(self, m, n):
        self.parent = {}
        self.rank = {}
        for i in range(m):
            for j in range(n):
                self.parent[(i, j)] = (i, j)  # Initially, each cell is its own parent
                self.rank[(i, j)] = 0  # Initially, rank is 0

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # Path compression
        return self.parent[x]

    def union(self, x, y):
        rootX = self.find(x)
        rootY = self.find(y)
        
        if rootX != rootY:
            # Union by rank
            if self.rank[rootX] > self.rank[rootY]:
                self.parent[rootY] = rootX
            elif self.rank[rootX] < self.rank[rootY]:
                self.parent[rootX] = rootY
            else:
                self.parent[rootY] = rootX
                self.rank[rootX] += 1

def numOfConnectedComponents(matrix):
    if not matrix:
        return 0
    
    m, n = len(matrix), len(matrix[0])
    uf = UnionFind(m, n)
    
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 1:
                for dir_x, dir_y in directions:
                    new_x, new_y = i + dir_x, j + dir_y
                    if 0 <= new_x < m and 0 <= new_y < n and matrix[new_x][new_y] == 1:
                        uf.union((i, j), (new_x, new_y))
    
    # Count the number of unique roots, which represents the number of components
    roots = set()
    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 1:
                roots.add(uf.find((i, j)))
    
    return len(roots)

# Example usage
matrix = [
    [1, 1, 0, 0, 0],
    [1, 1, 0, 1, 0],
    [0, 0, 0, 1, 1],
    [0, 0, 1, 0, 0],
]
print("Number of connected components:", numOfConnectedComponents(matrix))


# 3 TODO : return oranges
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

The "Rotting Oranges" problem is a common graph traversal problem where you are given a grid of oranges. Each orange can either be fresh (1), rotten (2), or empty (0). The goal is to determine how many minutes it will take for all the fresh oranges to rot, or if it is impossible to rot all of them.

Problem Summary:
We are given a 2D grid where:
1 represents a fresh orange.
2 represents a rotten orange.
0 represents an empty cell.
In each minute, any fresh orange that is adjacent (horizontally or vertically) to a rotten orange will rot.
The task is to return the minimum number of minutes required for all the fresh oranges to rot. If it's impossible, return -1.

https://takeuforward.org/data-structure/rotten-oranges-min-time-to-rot-all-oranges-bfs/


https://leetcode.com/problems/rotting-oranges/



'''

# method 1 : brute force approch
''' 
1. Time Complexity:
O(m * n), where m is the number of rows and n is the number of columns in the grid.
We visit each cell at most once, either to check if it is rotten or to rot it.
2. Space Complexity:
O(m * n), for the queue used in the BFS and the space required to store the grid.
The queue can hold up to all the cells in the grid, in the worst case when all cells are rotten or we are processing a large number of rotten oranges at once.

'''
from collections import deque

def orangesRotting(grid):
    rows, cols = len(grid), len(grid[0])
    queue = deque()
    fresh_count = 0
    
    # Step 1: Initialize the queue with all rotten oranges and count fresh oranges
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 2:
                queue.append((r, c))  # Add rotten orange coordinates to the queue
            elif grid[r][c] == 1:
                fresh_count += 1  # Count fresh oranges
    
    # If there are no fresh oranges, return 0
    if fresh_count == 0:
        return 0
    
    # Step 2: Perform BFS
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Directions for up, down, left, right
    minutes = 0
    
    # BFS process: each iteration is 1 minute
    while queue:
        size = len(queue)
        for _ in range(size):
            r, c = queue.popleft()
            # Check all 4 directions
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                # If the new cell is within bounds and contains a fresh orange
                if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1:
                    grid[nr][nc] = 2  # Rot this fresh orange
                    queue.append((nr, nc))  # Add it to the queue for future processing
                    fresh_count -= 1  # Decrease the count of fresh oranges
        
        # If we rotted any oranges in this minute, increment the time
        if queue:
            minutes += 1
    
    # Step 3: If there are still fresh oranges, return -1
    return minutes if fresh_count == 0 else -1

# Example usage
grid = [
    [2,1,1],
    [1,1,0],
    [0,1,1]
]

print("Minutes until all oranges rot:", orangesRotting(grid))


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 4 TODO : flood fill
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

- The Flood Fill problem is similar to a graph traversal problem, where we are asked to replace a color in a 2D grid, starting from a specific cell and replacing all adjacent cells with the same color with the new color.

https://takeuforward.org/graph/flood-fill-algorithm-graphs/


https://leetcode.com/problems/flood-fill/



'''
# method 1 : brute force approch
''' 
 Each cell in the grid can be visited once, and for each cell, we make a constant amount of work (changing its color and checking neighbors). Hence, the time complexity is O(m * n), where m is the number of rows and n is the number of columns.



SC -  In the worst case, when the grid is fully connected, the recursion stack can grow up to O(m * n) in the worst case (if the entire grid is part of the flood fill). Hence, the space complexity is O(m * n) due to recursion.

'''
def floodFill(image, sr, sc, newColor):
    # If the new color is the same as the current color, no need to do anything
    if image[sr][sc] == newColor:
        return image
    
    # Store the original color at the starting cell
    originalColor = image[sr][sc]
    
    def dfs(r, c):
        # Base case: If the cell is out of bounds or not the original color, return
        if r < 0 or r >= len(image) or c < 0 or c >= len(image[0]) or image[r][c] != originalColor:
            return
        
        # Change the color of the current cell
        image[r][c] = newColor
        
        # Explore the four neighboring cells (up, down, left, right)
        dfs(r + 1, c)
        dfs(r - 1, c)
        dfs(r, c + 1)
        dfs(r, c - 1)
    
    # Start DFS from the given position
    dfs(sr, sc)
    
    return image

# Example usage:
image = [
    [1,1,1],
    [1,1,0],
    [1,0,1]
]
sr, sc = 1, 1
newColor = 2
print(floodFill(image, sr, sc, newColor))


# method 2 : better approch
''' 
TC - BFS: Similarly, each cell is processed once, and we perform constant work for each cell (coloring and adding neighbors to the queue). Hence, the time complexity is also O(m * n).

SC - BFS: The space complexity is also O(m * n) since the queue stores at most O(m * n) cells in the worst case (for example, if the entire grid is filled with the same color).
'''
from collections import deque

def floodFill(image, sr, sc, newColor):
    # If the new color is the same as the current color, no need to do anything
    if image[sr][sc] == newColor:
        return image
    
    # Store the original color at the starting cell
    originalColor = image[sr][sc]
    
    # Initialize the queue for BFS
    queue = deque([(sr, sc)])
    
    # Start BFS
    while queue:
        r, c = queue.popleft()
        
        # If the current cell is the original color, change it
        if image[r][c] == originalColor:
            image[r][c] = newColor
            
            # Add the four neighboring cells (up, down, left, right) to the queue
            if r + 1 < len(image) and image[r + 1][c] == originalColor:
                queue.append((r + 1, c))
            if r - 1 >= 0 and image[r - 1][c] == originalColor:
                queue.append((r - 1, c))
            if c + 1 < len(image[0]) and image[r][c + 1] == originalColor:
                queue.append((r, c + 1))
            if c - 1 >= 0 and image[r][c - 1] == originalColor:
                queue.append((r, c - 1))
    
    return image

# Example usage:
image = [
    [1,1,1],
    [1,1,0],
    [1,0,1]
]
sr, sc = 1, 1
newColor = 2
print(floodFill(image, sr, sc, newColor))


# method 3 : optimal solution
# TC     -      
# SC     -      


# 5 TODO : cycle detection in undirected graph (BFS)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/detect-cycle-in-an-undirected-graph-using-bfs/


https://practice.geeksforgeeks.org/problems/detect-cycle-in-an-undirected-graph/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=detect-cycle-in-an-undirected-graph



'''
# method 1 : brute force approch
''' 
Time Complexity:
O(V + E), where V is the number of vertices and E is the number of edges in the graph.
We visit each node and each edge once during the BFS traversal.
Space Complexity:
O(V + E), where V is the number of vertices and E is the number of edges.
We store the graph as an adjacency list, and we also store the visited[], parent[], and queue which requires extra space proportional to the number of vertices and edges.


'''
from collections import deque

def isCyclic(graph, V):
    # Create a visited list to keep track of visited nodes
    visited = [False] * V
    
    # Function to check cycle using BFS
    def bfs(start):
        # Create a queue for BFS and add the starting node to it
        queue = deque([start])
        visited[start] = True
        
        # Initialize the parent of the starting node as -1 (no parent)
        parent = [-1] * V
        parent[start] = -1
        
        # Start BFS traversal
        while queue:
            node = queue.popleft()
            
            # Traverse all neighbors of the current node
            for neighbor in graph[node]:
                if not visited[neighbor]:
                    # Mark the neighbor as visited and assign the current node as its parent
                    visited[neighbor] = True
                    parent[neighbor] = node
                    queue.append(neighbor)
                elif parent[node] != neighbor:
                    # If the neighbor is visited and it's not the parent of the current node, a cycle is detected
                    return True
        return False

    # Perform BFS for every unvisited node
    for i in range(V):
        if not visited[i]:
            if bfs(i):
                return True
    
    return False

# Example usage:
# Graph represented as an adjacency list
graph = {
    0: [1, 2],
    1: [0, 2],
    2: [0, 1],
    3: [4],
    4: [3]
}

V = 5  # Number of vertices in the graph

print(isCyclic(graph, V))  # Output: True, as the graph contains a cycle (0-1-2-0)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 6 TODO : cycle detectio in undirected graph (DFS)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/detect-cycle-in-an-undirected-graph-using-dfs/


https://practice.geeksforgeeks.org/problems/detect-cycle-in-an-undirected-graph/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=detect-cycle-in-an-undirected-graph



'''
# method 1 : brute force approch
''' 
Time Complexity:
O(V + E), where V is the number of vertices and E is the number of edges.
In the worst case, we will visit each vertex and each edge once during the DFS traversal.
Space Complexity:
O(V), where V is the number of vertices.
We store the visited[] array of size V to track whether a node has been visited.
Additionally, the recursion stack will take up space proportional to the depth of the graph, which in the worst case could be O(V) if the graph is highly skewed (e.g., a long chain).
'''
def isCyclic(graph, V):
    # Create a visited list to keep track of visited nodes
    visited = [False] * V
    
    # Helper function for DFS
    def dfs(node, parent):
        # Mark the current node as visited
        visited[node] = True
        
        # Explore all the neighbors of the current node
        for neighbor in graph[node]:
            # If the neighbor is not visited, recurse DFS on the neighbor
            if not visited[neighbor]:
                if dfs(neighbor, node):  # Recurse with the current node as parent
                    return True
            # If the neighbor is visited and is not the parent of the current node, a cycle is detected
            elif neighbor != parent:
                return True
        
        return False
    
    # Perform DFS for each unvisited node
    for i in range(V):
        if not visited[i]:
            if dfs(i, -1):  # Start DFS for each component
                return True
    
    return False

# Example usage:
# Graph represented as an adjacency list
graph = {
    0: [1, 2],
    1: [0, 2],
    2: [0, 1],
    3: [4],
    4: [3]
}

V = 5  # Number of vertices in the graph

print(isCyclic(graph, V))  # Output: True, as the graph contains a cycle (0-1-2-0)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 7 TODO : 0/1 matrix (BFS problem)
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/graph/distance-of-nearest-cell-having-1/


https://leetcode.com/problems/01-matrix/



'''

# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 8 TODO : surrounded regions (DFS)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

- The 0/1 Matrix problem refers to finding the shortest path in a grid (matrix) where each cell is either 0 or 1.

0 represents a free cell, and 1 represents a blocked cell.
The task is to find the shortest distance from a source cell to a target cell in this grid. You can only move in 4 directions (up, down, left, and right).

https://takeuforward.org/graph/surrounded-regions-replace-os-with-xs/


https://leetcode.com/problems/surrounded-regions/



'''
# method 1 : brute force approch
''' 
Time Complexity:
O(n^2), where n is the size of the grid. In the worst case, we may need to visit each cell once, and for each cell, we explore its neighbors, which takes constant time.
Space Complexity:
O(n^2) due to the space required for the grid (which is modified in place) and the queue that stores the BFS nodes. In the worst case, the queue can hold up to all the grid cells.

'''
from collections import deque

def shortestPathBinaryMatrix(grid):
    # Edge case: if the starting point is blocked, return -1 immediately
    if grid[0][0] == 1 or grid[-1][-1] == 1:
        return -1
    
    n = len(grid)
    # Directions to move in the grid (left, right, up, down)
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]
    
    # Queue for BFS
    queue = deque([(0, 0, 1)])  # (x, y, distance)
    
    # Mark the starting point as visited
    grid[0][0] = 1
    
    while queue:
        x, y, dist = queue.popleft()
        
        # If we reach the bottom-right corner, return the distance
        if x == n - 1 and y == n - 1:
            return dist
        
        # Explore all possible directions
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            
            # Check if the new position is valid and unvisited (i.e., grid[nx][ny] == 0)
            if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0:
                grid[nx][ny] = 1  # Mark as visited
                queue.append((nx, ny, dist + 1))
    
    return -1  # Return -1 if there is no valid path

# Example usage:
grid = [
    [0, 1, 0],
    [1, 0, 1],
    [0, 1, 0]
]
print(shortestPathBinaryMatrix(grid))  # Output: 4


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 9 TODO : number of enclaves (flood fill implementation - multisource)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/graph/number-of-enclaves/


https://leetcode.com/problems/number-of-enclaves/

The number of enclaves problem is often associated with a flood fill (multi-source BFS/DFS) technique in a graph. Given a grid of 1s and 0s:

1 represents land.
0 represents water.
An enclave is a group of land cells (1s) that are completely surrounded by water cells (0s) and do not touch any boundary (edges) of the grid.

The goal is to count the number of such enclaves (groups of land cells that are completely surrounded by water).

'''
# method 1 : brute force approch
''' 
Time Complexity:
O(n * m), where n is the number of rows and m is the number of columns in the grid.
The BFS/DFS traversal of each boundary-connected land cell takes O(n * m) time, since in the worst case, we may visit each cell of the grid once.
Space Complexity:
O(n * m) for the grid storage and the auxiliary space used by the BFS queue (which stores at most O(n * m) nodes in the worst case).

'''
from collections import deque

# Directions for 4 possible movements: up, down, left, right
directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

def numEnclaves(grid):
    if not grid:
        return 0
    
    n, m = len(grid), len(grid[0])
    
    # Helper function for BFS to mark all connected land cells
    def bfs(x, y):
        queue = deque([(x, y)])
        grid[x][y] = 0  # Mark the cell as visited (water now)
        
        while queue:
            cx, cy = queue.popleft()
            
            for dx, dy in directions:
                nx, ny = cx + dx, cy + dy
                if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 1:
                    grid[nx][ny] = 0  # Mark visited
                    queue.append((nx, ny))
    
    # First, mark all land cells connected to the boundary (edges)
    
    # Traverse the first and last rows
    for i in range(m):
        if grid[0][i] == 1:
            bfs(0, i)
        if grid[n-1][i] == 1:
            bfs(n-1, i)
    
    # Traverse the first and last columns
    for i in range(n):
        if grid[i][0] == 1:
            bfs(i, 0)
        if grid[i][m-1] == 1:
            bfs(i, m-1)
    
    # Now, count remaining land cells (enclaves)
    enclave_count = 0
    for i in range(n):
        for j in range(m):
            if grid[i][j] == 1:  # Unvisited land cell
                enclave_count += 1
    
    return enclave_count

# Example usage:
grid = [
    [0, 1, 0, 0],
    [1, 1, 0, 1],
    [0, 0, 1, 0],
    [1, 1, 1, 0]
]

print(numEnclaves(grid))  # Output: 3


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 10 TODO :  word index - 1
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/graph/word-ladder-i-g-29/


https://leetcode.com/problems/word-ladder/



'''
# method 1 : brute force approch
''' 
Time Complexity:
Building the Trie: Inserting all words into the Trie takes O(W * L) time, where W is the number of words and L is the average length of the words.
DFS Traversal: For each cell in the grid, DFS could explore all 4 directions. In the worst case, DFS explores every cell, leading to a complexity of O(n * m) where n is the number of rows and m is the number of columns in the grid.
Overall Time Complexity: O(W * L + n * m) where W is the number of words, L is the length of the average word, n is the number of rows, and m is the number of columns in the grid.
Space Complexity:
Trie Space: The space complexity for the Trie is O(W * L) where W is the number of words and L is the length of the longest word.
DFS Stack and Visited Set: The space complexity for the DFS recursion stack and visited cells is O(n * m).
Overall Space Complexity: O(W * L + n * m).


'''
# Define Trie Node class
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

# Trie class to insert and search for words
class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True
    
    def search_prefix(self, prefix):
        node = self.root
        for char in prefix:
            if char not in node.children:
                return None
            node = node.children[char]
        return node


def findWordIndex(board, words):
    # Helper function to perform DFS and search for words
    def dfs(board, node, i, j, path, visited):
        # If we reach a valid word, add it to results
        if node.is_end_of_word:
            word = ''.join(path)
            if word in word_index_map:
                word_index_map[word] = len(word_index_map)  # Record the index of the word
            node.is_end_of_word = False  # Avoid revisiting the word
        
        # Boundaries check and if already visited
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or (i, j) in visited:
            return
        
        visited.add((i, j))
        path.append(board[i][j])
        
        # Explore in all 4 directions (up, down, left, right)
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nx, ny = i + dx, j + dy
            if (board[nx][ny] in node.children if 0 <= nx < len(board) and 0 <= ny < len(board[0]) else False):
                dfs(board, node.children[board[nx][ny]], nx, ny, path, visited)

        visited.remove((i, j))
        path.pop()  # Backtrack

    trie = Trie()
    for word in words:
        trie.insert(word)
    
    word_index_map = {}  # To store the index of words found in the grid
    
    for i in range(len(board)):
        for j in range(len(board[0])):
            node = trie.search_prefix(board[i][j])
            if node:
                visited = set()
                dfs(board, node, i, j, [], visited)

    # Return the last found word index
    return max(word_index_map.values(), default=-1)

# Example usage:
board = [
    ['o', 'a', 'a', 'n'],
    ['e', 't', 'a', 'e'],
    ['i', 'h', 'k', 'r'],
    ['i', 'f', 'l', 'v']
]

words = ["oath", "pea", "eat", "rain"]
print(findWordIndex(board, words))  # Output: 2 (index of "eat" in words list)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 11 TODO : word index - 2
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/graph/g-30-word-ladder-ii/


https://leetcode.com/problems/word-ladder-ii/



'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
''' 
Time Complexity:
Inserting Words into Trie: Inserting each word takes O(L) time where L is the average length of the words. The total time complexity for this step is O(W * L), where W is the number of words.
DFS Search: For each cell in the grid, we perform DFS. In the worst case, this could explore every direction from every cell. The time complexity for DFS is O(n * m) where n is the number of rows and m is the number of columns in the grid.
Overall Time Complexity: O(W * L + n * m), where W is the number of words, L is the length of the average word, and n and m are the dimensions of the grid.
Space Complexity:
Trie Space: The space complexity for the Trie is O(W * L), where W is the number of words and L is the average length of the words.
DFS Stack and Visited Set: The space complexity for the DFS recursion stack and the visited set is O(n * m), where n and m are the dimensions of the grid.
Overall Space Complexity: O(W * L + n * m).


'''
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True

    def search_prefix(self, prefix):
        node = self.root
        for char in prefix:
            if char not in node.children:
                return None
            node = node.children[char]
        return node

def find_word_index_2(board, words):
    def dfs(board, node, i, j, path, visited):
        if node.is_end_of_word:
            word = ''.join(path)
            if word not in word_index_map:
                word_index_map[word] = len(word_index_map)  # Record the index
            node.is_end_of_word = False
        
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or (i, j) in visited:
            return
        
        visited.add((i, j))
        path.append(board[i][j])

        # Explore all four directions (up, down, left, right)
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nx, ny = i + dx, j + dy
            if 0 <= nx < len(board) and 0 <= ny < len(board[0]) and board[nx][ny] in node.children:
                dfs(board, node.children[board[nx][ny]], nx, ny, path, visited)
        
        visited.remove((i, j))
        path.pop()

    trie = Trie()
    for word in words:
        trie.insert(word)

    word_index_map = {}

    for i in range(len(board)):
        for j in range(len(board[0])):
            node = trie.search_prefix(board[i][j])
            if node:
                visited = set()
                dfs(board, node, i, j, [], visited)

    # Return the last word index
    return max(word_index_map.values(), default=-1)

# Example usage:
board = [
    ['o', 'a', 'a', 'n'],
    ['e', 't', 'a', 'e'],
    ['i', 'h', 'k', 'r'],
    ['i', 'f', 'l', 'v']
]

words = ["oath", "pea", "eat", "rain"]
print(find_word_index_2(board, words))  # Output: 2 (index of "eat" in words list)


# 12 TODO : number of distinct islands (DFS multi source)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/data-structure/number-of-islands/


https://leetcode.com/problems/number-of-distinct-islands-ii/



'''
# method 1 : brute force approch
''' 
Time Complexity:
DFS Exploration: Each cell is visited at most once during the DFS, so the time complexity for the DFS is O(n * m), where n is the number of rows and m is the number of columns in the grid.
Shape Comparison and Storage: Storing the shape of an island involves sorting the list of coordinates, which takes O(k log k) where k is the number of cells in the island. In the worst case, each island can have O(n * m) cells, but typically the islands are smaller. The time complexity for storing all distinct islands is O(k log k) for each island and O(D) for D distinct islands.
Overall Time Complexity: The total time complexity is approximately O(n * m + D * k log k), where D is the number of distinct islands and k is the size of the largest island.

Space Complexity:
Visited Set: The space complexity for the visited set is O(n * m) because we need to store information for all cells in the grid.
Shape Storage: The space for storing the shapes of islands is also O(n * m) in the worst case, since each island could potentially contain every cell.
Overall Space Complexity: O(n * m).

'''
def numDistinctIslands(grid):
    def dfs(i, j, origin, visited, shape):
        # Check bounds and if the cell is land and not visited
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0 or (i, j) in visited:
            return
        
        visited.add((i, j))
        # Store relative position of the current cell to the island's origin
        shape.append((i - origin[0], j - origin[1]))  # Relative coordinate to the origin
        
        # Explore all 4 directions (up, down, left, right)
        dfs(i - 1, j, origin, visited, shape)  # Up
        dfs(i + 1, j, origin, visited, shape)  # Down
        dfs(i, j - 1, origin, visited, shape)  # Left
        dfs(i, j + 1, origin, visited, shape)  # Right
    
    visited = set()  # To keep track of visited cells
    distinct_islands = set()  # To store unique island shapes
    
    # Traverse through the grid
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1 and (i, j) not in visited:
                # Start a new DFS for a new island
                shape = []
                dfs(i, j, (i, j), visited, shape)  # Perform DFS to get the island's shape
                # Convert the shape to a tuple (hashable) and add it to distinct islands set
                distinct_islands.add(tuple(sorted(shape)))
    
    return len(distinct_islands)

# Example Usage
grid = [
    [1, 1, 0, 0, 0],
    [1, 1, 0, 0, 0],
    [0, 0, 1, 1, 0],
    [0, 0, 0, 1, 1]
]
print(numDistinctIslands(grid))  # Output: 2


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 13 TODO : bipartite Graphs (DFS)
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡

A Bipartite Graph is a graph whose vertices can be divided into two disjoint sets such that every edge connects a vertex from the first set to a vertex in the second set. In other words, no two vertices within the same set are adjacent. We can determine if a graph is bipartite by trying to color the graph using two colors (or sets). If we can color the graph using two colors without any conflicts, the graph is bipartite.

In this problem, we are asked to determine if a given graph is bipartite using a DFS approach.

https://takeuforward.org/graph/bipartite-graph-dfs-implementation/


https://leetcode.com/problems/is-graph-bipartite/



'''
# method 1 : brute force approch
''' 
Time Complexity:
DFS Traversal: The time complexity of DFS is O(V + E), where V is the number of vertices (nodes) and E is the number of edges. Each node is visited once, and each edge is explored once.
Overall Time Complexity: Since we are performing DFS once for each unvisited node, the time complexity of this approach is O(V + E).

Space Complexity:
Space for Color Array: We use an array of size V (the number of vertices) to store the colors of the nodes, which takes O(V) space.
Space for the Recursion Stack: In the worst case, the depth of the recursion stack is O(V) (if the graph is a single chain), which adds to the space complexity.
Overall Space Complexity: The overall space complexity is O(V) due to the color array and recursion stack.

'''
def isBipartite(graph):
    # Initialize an array to store colors of nodes. 0 means uncolored, 1 and -1 are the two colors.
    n = len(graph)
    color = [0] * n
    
    def dfs(node, c):
        # Assign the current color to the node
        color[node] = c
        
        # Traverse all the neighbors of the node
        for neighbor in graph[node]:
            # If the neighbor has the same color, it's not bipartite
            if color[neighbor] == c:
                return False
            # If the neighbor is uncolored, color it with the opposite color
            if color[neighbor] == 0 and not dfs(neighbor, -c):
                return False
        return True
    
    # Check each node (in case the graph is not connected)
    for i in range(n):
        if color[i] == 0:  # If uncolored, start a DFS
            if not dfs(i, 1):  # Start coloring with color 1
                return False
    
    return True

# Example Usage:
graph = [
    [1, 3],
    [0, 2],
    [1, 3],
    [0, 2]
]

print(isBipartite(graph))  # Output: True


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 14 TODO : cucle detection in directed graph (DFS)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/detect-cycle-in-a-directed-graph-using-dfs-g-19/


https://leetcode.com/problems/course-schedule-ii/discuss/293048/detecting-cycle-in-directed-graph-problem



'''
# method 1 : brute force approch
''' 
Time Complexity:
DFS Traversal: The time complexity of a DFS traversal is O(V + E), where V is the number of vertices and E is the number of edges in the graph. Each node and edge is explored at most once.
Overall Time Complexity: Since DFS is invoked once per unvisited node, the overall time complexity remains O(V + E).

Space Complexity:
State Array: We maintain an array state of size V to track the state of each node, which requires O(V) space.
Recursion Stack: In the worst case, the recursion stack depth could be as large as the number of vertices in the graph, which adds an additional O(V) space.
Overall Space Complexity: The overall space complexity is O(V) due to the state array and recursion stack.

'''
def hasCycle(graph):
    # State array: 0 -> unvisited, 1 -> visiting, 2 -> visited
    state = [0] * len(graph)
    
    def dfs(node):
        if state[node] == 1:  # Cycle detected
            return True
        if state[node] == 2:  # Already fully explored
            return False
        
        # Mark the node as "visiting" (currently in the recursion stack)
        state[node] = 1
        
        # Visit all the neighbors of the node
        for neighbor in graph[node]:
            if dfs(neighbor):
                return True
        
        # Mark the node as "visited" (all neighbors processed)
        state[node] = 2
        return False
    
    # Iterate through all nodes in the graph
    for i in range(len(graph)):
        if state[i] == 0:  # Unvisited node
            if dfs(i):  # Start DFS from this node
                return True
    
    return False

# Example Usage:
# Directed graph represented as an adjacency list
# Graph: 0 -> 1, 1 -> 2, 2 -> 0 (cycle present)
graph1 = [
    [1],   # Node 0 points to Node 1
    [2],   # Node 1 points to Node 2
    [0]    # Node 2 points to Node 0 (cycle)
]
print(hasCycle(graph1))  # Output: True (cycle detected)

# Graph: 0 -> 1, 1 -> 2, 2 -> 3 (no cycle)
graph2 = [
    [1],  # Node 0 points to Node 1
    [2],  # Node 1 points to Node 2
    [3],  # Node 2 points to Node 3
    []    # Node 3 has no outgoing edges
]
print(hasCycle(graph2))  # Output: False (no cycle)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      




# endregion





# region 15.3 GRAPHS - TOPO SORT
# ------------------------------

# 1 TODO :  topo sort
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/topological-sort-algorithm-dfs-g-21/


https://practice.geeksforgeeks.org/problems/topological-sort/1

Topological sorting (or topological order) of a directed acyclic graph (DAG) is a linear ordering of its vertices such that for every directed edge 
ğ‘¢
ğ‘£
uv from vertex 
ğ‘¢
u to vertex 
ğ‘£
v, vertex 
ğ‘¢
u comes before 
ğ‘£
v in the ordering. Topological sorting is possible only if the graph has no cycles.

'''
# method 1 : brute force approch
''' 
Time Complexity: 
ğ‘‚
(
ğ‘‰
+
ğ¸
)
O(V+E), where 
ğ‘‰
V is the number of vertices and 
ğ¸
E is the number of edges. Every vertex and edge is visited at most once.
Space Complexity: 
ğ‘‚
(
ğ‘‰
+
ğ¸
)
O(V+E) due to the graph representation and recursion stack.

'''  
from collections import defaultdict

# DFS-based topological sort
def topoSortDFS(graph, V):
    visited = [False] * V
    result = []

    def dfs(v):
        visited[v] = True
        for neighbor in graph[v]:
            if not visited[neighbor]:
                dfs(neighbor)
        result.append(v)

    # Call DFS for each unvisited node
    for i in range(V):
        if not visited[i]:
            dfs(i)

    # Return reversed result as DFS finishes from leaf to root
    return result[::-1]

# Example Usage:
graph1 = defaultdict(list)
graph1[0] = [1, 2]
graph1[1] = [3]
graph1[2] = [3]

V = 4  # Number of vertices in the graph
print(topoSortDFS(graph1, V))  # Output: [0, 2, 1, 3]


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : kahn's algorithm
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/kahns-algorithm-topological-sort-algorithm-bfs-g-22/


https://bit.ly/3c690mm

Use Kahnâ€™s Algorithm (BFS-based), which uses an in-degree array to track the number of incoming edges for each vertex. We start with nodes that have zero in-degree (no dependencies) and iteratively reduce the in-degree of their neighbors.

'''
# method 1 : brute force approch
''' 
Time Complexity: 
ğ‘‚
(
ğ‘‰
+
ğ¸
)
O(V+E), where 
ğ‘‰
V is the number of vertices and 
ğ¸
E is the number of edges. We process each vertex and edge once.
Space Complexity: 
ğ‘‚
(
ğ‘‰
+
ğ¸
)
O(V+E) due to the graph representation, the in-degree array, and the queue.

'''
from collections import deque, defaultdict

# Kahn's Algorithm (BFS-based Topological Sort)
def topoSortKahn(graph, V):
    in_degree = [0] * V
    # Calculate in-degree (number of incoming edges) for each vertex
    for u in range(V):
        for v in graph[u]:
            in_degree[v] += 1

    # Initialize queue with all nodes having in-degree 0
    queue = deque([i for i in range(V) if in_degree[i] == 0])
    result = []

    while queue:
        node = queue.popleft()
        result.append(node)

        # Decrease in-degree of neighbors
        for neighbor in graph[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)

    # If the result contains all vertices, return the result
    if len(result) == V:
        return result
    else:
        return []  # Cycle detected, no topological sort possible

# Example Usage:
graph2 = defaultdict(list)
graph2[0] = [1, 2]
graph2[1] = [3]
graph2[2] = [3]

V = 4  # Number of vertices in the graph
print(topoSortKahn(graph2, V))  # Output: [0, 2, 1, 3]


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 3 TODO : cycle detection in directed graph (BFS)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://practice.geeksforgeeks.org/problems/detect-cycle-in-a-directed-graph/1



'''
# method 1 : brute force approch
''' 
Time Complexity:
In-degree Calculation: 
ğ‘‚
(
ğ‘‰
+
ğ¸
)
O(V+E), where 
ğ‘‰
V is the number of vertices and 
ğ¸
E is the number of edges. We visit each vertex and each edge exactly once.
Queue Processing: Each vertex and edge is processed once, so this step also takes 
ğ‘‚
(
ğ‘‰
+
ğ¸
)
O(V+E).
Total Time Complexity: 
ğ‘‚
(
ğ‘‰
+
ğ¸
)
O(V+E).
Space Complexity:
The graph is represented as an adjacency list, which takes 
ğ‘‚
(
ğ‘‰
+
ğ¸
)
O(V+E) space.
The in-degree array takes 
ğ‘‚
(
ğ‘‰
)
O(V) space.
The queue takes 
ğ‘‚
(
ğ‘‰
)
O(V) space.
Total Space Complexity: 
ğ‘‚
(
ğ‘‰
+
ğ¸
)
O(V+E).

'''
from collections import deque, defaultdict

# Function to detect cycle in a directed graph using BFS (Kahn's Algorithm)
def cycleDetectionBFS(graph, V):
    # Initialize in-degree array with 0
    in_degree = [0] * V
    
    # Step 1: Compute in-degree for each vertex
    for u in range(V):
        for v in graph[u]:
            in_degree[v] += 1
    
    # Step 2: Initialize queue with vertices having in-degree 0
    queue = deque([i for i in range(V) if in_degree[i] == 0])
    count = 0  # To count the number of nodes processed
    
    # Step 3: Process the vertices from the queue
    while queue:
        node = queue.popleft()
        count += 1
        
        # For each neighbor of the current node, reduce its in-degree by 1
        for neighbor in graph[node]:
            in_degree[neighbor] -= 1
            # If in-degree becomes 0, add it to the queue
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    # Step 4: If count is not equal to number of vertices, a cycle exists
    if count == V:
        return False  # No cycle
    else:
        return True  # Cycle detected

# Example usage:
# Directed graph represented as an adjacency list
graph = defaultdict(list)
graph[0] = [1]
graph[1] = [2]
graph[2] = [0]

V = 3  # Number of vertices in the graph

print(cycleDetectionBFS(graph, V))  # Output: True (Cycle exists)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 4 TODO : course schedule - I
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/data-structure/course-schedule-i-and-ii-pre-requisite-tasks-topological-sort-g-24/


https://leetcode.com/problems/course-schedule/

You are given the total number of courses numCourses and a list of prerequisite pairs prerequisites. Each pair [a, b] indicates that for course a to be taken, course b must be completed first. Your task is to determine if it is possible to finish all courses.


'''
# method 1 : brute force approch
''' 
Time Complexity:
Graph Construction: Constructing the graph and filling the in-degree array takes O(V + E) time, where V is the number of vertices (courses) and E is the number of edges (prerequisites).
Queue Processing: We process each course once and each edge once, so this step also takes O(V + E) time.
Total Time Complexity: O(V + E), where V is the number of courses and E is the number of prerequisites.

Space Complexity:
Graph Representation: The graph is represented as an adjacency list, which takes O(V + E) space.
In-degree Array: The in-degree array takes O(V) space.
Queue: In the worst case, the queue can hold all courses, so it takes O(V) space.
Total Space Complexity: O(V + E).

'''
from collections import deque, defaultdict

def canFinish(numCourses, prerequisites):
    # Step 1: Build the graph
    graph = defaultdict(list)  # Adjacency list representation of the graph
    in_degree = [0] * numCourses  # Array to store the in-degree of each course
    
    for course, pre in prerequisites:
        graph[pre].append(course)  # Add the edge
        in_degree[course] += 1  # Increment in-degree of the course
    
    # Step 2: Initialize a queue with all courses that have 0 in-degree
    queue = deque()
    for i in range(numCourses):
        if in_degree[i] == 0:
            queue.append(i)
    
    # Step 3: Process courses
    processed_courses = 0
    while queue:
        course = queue.popleft()
        processed_courses += 1
        
        # For each neighbor of the current course, reduce its in-degree by 1
        for neighbor in graph[course]:
            in_degree[neighbor] -= 1
            # If the in-degree becomes 0, add it to the queue
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    # Step 4: If we processed all courses, there is no cycle, otherwise, there is a cycle
    return processed_courses == numCourses

# Example usage
numCourses = 2
prerequisites = [[1, 0]]
print(canFinish(numCourses, prerequisites))  # Output: True (Course 1 depends on course 0)

numCourses = 2
prerequisites = [[1, 0], [0, 1]]
print(canFinish(numCourses, prerequisites))  # Output: False (Cycle detected)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 5 TODO : course schedule - 2
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/course-schedule-i-and-ii-pre-requisite-tasks-topological-sort-g-24/


https://leetcode.com/problems/course-schedule-ii/

You are given the total number of courses numCourses and a list of prerequisite pairs prerequisites. Each pair [a, b] indicates that to take course a, you must complete course b first. You need to return the order in which you can take the courses, following the prerequisites. If there are multiple valid orders, return any of them. If it's impossible to complete all courses, return an empty array.

'''
# method 1 : brute force approch
''' 
Time Complexity:
Graph Construction: The time to build the graph is O(E), where E is the number of prerequisite pairs.
Queue Processing: Processing each course once and each edge once takes O(V + E) time, where V is the number of courses.
Total Time Complexity: O(V + E), where V is the number of courses and E is the number of prerequisite pairs.

Space Complexity:
Graph Representation: The graph uses O(V + E) space to store the adjacency list.
In-degree Array: The in-degree array takes O(V) space.
Queue: The queue takes O(V) space in the worst case (if all courses can be processed at once).
Result List: The result list takes O(V) space.
Total Space Complexity: O(V + E).
'''
from collections import deque, defaultdict

def findOrder(numCourses, prerequisites):
    # Step 1: Build the graph and calculate in-degree of each course
    graph = defaultdict(list)
    in_degree = [0] * numCourses
    
    for course, pre in prerequisites:
        graph[pre].append(course)
        in_degree[course] += 1
    
    # Step 2: Initialize a queue with all courses that have 0 in-degree
    queue = deque()
    for i in range(numCourses):
        if in_degree[i] == 0:
            queue.append(i)
    
    # Step 3: Process courses
    result = []
    while queue:
        course = queue.popleft()
        result.append(course)
        
        # For each neighbor of the current course, reduce its in-degree by 1
        for neighbor in graph[course]:
            in_degree[neighbor] -= 1
            # If the in-degree becomes 0, add it to the queue
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    # Step 4: If we processed all courses, return the result, otherwise return empty list
    return result if len(result) == numCourses else []

# Example usage
numCourses = 4
prerequisites = [[1, 0], [2, 0], [3, 1], [3, 2]]
print(findOrder(numCourses, prerequisites))  # Output: [0, 1, 2, 3] or [0, 2, 1, 3]

numCourses = 2
prerequisites = [[1, 0], [0, 1]]
print(findOrder(numCourses, prerequisites))  # Output: [] (Cycle detected, impossible to finish all courses)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 6 TODO : find eventual safe states
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/data-structure/find-eventual-safe-states-bfs-topological-sort-g-25/


https://leetcode.com/problems/find-eventual-safe-states/



'''
# method 1 : brute force approch
''' 
Time Complexity:
DFS Traversal: For each node, we potentially visit all its neighbors. Hence, the time complexity is O(V + E), where V is the number of nodes and E is the number of edges in the graph.
Space Complexity:
State Array: We use an array state of size V to track the state of each node.
Call Stack: The DFS call stack can go as deep as the number of nodes, so the space complexity for the call stack is O(V).
Total Space Complexity: O(V + E) due to the state array and adjacency list.

'''
def eventualSafeNodes(graph):
    # Helper function for DFS
    def dfs(node):
        if state[node] != 0:
            return state[node]  # If the node has been visited already, return its state (safe or unsafe)

        state[node] = 1  # Mark the node as visiting

        # Explore all neighbors of the current node
        for neighbor in graph[node]:
            if state[neighbor] == 1 or state[neighbor] == 0 and dfs(neighbor) == 1:
                # If a neighbor is visiting or leads to an unsafe node, mark this node as unsafe
                state[node] = 1
                return 1

        # Mark the node as safe
        state[node] = 2
        return 2

    # Initialize state array
    n = len(graph)
    state = [0] * n  # 0 - Unvisited, 1 - Visiting, 2 - Safe

    # Run DFS for all nodes to check which are safe
    result = []
    for i in range(n):
        if dfs(i) == 2:
            result.append(i)
    
    return result

# Example usage
graph = [[1,2], [2,3], [5], [0], [5], [], []]
print(eventualSafeNodes(graph))  # Output: [2, 4, 5, 6]


# method 2 : better approch
''' 
Time Complexity:
Graph Reversal: Constructing the reversed graph takes O(V + E) time.
BFS Traversal: Processing each node and its neighbors takes O(V + E) time.
Total Time Complexity: O(V + E).

Space Complexity:
Graph Representation: The reversed graph takes O(V + E) space.
In-degree Array: The in-degree array takes O(V) space.
Queue: The queue can hold all nodes in the worst case, so O(V) space.
Total Space Complexity: O(V + E).

'''
from collections import deque, defaultdict

def eventualSafeNodes(graph):
    # Step 1: Reverse the graph and calculate in-degrees
    n = len(graph)
    reverse_graph = defaultdict(list)
    in_degree = [0] * n
    
    for node in range(n):
        for neighbor in graph[node]:
            reverse_graph[neighbor].append(node)
            in_degree[node] += 1
    
    # Step 2: Initialize queue with nodes having 0 in-degree
    queue = deque()
    for i in range(n):
        if in_degree[i] == 0:
            queue.append(i)
    
    # Step 3: Perform BFS to find safe nodes
    safe_nodes = []
    while queue:
        node = queue.popleft()
        safe_nodes.append(node)
        
        # Reduce the in-degree of the neighboring nodes
        for neighbor in reverse_graph[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    return sorted(safe_nodes)

# Example usage
graph = [[1,2], [2,3], [5], [0], [5], [], []]
print(eventualSafeNodes(graph))  # Output: [2, 4, 5, 6]


# method 3 : optimal solution
# TC     -      
# SC     -      


# 7 TODO : alien dictionary
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/data-structure/alien-dictionary-topological-sort-g-26/


https://leetcode.com/problems/alien-dictionary/solution/

In this problem, we are given a list of words sorted lexicographically according to the rules of an alien language. We need to return the characters of the alien language in their correct order based on the given sorted words.

'''
# method 1 : brute force approch
''' 
Time Complexity:

Constructing the graph takes O(E), where E is the number of edges (which is proportional to the number of character comparisons across adjacent words).
Topological Sort (Kahnâ€™s Algorithm) takes O(V + E), where V is the number of vertices (characters) and E is the number of edges in the graph.
Overall, the time complexity is O(V + E).
Space Complexity:

The space complexity is O(V + E) due to the adjacency list representation of the graph, in-degree array, and the queue used for BFS.

'''
from collections import defaultdict, deque

def alienOrder(words):
    # Step 1: Build the graph
    graph = defaultdict(set)
    in_degree = defaultdict(int)

    # Initialize all characters in the words
    for word in words:
        for char in word:
            in_degree[char] = 0

    # Step 2: Compare adjacent words to build the graph and in-degree map
    for i in range(len(words) - 1):
        word1, word2 = words[i], words[i + 1]
        min_len = min(len(word1), len(word2))
        
        for j in range(min_len):
            if word1[j] != word2[j]:
                # Create a directed edge from word1[j] to word2[j]
                if word2[j] not in graph[word1[j]]:
                    graph[word1[j]].add(word2[j])
                    in_degree[word2[j]] += 1
                break
    
    # Step 3: Topological sort using Kahn's algorithm (BFS)
    # Start with characters that have zero in-degree
    queue = deque([char for char in in_degree if in_degree[char] == 0])
    result = []

    while queue:
        char = queue.popleft()
        result.append(char)

        for neighbor in graph[char]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)

    # Step 4: If result contains all the characters, we return the order
    if len(result) == len(in_degree):
        return ''.join(result)
    else:
        # If cycle exists, return an empty string
        return ""

# Example usage
words = ["wrt", "wrf", "er", "ett", "rftt"]
print(alienOrder(words))  # Output: "wertf"


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
''' 
Time Complexity: O(V + E), where V is the number of vertices (characters) and E is the number of edges in the graph.
Space Complexity: O(V + E), due to the graph representation, in-degree array, and the recursion stack.

'''
from collections import defaultdict

def alienOrder(words):
    # Step 1: Build the graph
    graph = defaultdict(set)
    in_degree = defaultdict(int)

    # Initialize all characters in the words
    for word in words:
        for char in word:
            in_degree[char] = 0

    # Step 2: Compare adjacent words to build the graph and in-degree map
    for i in range(len(words) - 1):
        word1, word2 = words[i], words[i + 1]
        min_len = min(len(word1), len(word2))
        
        for j in range(min_len):
            if word1[j] != word2[j]:
                # Create a directed edge from word1[j] to word2[j]
                if word2[j] not in graph[word1[j]]:
                    graph[word1[j]].add(word2[j])
                    in_degree[word2[j]] += 1
                break

    # Step 3: Perform DFS to get the topological order
    result = []
    visited = {}  # 0 = unvisited, 1 = visiting, 2 = visited

    def dfs(node):
        if node in visited:
            return visited[node]

        visited[node] = 1  # Mark the node as visiting

        for neighbor in graph[node]:
            if dfs(neighbor) == -1:
                return -1  # Cycle detected

        visited[node] = 2  # Mark the node as visited
        result.append(node)
        return 1

    # Start DFS from all nodes
    for char in in_degree:
        if char not in visited:
            if dfs(char) == -1:
                return ""  # Cycle detected

    # Reverse the result to get the correct order
    return ''.join(result[::-1])

# Example usage
words = ["wrt", "wrf", "er", "ett", "rftt"]
print(alienOrder(words))  # Output: "wertf"




# endregion





# region 15.4 GRAPHS - SORTEST PATH
# ---------------------------------

# 1 TODO :  shortest path in UG with unit weights
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/data-structure/shortest-path-in-undirected-graph-with-unit-distance-g-28/


https://bit.ly/3UVQD4C



'''
# method 1 : brute force approch
''' 
Time Complexity:
The time complexity of BFS is O(V + E), where V is the number of nodes and E is the number of edges in the graph. This is because each node is visited once and each edge is processed once.

Space Complexity:
The space complexity is O(V + E), where:
O(V) space is used for the distance array.
O(V + E) space is used to store the graph as an adjacency list.
O(V) space is used for the queue.

'''
from collections import deque, defaultdict

def shortestPathUG(graph, source, n):
    # Step 1: Initialize the distance array
    distance = [float('inf')] * n
    distance[source] = 0
    
    # Step 2: BFS initialization
    queue = deque([source])
    
    # Step 3: Perform BFS
    while queue:
        node = queue.popleft()
        
        # Explore all neighbors
        for neighbor in graph[node]:
            if distance[neighbor] == float('inf'):  # If the neighbor is unvisited
                distance[neighbor] = distance[node] + 1
                queue.append(neighbor)
    
    return distance

# Example usage
# Graph represented as adjacency list (undirected graph)
graph = defaultdict(list)
graph[0].extend([1, 4])
graph[1].extend([0, 2, 3])
graph[2].extend([1, 3])
graph[3].extend([1, 2, 4])
graph[4].extend([0, 3])

source = 0
n = 5  # Number of nodes in the graph
result = shortestPathUG(graph, source, n)
print(f"Shortest paths from source {source}: {result}")


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : shortest path in DAG
'''


ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/shortest-path-in-directed-acyclic-graph-topological-sort-g-27/


https://bit.ly/3Eo1mhq



'''
# method 1 : brute force approch
''' 
Time Complexity:

Topological Sort: The time complexity of topological sort using DFS is O(V + E), where V is the number of vertices and E is the number of edges in the graph.
Relaxation: Relaxing the edges takes O(E) time since each edge is processed once.
Therefore, the overall time complexity is O(V + E).

Space Complexity:

Graph Representation: The adjacency list uses O(V + E) space.
Distance Array: The distance array uses O(V) space.
Stack: The stack used for topological sort takes O(V) space.
Therefore, the overall space complexity is O(V + E).

'''
from collections import defaultdict, deque

# Topological Sort using DFS
def topologicalSort(graph, V):
    visited = [False] * V
    stack = []
    
    def dfs(node):
        visited[node] = True
        for neighbor in graph[node]:
            if not visited[neighbor]:
                dfs(neighbor)
        stack.append(node)
    
    for node in range(V):
        if not visited[node]:
            dfs(node)
    
    # Reverse the stack to get the topological order
    return stack[::-1]

# Shortest Path in DAG
def shortestPathInDAG(graph, V, source):
    # Step 1: Get the topological order of the nodes
    topo_order = topologicalSort(graph, V)
    
    # Step 2: Initialize distances with infinity
    distance = [float('inf')] * V
    distance[source] = 0
    
    # Step 3: Relax the edges in topological order
    for node in topo_order:
        # Update distances of all adjacent vertices
        for neighbor, weight in graph[node]:
            if distance[node] + weight < distance[neighbor]:
                distance[neighbor] = distance[node] + weight
    
    return distance

# Example Usage:
# Graph Representation: Adjacency list (node -> [(neighbor, weight)])
graph = defaultdict(list)
graph[0].append((1, 5))
graph[0].append((2, 3))
graph[1].append((3, 6))
graph[2].append((1, 2))
graph[2].append((3, 7))
graph[3].append((4, 2))
graph[4].append((5, 3))
graph[5].append((3, 1))

source = 0
V = 6  # Number of vertices in the graph
result = shortestPathInDAG(graph, V, source)
print(f"Shortest paths from source {source}: {result}")


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 3 TODO : Dijkatra's algorithm
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/dijkstras-algorithm-using-set-g-33/


https://practice.geeksforgeeks.org/problems/implementing-dijkstra-set-1-adjacency-matrix/1



'''
# method 1 : brute force approch
''' 
Time Complexity:
Brute Force Approach:

We would have to check all edges and nodes multiple times. For each node, we scan all its neighbors, leading to a time complexity of O(V * E), where V is the number of vertices and E is the number of edges.
Better Approach (Linear Search):

This is the approach where we use an array and for each node, we perform a linear search to find the node with the smallest distance. This would have a time complexity of O(V^2), since in the worst case we may have to scan all nodes for each node.
Optimized Approach (Using Min-Heap):

The time complexity is O((V + E) * log V):
O(V log V) for processing each vertex.
O(E log V) for relaxing the edges, as each edge may cause a heap operation (insertion).
This is the most efficient approach for sparse graphs.

Space Complexity:
Space Complexity:
O(V + E) for storing the graph as an adjacency list.
O(V) for storing the distance array.
O(V) for the min-heap to store the nodes with their distances.
Therefore, the total space complexity is O(V + E).

'''
import heapq

def dijkstra(graph, source, V):
    # Distance array, initialized to infinity for all nodes
    dist = [float('inf')] * V
    dist[source] = 0
    
    # Priority queue to store (distance, node) pairs
    min_heap = [(0, source)]  # (distance, node)
    
    while min_heap:
        # Extract node with the minimum distance
        current_dist, u = heapq.heappop(min_heap)
        
        # If the distance is not the current shortest, skip processing
        if current_dist > dist[u]:
            continue
        
        # Explore neighbors of node u
        for v, weight in graph[u]:
            # Relaxation step: check if a shorter path exists via u
            if dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                heapq.heappush(min_heap, (dist[v], v))  # Push the updated distance to the heap
    
    return dist

# Example Usage:
# Graph Representation: adjacency list, graph[u] = [(v1, weight1), (v2, weight2), ...]
graph = {
    0: [(1, 4), (2, 1)],
    1: [(2, 2), (3, 5)],
    2: [(1, 1), (3, 8), (4, 10)],
    3: [(4, 2)],
    4: []
}

V = 5  # Number of vertices
source = 0
shortest_paths = dijkstra(graph, source, V)

print(f"Shortest paths from source {source}: {shortest_paths}")


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 4 TODO : why parity queue is used in dijkatra's algorithm
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/dijkstras-algorithm-using-priority-queue-g-32/


https://bit.ly/3Et6alk

Parity Queue in Dijkstra's Algorithm
In Dijkstra's algorithm, a priority queue (often implemented using a min-heap) is used to efficiently fetch the vertex with the smallest tentative distance during the process. The use of this queue is crucial for optimizing the algorithm and improving its performance, especially when dealing with large graphs. Let's discuss why this data structure is used and its significance.

Problem Description:
When we need to find the shortest path in a weighted graph with non-negative edges, Dijkstra's algorithm is used. The key idea of the algorithm is to:

Start with a source node and set its distance to 0.
Use a priority queue to always process the node with the smallest tentative distance.
Relax the edges of the processed node and update the tentative distances of its neighbors.
Why Parity Queue (Min-Heap) is Used in Dijkstra's Algorithm:
A min-heap (or priority queue) allows us to efficiently:

Extract the node with the minimum distance (the node with the smallest tentative distance) in O(log V) time, where V is the number of vertices.
Update the distances of the neighbors and push these updated distances back into the priority queue in O(log V) time.
Without a priority queue, we would need to scan through all the vertices to find the one with the smallest distance, which would take O(V) time per operation. This would lead to a much slower solution.

Brute Force Approach (No Priority Queue):
Without a priority queue, we would:

Maintain a list of distances for each vertex.
At each step, scan the list to find the vertex with the smallest tentative distance.
This would require O(V) time to find the minimum vertex, and we would repeat this for each vertex, leading to a time complexity of O(V^2) for dense graphs.
Time Complexity (Brute Force Approach): O(V^2)
Space Complexity: O(V)

Better Approach (Priority Queue using Linear Search):
If we use a priority queue but don't optimize its structure (e.g., using a simple list or array), we can reduce the time complexity for extracting the minimum distance to O(log V) per extraction. However, in the case of using a simple unsorted list, updating the distances will still involve scanning through the list, which is inefficient.

Time Complexity: O(V log V + E), where E is the number of edges.
Space Complexity: O(V + E) for storing the graph and the priority queue.

Optimized Approach (Using Min-Heap or Priority Queue):
The optimized approach uses a min-heap (a type of priority queue). With the heap, both the extraction of the minimum distance and the updating of the neighbors can be done efficiently in O(log V) time.

Heap Operations: Each time we need to extract the minimum or update the distance of a node, we perform operations on the heap:
Extract-Min: Takes O(log V) time to remove the node with the smallest distance.
Insert/Update: Also takes O(log V) time to add or update a node in the heap.
Using this optimized approach, we achieve better time complexity, especially for large graphs with sparse edges.
Time Complexity (Optimized Approach): O((V + E) log V), where V is the number of vertices and E is the number of edges.
Space Complexity: O(V + E) for storing the graph and the priority queue.



'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 5 TODO : shortest path in binary tree
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡




https://takeuforward.org/data-structure/g-36-shortest-distance-in-a-binary-maze/


https://leetcode.com/problems/shortest-path-in-binary-matrix/



'''

# method 1 : brute force approch
''' 
Time Complexity: O(N), where N is the number of nodes in the binary tree.
Each node is visited once during DFS traversal.
Space Complexity: O(H), where H is the height of the binary tree (this is the maximum depth of the recursion stack).

'''
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

# Brute Force approach using DFS
def shortest_path_dfs(root, target, path=[]):
    if root is None:
        return None

    # Include current node to the path
    path.append(root.value)
    
    # If the target is found, return the current path
    if root.value == target:
        return path
    
    # Search in the left subtree
    left_path = shortest_path_dfs(root.left, target, path.copy())
    if left_path:
        return left_path
    
    # Search in the right subtree
    right_path = shortest_path_dfs(root.right, target, path.copy())
    return right_path

# Example usage
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
root.right.left = Node(6)
root.right.right = Node(7)

target = 5
print("Shortest path (DFS):", shortest_path_dfs(root, target))


# method 2 : better approch
''' 
Time Complexity: O(N), where N is the number of nodes in the tree.
BFS explores all nodes at most once.
Space Complexity: O(N), where N is the number of nodes in the tree.
The queue could store up to N nodes in the worst case.

'''
from collections import deque

# Better approach using BFS
def shortest_path_bfs(root, target):
    if not root:
        return []
    
    queue = deque([(root, [root.value])])  # Store the node and the path up to that node
    
    while queue:
        node, path = queue.popleft()
        
        # If the target node is found, return the path
        if node.value == target:
            return path
        
        # Add left child to the queue
        if node.left:
            queue.append((node.left, path + [node.left.value]))
        
        # Add right child to the queue
        if node.right:
            queue.append((node.right, path + [node.right.value]))
    
    return []  # If the target is not found

# Example usage
target = 5
print("Shortest path (BFS):", shortest_path_bfs(root, target))


# method 3 : optimal solution
''' 
Time Complexity: O(N), where N is the number of nodes in the binary tree.
We traverse each node at most once and store the path for each node.
Space Complexity: O(H), where H is the height of the binary tree.
Memoization uses additional space for storing results, and the maximum height determines the space used by the recursion stack.

'''
# Optimized approach using DFS with memoization
def shortest_path_dfs_memo(root, target, memo={}):
    if root is None:
        return None
    
    # Check if the path is already calculated
    if root in memo:
        return memo[root]
    
    # Start with an empty path
    path = [root.value]
    
    if root.value == target:
        memo[root] = path
        return path
    
    # Search left subtree
    left_path = shortest_path_dfs_memo(root.left, target, memo)
    if left_path:
        memo[root] = path + left_path
        return memo[root]
    
    # Search right subtree
    right_path = shortest_path_dfs_memo(root.right, target, memo)
    if right_path:
        memo[root] = path + right_path
        return memo[root]
    
    return None

# Example usage
target = 5
print("Shortest path (DFS with Memoization):", shortest_path_dfs_memo(root, target))


# 6 TODO : path with minimum effort
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/g-37-path-with-minimum-effort/


https://leetcode.com/problems/path-with-minimum-effort/



'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
''' 
Time Complexity:

Binary Search runs in O(log(max_height_diff)), where max_height_diff is the maximum possible difference in heights between two cells.
BFS runs in O(m * n), where m and n are the number of rows and columns in the grid.
Overall time complexity: O(m * n * log(max_height_diff)).
Space Complexity: O(m * n) for storing visited nodes and the queue.

'''
from collections import deque

def can_reach_end(grid, max_effort):
    m, n = len(grid), len(grid[0])
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    visited = [[False] * n for _ in range(m)]
    queue = deque([(0, 0)])  # Start from top-left corner
    visited[0][0] = True
    
    while queue:
        x, y = queue.popleft()
        
        # If we reach the bottom-right corner
        if x == m - 1 and y == n - 1:
            return True
        
        # Explore the neighbors
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:
                # Check if the effort to move to this cell is within the max_effort
                if abs(grid[x][y] - grid[nx][ny]) <= max_effort:
                    visited[nx][ny] = True
                    queue.append((nx, ny))
                    
    return False

def path_with_minimum_effort(grid):
    m, n = len(grid), len(grid[0])
    left, right = 0, max(max(row) for row in grid) - min(min(row) for row in grid)
    
    # Binary search on the maximum allowed effort
    while left < right:
        mid = (left + right) // 2
        
        # Check if there's a path with maximum effort <= mid
        if can_reach_end(grid, mid):
            right = mid  # Try to reduce the maximum effort
        else:
            left = mid + 1  # Increase the allowed effort
    
    return left

# Example usage
grid = [
    [1, 3, 1],
    [1, 2, 1],
    [3, 3, 1]
]

print("Minimum effort path:", path_with_minimum_effort(grid))


# method 3 : optimal solution
''' 
Time Complexity: O((m * n) log(m * n)), where m and n are the number of rows and columns. This is because we are using a priority queue (min-heap), and each node is processed once.
Space Complexity: O(m * n) for storing the visited nodes and the heap.


'''
import heapq

def dijkstra(grid):
    m, n = len(grid), len(grid[0])
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    heap = [(0, 0, 0)]  # (effort, row, col)
    visited = [[False] * n for _ in range(m)]
    visited[0][0] = True
    
    while heap:
        effort, x, y = heapq.heappop(heap)
        
        # If we reach the bottom-right corner
        if x == m - 1 and y == n - 1:
            return effort
        
        # Explore the neighbors
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:
                visited[nx][ny] = True
                new_effort = max(effort, abs(grid[x][y] - grid[nx][ny]))
                heapq.heappush(heap, (new_effort, nx, ny))
    
    return -1

def path_with_minimum_effort_dijkstra(grid):
    return dijkstra(grid)

# Example usage
grid = [
    [1, 3, 1],
    [1, 2, 1],
    [3, 3, 1]
]

print("Minimum effort path (Dijkstra):", path_with_minimum_effort_dijkstra(grid))


# 7 TODO : cheapest flights with K stops
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/g-38-cheapest-flights-within-k-stops/


https://leetcode.com/problems/cheapest-flights-within-k-stops/




'''
# method 1 : brute force approch
''' 
Time Complexity: O(K * E) where K is the maximum number of stops and E is the number of flights (edges). For each iteration (total K+1 iterations), we scan all flights and update the shortest path distances.
Space Complexity: O(N) where N is the number of airports, as we are storing the distance to each airport.

'''
from collections import defaultdict
import heapq

def findCheapestPrice(n, flights, src, dst, K):
    # Initialize distances array with a large number (infinity)
    # distances[i] will store the cheapest price to reach airport i with at most k stops
    inf = float('inf')
    dp = [inf] * n
    dp[src] = 0  # Starting point, 0 cost to reach source
    
    # Perform Bellman-Ford
    for _ in range(K + 1):
        # Make a copy of dp for this iteration to avoid overwriting data
        temp_dp = dp[:]
        for u, v, cost in flights:
            if dp[u] != inf and dp[u] + cost < temp_dp[v]:
                temp_dp[v] = dp[u] + cost
        dp = temp_dp

    # If the destination has not been updated, return -1 (not reachable)
    return dp[dst] if dp[dst] != inf else -1

# Example usage
flights = [
    [0, 1, 100], 
    [1, 2, 100], 
    [0, 2, 500]
]
n = 3  # number of airports
src = 0  # source airport
dst = 2  # destination airport
K = 1  # maximum number of stops

print("Cheapest flight with at most K stops:", findCheapestPrice(n, flights, src, dst, K))


# method 2 : better approch
''' 
Time Complexity: O(E log V) where E is the number of edges (flights) and V is the number of vertices (airports). The heap operations (push and pop) take O(log V) time, and each flight (edge) is processed once.
Space Complexity: O(E + V) for the adjacency list and the priority queue.
'''
import heapq

def findCheapestPrice(n, flights, src, dst, K):
    # Create adjacency list for the flights
    adj = defaultdict(list)
    for u, v, cost in flights:
        adj[u].append((v, cost))

    # Min-heap: (current_cost, current_node, stops)
    heap = [(0, src, 0)]  # Starting from src, with 0 cost and 0 stops
    # A dictionary to store the minimum cost to reach a node with a certain number of stops
    min_cost = {}

    while heap:
        cost, node, stops = heapq.heappop(heap)

        # If we have reached the destination and stops are within the limit
        if node == dst:
            return cost
        
        # If we've already visited this node with fewer or same number of stops, skip it
        if (node, stops) in min_cost and min_cost[(node, stops)] <= cost:
            continue

        min_cost[(node, stops)] = cost

        # If we haven't exceeded the max stops, process the neighbors
        if stops < K:
            for neighbor, price in adj[node]:
                new_cost = cost + price
                heapq.heappush(heap, (new_cost, neighbor, stops + 1))

    return -1  # No path found within K stops

# Example usage
flights = [
    [0, 1, 100], 
    [1, 2, 100], 
    [0, 2, 500]
]
n = 3  # number of airports
src = 0  # source airport
dst = 2  # destination airport
K = 1  # maximum number of stops

print("Cheapest flight with at most K stops (Dijkstra variant):", findCheapestPrice(n, flights, src, dst, K))


# method 3 : optimal solution
# TC     -      
# SC     -      


# 8 TODO : network delay time
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://leetcode.com/problems/network-delay-time/



'''
# method 1 : brute force approch
''' 
Time Complexity: O((E + V) log V), where E is the number of edges and V is the number of vertices. This is because for each edge, we perform a heappush or heappop operation, both of which take O(log V) time.
Space Complexity: O(E + V), where E is the number of edges and V is the number of nodes. This is the space used by the adjacency list, distance array, and priority queue.

'''
import heapq
import sys

def networkDelayTime(times, N, K):
    # Step 1: Create an adjacency list to represent the graph
    graph = {i: [] for i in range(1, N+1)}
    for u, v, w in times:
        graph[u].append((v, w))
    
    # Step 2: Initialize distance array to store the shortest time to reach each node
    # We set the initial distance to infinity for all nodes except the source node (K)
    dist = {i: sys.maxsize for i in range(1, N+1)}
    dist[K] = 0
    
    # Step 3: Create a priority queue to keep track of the node with the smallest distance
    pq = [(0, K)]  # (distance, node)
    
    while pq:
        # Step 4: Pop the node with the smallest distance from the priority queue
        d, node = heapq.heappop(pq)
        
        # Step 5: If the current distance is greater than the already known shortest distance, skip it
        if d > dist[node]:
            continue
        
        # Step 6: Iterate through the neighbors of the current node and update their distances
        for neighbor, time in graph[node]:
            new_dist = d + time
            if new_dist < dist[neighbor]:
                dist[neighbor] = new_dist
                heapq.heappush(pq, (new_dist, neighbor))
    
    # Step 7: Get the maximum distance from the dist dictionary
    max_dist = max(dist.values())
    
    # Step 8: If any node has infinity distance, it means it's unreachable from the source
    return max_dist if max_dist < sys.maxsize else -1

# Example usage
times = [
    [2, 1, 1], 
    [2, 3, 1], 
    [3, 4, 1]
]
N = 4  # number of nodes
K = 2  # starting node (source)

print("Network Delay Time:", networkDelayTime(times, N, K))  # Output should be 2


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 9 TODO : number of ways to arive at destination
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/g-40-number-of-ways-to-arrive-at-destination/


https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/



'''
# method 1 : brute force approch
''' 
Time Complexity:
Topological Sort using Kahnâ€™s algorithm takes O(V + E), where V is the number of vertices and E is the number of edges.
DP Update also takes O(V + E) as we visit each edge once to propagate the values.
Overall time complexity is O(V + E).

Space Complexity:
The adjacency list takes O(E) space.
The dp array takes O(V) space.
The in_degree array and queue used in topological sort take O(V) space.
Overall space complexity is O(V + E).

'''
from collections import defaultdict, deque

def countWaysToReachDestination(n, roads):
    # Step 1: Create an adjacency list for the graph
    graph = defaultdict(list)
    for u, v in roads:
        graph[u].append(v)
    
    # Step 2: Initialize DP table
    dp = [0] * n
    dp[0] = 1  # There's 1 way to reach the source node (itself)
    
    # Step 3: Perform Topological Sort using Kahn's Algorithm (BFS)
    in_degree = [0] * n
    for u, v in roads:
        in_degree[v] += 1
    
    # Kahn's algorithm for topological sort
    queue = deque()
    for i in range(n):
        if in_degree[i] == 0:
            queue.append(i)
    
    # Step 4: Process nodes in topological order
    while queue:
        node = queue.popleft()
        
        # Update dp values for the neighbors of the current node
        for neighbor in graph[node]:
            dp[neighbor] += dp[node]
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    # Step 5: The result is the number of ways to reach the destination node (n-1)
    return dp[n-1] if dp[n-1] > 0 else 0

# Example usage
n = 5  # number of nodes
roads = [
    [0, 1],
    [0, 2],
    [1, 3],
    [2, 3],
    [3, 4]
]

print("Number of ways to reach destination:", countWaysToReachDestination(n, roads))  # Output: 2


# method 2 : better approch
''' 
Time Complexity: O(V + E), as we only visit each node once and each edge once due to memoization.
Space Complexity: O(V + E) due to the adjacency list, recursion stack, and memoization.
'''
def countWaysToReachDestinationBrute(n, roads):
    # Create adjacency list
    graph = defaultdict(list)
    for u, v in roads:
        graph[u].append(v)
    
    # Memoization table to store the number of ways from a node to destination
    memo = {}
    
    def dfs(node):
        if node == n - 1:  # destination node
            return 1
        if node in memo:
            return memo[node]
        
        # Calculate the number of ways from this node
        total_ways = 0
        for neighbor in graph[node]:
            total_ways += dfs(neighbor)
        
        memo[node] = total_ways
        return total_ways
    
    return dfs(0)  # Start DFS from node 0

# Example usage
print("Number of ways to reach destination (Brute Force):", countWaysToReachDestinationBrute(n, roads))


# method 3 : optimal solution
# TC     -      
# SC     -      


# 10 TODO :  minimum steps to reach end from start by performing multiplicationand mod with array elements
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/graph/g-39-minimum-multiplications-to-reach-end/


https://bit.ly/3QAEsrY



'''
# method 1 : brute force approch
''' 
Time Complexity:

The time complexity of BFS is O(V + E) where V is the number of nodes (array indices) and E is the number of edges (possible moves between indices).
Each index can be processed at most once, and at most two operations are performed per index. So, the total time complexity is approximately O(n), where n is the length of the array.
Space Complexity:

The space complexity is O(n) due to the storage used by the visited array and the BFS queue.
'''
from collections import deque

def min_steps_to_reach_end(arr):
    n = len(arr)
    
    if n == 1:
        return 0  # Already at the end
    
    # Queue to hold (current index, number of steps)
    queue = deque([(0, 0)])  # Start from index 0 with 0 steps
    visited = [False] * n  # Keep track of visited indices
    visited[0] = True
    
    while queue:
        current_index, steps = queue.popleft()
        
        # If we have reached the last index
        if current_index == n - 1:
            return steps
        
        # Two possible operations: multiplication and modulo
        # Operation 1: Multiplying by arr[current_index]
        next_index_mult = current_index * arr[current_index]
        if next_index_mult < n and not visited[next_index_mult]:
            visited[next_index_mult] = True
            queue.append((next_index_mult, steps + 1))
        
        # Operation 2: Modulo with arr[current_index]
        next_index_mod = current_index % arr[current_index]
        if next_index_mod < n and not visited[next_index_mod]:
            visited[next_index_mod] = True
            queue.append((next_index_mod, steps + 1))
    
    return -1  # Return -1 if no solution exists

# Example usage:
arr = [2, 3, 1, 2, 4, 1]
print("Minimum steps to reach the end:", min_steps_to_reach_end(arr))


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 11 TODO : bellman ford algorithm
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/data-structure/bellman-ford-algorithm-g-41/


https://practice.geeksforgeeks.org/problems/distance-from-the-source-bellman-ford-algorithm/1

The Bellman-Ford algorithm is a well-known algorithm used for finding the shortest paths from a single source vertex to all other vertices in a graph. It can handle graphs with negative weight edges, unlike Dijkstra's algorithm. However, it cannot handle negative weight cycles.


'''
# method 1 : brute force approch
''' 
Time Complexity:
Brute Force Approach: O(V * E)
We perform V-1 iterations and in each iteration, we process all E edges, where V is the number of vertices and E is the number of edges.
Better/Optimized Approach: The time complexity is still O(V * E) because even with early stopping, in the worst case, the algorithm will still need to relax all edges V-1 times to ensure correctness.

Space Complexity:
Space Complexity: O(V + E)
We store the graph as an edge list, which takes O(E) space.
We also store the distances for each vertex, which takes O(V) space.

'''
class Graph:
    def __init__(self, vertices):
        self.V = vertices  # Number of vertices
        self.graph = []    # Edge list

    def add_edge(self, u, v, weight):
        self.graph.append([u, v, weight])  # Edge (u, v) with given weight

    def bellman_ford(self, src):
        # Step 1: Initialize distances
        distances = [float("inf")] * self.V
        distances[src] = 0

        # Step 2: Relax all edges (V-1) times
        for _ in range(self.V - 1):
            for u, v, weight in self.graph:
                if distances[u] != float("inf") and distances[u] + weight < distances[v]:
                    distances[v] = distances[u] + weight

        # Step 3: Check for negative weight cycles
        for u, v, weight in self.graph:
            if distances[u] != float("inf") and distances[u] + weight < distances[v]:
                print("Graph contains negative weight cycle")
                return None

        # Return the shortest distances from the source
        return distances

# Example usage
g = Graph(5)
g.add_edge(0, 1, -1)
g.add_edge(0, 2, 4)
g.add_edge(1, 2, 3)
g.add_edge(1, 3, 2)
g.add_edge(1, 4, 2)
g.add_edge(3, 2, 5)
g.add_edge(3, 1, 1)
g.add_edge(4, 3, -3)

src = 0
distances = g.bellman_ford(src)
if distances is not None:
    print(f"Shortest distances from source {src}:")
    for i in range(len(distances)):
        print(f"Vertex {i}: {distances[i]}")


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 12 TODO : floyd warshall algorithm
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/floyd-warshall-algorithm-g-42/


https://practice.geeksforgeeks.org/problems/implementing-floyd-warshall2042/1

The Floyd-Warshall algorithm is an efficient algorithm to find the shortest paths between all pairs of vertices in a weighted graph. It is particularly useful for finding shortest paths in dense graphs or graphs with negative edge weights, but it cannot handle negative weight cycles.

'''
# method 1 : brute force approch
'''end=
Time Complexity:
Brute Force Approach: O(V^3)
The algorithm uses three nested loops to check all possible paths between the vertices, where V is the number of vertices. Hence, the time complexity is O(V^3), which is typical for the Floyd-Warshall algorithm.
Space Complexity:
Space Complexity: O(V^2)
The space complexity comes from storing the distance matrix dist[][], which has V^2 elements.
'''
INF = float("inf")

def floyd_warshall(graph, V):
    # dist[][] will store the shortest path distances between every pair of vertices
    dist = [[INF] * V for _ in range(V)]

    # Initialize the distance matrix with the given graph
    for i in range(V):
        for j in range(V):
            if graph[i][j] != 0:
                dist[i][j] = graph[i][j]
            if i == j:
                dist[i][j] = 0  # Distance from a vertex to itself is 0

    # Floyd-Warshall algorithm
    for k in range(V):
        for i in range(V):
            for j in range(V):
                # If a shorter path is found, update the distance
                if dist[i][j] > dist[i][k] + dist[k][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    
    # Print the shortest distance matrix
    for i in range(V):
        for j in range(V):
            if dist[i][j] == INF:
                print("INF", end=" ")
            else:
                print(dist[i][j], end=" ")
        print()

# Example graph (adjacency matrix representation)
graph = [
    [0, 3, INF, INF],
    [2, 0, INF, 6],
    [INF, 7, 0, 1],
    [4, INF, 2, 0]
]

V = 4  # Number of vertices
floyd_warshall(graph, V)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 13 TODO : find the city with the smallest number of neighbours at a threshold distance
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/data-structure/find-the-city-with-the-smallest-number-of-neighbours-at-a-threshold-distance-g-43/


https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/

You are given a list of cities connected by roads, where each road has a distance. The goal is to find the city with the smallest number of neighbors whose distance is at most a given threshold. This is a typical graph problem where we need to perform a breadth-first or depth-first search, keeping track of distances and counting the number of neighbors.



'''
# method 1 : brute force approch
''' 

Time Complexity (TC):
Brute Force: O(n^2), as we check each cityâ€™s distance to all other cities.
Optimized (BFS Approach):
For each city, we perform a BFS, which takes O(V + E) time, where V is the number of cities and E is the number of roads.
In the worst case, BFS is called n times, so the total time complexity is O(n * (V + E)).
Since V is the number of cities (n) and E is the number of roads, the time complexity is O(n * (n + E)).
Space Complexity (SC):
Space Complexity: O(n + E) for storing the adjacency list, where n is the number of cities and E is the number of roads.
The BFS queue and visited array also consume O(n) space.

''' 
from collections import deque

def findCityWithSmallestNeighbors(n, roads, distanceThreshold):
    # Create adjacency list from roads data
    adj = [[] for _ in range(n)]
    for u, v, w in roads:
        adj[u].append((v, w))
        adj[v].append((u, w))

    def bfs(city):
        # BFS to find the number of neighbors within the threshold
        visited = [False] * n
        queue = deque([(city, 0)])  # (node, distance)
        visited[city] = True
        count = 0
        
        while queue:
            node, dist = queue.popleft()
            
            for neighbor, weight in adj[node]:
                if not visited[neighbor] and dist + weight <= distanceThreshold:
                    visited[neighbor] = True
                    count += 1
                    queue.append((neighbor, dist + weight))
        
        return count

    min_neighbors = n  # Initialize with the maximum possible (i.e., all cities)
    result_city = -1

    # Check each city and find the one with the smallest number of neighbors
    for city in range(n):
        num_neighbors = bfs(city)
        if num_neighbors < min_neighbors:
            min_neighbors = num_neighbors
            result_city = city

    return result_city

# Example usage
n = 5  # Number of cities
roads = [
    [0, 1, 2],
    [0, 2, 3],
    [1, 2, 1],
    [1, 3, 2],
    [2, 3, 4],
    [3, 4, 1]
]  # Roads in the format [u, v, weight]
distanceThreshold = 4

print("City with smallest number of neighbors within the threshold distance:", findCityWithSmallestNeighbors(n, roads, distanceThreshold))


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      




# endregion





# region 15.5 GRAPHS - MST/DISJOINT SET
# -------------------------------------

# 1 TODO :  minimum spanning tree
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/minimum-spanning-tree-theory-g-44/


https://practice.geeksforgeeks.org/problems/minimum-spanning-tree/1

The Minimum Spanning Tree (MST) of a graph is a subset of edges that connects all the vertices in the graph while minimizing the total edge weight, without forming any cycles. There are two popular algorithms to find the MST:

Kruskal's Algorithm
Prim's Algorithm

'''
# method 1 : brute force approch
''' 
Time Complexity:
Building the priority queue takes 
ğ‘‚
(
log
â¡
ğ‘‰
)
O(logV) for each vertex, and there are 
ğ‘‰
V vertices.
For each edge, we perform an insertion and extraction operation, each taking 
ğ‘‚
(
log
â¡
ğ‘‰
)
O(logV).
Hence, the time complexity is 
ğ‘‚
(
ğ¸
log
â¡
ğ‘‰
)
O(ElogV), where 
ğ¸
E is the number of edges and 
ğ‘‰
V is the number of vertices.
Space Complexity:
The space complexity is 
ğ‘‚
(
ğ‘‰
+
ğ¸
)
O(V+E) because we store the graph as an adjacency list and use the priority queue, which at most holds 
ğ‘‰
V vertices and 
ğ¸
E edges.

'''
import heapq

# Function to find the minimum spanning tree using Prim's algorithm
def prim_mst(graph, V):
    # Priority queue to store edges
    min_heap = []
    # Start from vertex 0
    heapq.heappush(min_heap, (0, 0))  # (weight, vertex)
    visited = [False] * V
    mst_cost = 0
    mst_edges = []
    
    while min_heap:
        weight, node = heapq.heappop(min_heap)
        
        # If the node is already in the MST, we skip it
        if visited[node]:
            continue
        
        # Mark the node as visited
        visited[node] = True
        mst_cost += weight
        
        # Add the edge to the result (optional)
        if weight != 0:
            mst_edges.append((prev_node, node, weight))
        
        # Explore the neighbors
        for neighbor, edge_weight in graph[node]:
            if not visited[neighbor]:
                heapq.heappush(min_heap, (edge_weight, neighbor))
                prev_node = node
    
    return mst_cost, mst_edges

# Example Graph represented as an adjacency list:
# graph[u] = [(v1, w1), (v2, w2), ...] means there's an edge from u to v1, v2, etc. with weights w1, w2, etc.
graph = {
    0: [(1, 1), (2, 4)],
    1: [(0, 1), (2, 2), (3, 5)],
    2: [(0, 4), (1, 2), (3, 1)],
    3: [(1, 5), (2, 1)]
}

# Number of vertices
V = 4

# Run Prim's algorithm
mst_cost, mst_edges = prim_mst(graph, V)

print("Minimum Spanning Tree Cost:", mst_cost)
print("Edges in the MST:", mst_edges)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : prism's algorithm
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/prims-algorithm-minimum-spanning-tree-c-and-java-g-45/


https://practice.geeksforgeeks.org/problems/minimum-spanning-tree/1

Prim's algorithm is used to find the Minimum Spanning Tree (MST) of a graph, which is a subset of edges that connects all the vertices in the graph while minimizing the total edge weight.
There are three main approaches for implementing Prim's Algorithm:

Brute Force Approach
Better Approach (Using Min-Heap)
Optimized Approach (Using Fibonacci Heap)


'''
# method 1 : brute force approch
''' 
Time Complexity:

Inserting and extracting from the min-heap takes 
ğ‘‚
(
log
â¡
ğ‘‰
)
O(logV) for each vertex, and there are 
ğ‘‰
V vertices.
For each edge, we perform an insertion operation into the heap, which takes 
ğ‘‚
(
log
â¡
ğ‘‰
)
O(logV).
The total time complexity is 
ğ‘‚
(
ğ¸
log
â¡
ğ‘‰
)
O(ElogV), where 
ğ¸
E is the number of edges and 
ğ‘‰
V is the number of vertices.
Space Complexity:

The space complexity is 
ğ‘‚
(
ğ‘‰
+
ğ¸
)
O(V+E) because we store the graph as an adjacency list and the priority queue can hold at most 
ğ‘‰
V vertices and 
ğ¸
E edges.
'''
import heapq

# Function to implement Prim's Algorithm using Min-Heap (Priority Queue)
def prim_mst(graph, V):
    # Min-Heap to store the edges (weight, vertex)
    min_heap = []
    # Start from the 0th node (can be any node)
    heapq.heappush(min_heap, (0, 0))  # (weight, node)
    
    # Array to keep track of the vertices included in the MST
    visited = [False] * V
    mst_cost = 0  # Total cost of MST
    mst_edges = []  # List to store the edges in the MST
    
    while min_heap:
        weight, node = heapq.heappop(min_heap)
        
        # Skip if the node is already included in MST
        if visited[node]:
            continue
        
        # Mark the node as included in MST
        visited[node] = True
        mst_cost += weight
        
        # If weight is not 0, then this edge is part of MST
        if weight != 0:
            mst_edges.append((prev_node, node, weight))
        
        # Explore the neighbors of the current node
        for neighbor, edge_weight in graph[node]:
            if not visited[neighbor]:
                heapq.heappush(min_heap, (edge_weight, neighbor))
                prev_node = node
    
    return mst_cost, mst_edges

# Example Graph represented as an adjacency list:
# graph[u] = [(v1, w1), (v2, w2), ...] means there's an edge from u to v1, v2, etc. with weights w1, w2, etc.
graph = {
    0: [(1, 1), (2, 4)],
    1: [(0, 1), (2, 2), (3, 5)],
    2: [(0, 4), (1, 2), (3, 1)],
    3: [(1, 5), (2, 1)]
}

# Number of vertices
V = 4

# Run Prim's algorithm
mst_cost, mst_edges = prim_mst(graph, V)

print("Minimum Spanning Tree Cost:", mst_cost)
print("Edges in the MST:", mst_edges)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 3 TODO : disjoint set (union by rank)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/disjoint-set-union-by-rank-union-by-size-path-compression-g-46/


https://bit.ly/3QSGvHz

The Disjoint Set Union (DSU) data structure, also known as Union-Find, is commonly used for handling connected components in a graph. It supports two main operations:

Find: Find the root representative of a given element.
Union: Merge the sets containing two elements.
The Union by Rank optimization ensures that when two sets are merged, the root of the tree with the smaller rank becomes the child of the root of the tree with the larger rank. This helps in keeping the tree height small, improving the efficiency of future operations.


'''
# method 1 : brute force approch
''' 
Time Complexity:
Find Operation: 
ğ‘‚
(
ğ›¼
(
ğ‘‰
)
)
O(Î±(V)), where 
ğ›¼
Î± is the inverse Ackermann function. In practice, this is almost constant time, even for very large 
ğ‘‰
V.

Union Operation: 
ğ‘‚
(
ğ›¼
(
ğ‘‰
)
)
O(Î±(V)), where 
ğ›¼
Î± is the inverse Ackermann function, similar to the find operation.

Thus, both the find and union operations are very efficient with amortized 
ğ‘‚
(
ğ›¼
(
ğ‘‰
)
)
O(Î±(V)) time.

Space Complexity:
Space Complexity: 
ğ‘‚
(
ğ‘‰
)
O(V) for the parent and rank arrays.

'''
class DisjointSet:
    def __init__(self, n):
        # Parent array to keep track of the leader of each set
        self.parent = [i for i in range(n)]
        # Rank array to keep track of tree height for Union by Rank
        self.rank = [0] * n
    
    # Find operation with path compression
    def find(self, x):
        # If x is the root of itself, return x
        if self.parent[x] != x:
            # Path compression: make every node in the path point directly to the root
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    # Union operation with union by rank
    def union(self, x, y):
        # Find the roots of both x and y
        rootX = self.find(x)
        rootY = self.find(y)
        
        if rootX != rootY:
            # Union by rank: attach the smaller tree under the larger one
            if self.rank[rootX] > self.rank[rootY]:
                self.parent[rootY] = rootX
            elif self.rank[rootX] < self.rank[rootY]:
                self.parent[rootX] = rootY
            else:
                # If both have the same rank, make one root the parent of the other
                self.parent[rootY] = rootX
                # Increment the rank if both trees were of the same height
                self.rank[rootX] += 1

# Example usage of the Disjoint Set data structure
if __name__ == "__main__":
    n = 5  # Number of elements (0 to 4)
    ds = DisjointSet(n)
    
    # Performing union operations
    ds.union(0, 1)
    ds.union(1, 2)
    ds.union(3, 4)
    
    # Finding representatives of each element
    print(ds.find(0))  # Output: 0
    print(ds.find(1))  # Output: 0
    print(ds.find(2))  # Output: 0
    print(ds.find(3))  # Output: 3
    print(ds.find(4))  # Output: 3
    
    # Union 2 and 3
    ds.union(2, 3)
    
    # Now 0, 1, 2, and 3 should be in the same set
    print(ds.find(2))  # Output: 0
    print(ds.find(3))  # Output: 0


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 4 TODO : disjoint set (union by size)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/disjoint-set-union-by-rank-union-by-size-path-compression-g-46/

https://bit.ly/3QSGvHz


'''
# method 1 : brute force approch
''' 
Time Complexity:
Find Operation: 
ğ‘‚
(
ğ›¼
(
ğ‘‰
)
)
O(Î±(V)), where 
ğ›¼
Î± is the inverse Ackermann function. In practice, this is almost constant time, even for very large 
ğ‘‰
V.

Union Operation: 
ğ‘‚
(
ğ›¼
(
ğ‘‰
)
)
O(Î±(V)), as we use union by size to minimize tree height.

Thus, both find and union operations are very efficient with amortized 
ğ‘‚
(
ğ›¼
(
ğ‘‰
)
)
O(Î±(V)) time.

Space Complexity:
Space Complexity: 
ğ‘‚
(
ğ‘‰
)
O(V) for the parent and size arrays.

'''
class DisjointSet:
    def __init__(self, n):
        # Parent array to keep track of the leader of each set
        self.parent = [i for i in range(n)]
        # Size array to keep track of the size of each set (initially each set has size 1)
        self.size = [1] * n
    
    # Find operation with path compression
    def find(self, x):
        # If x is the root of itself, return x
        if self.parent[x] != x:
            # Path compression: make every node in the path point directly to the root
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    # Union operation with union by size
    def union(self, x, y):
        # Find the roots of both x and y
        rootX = self.find(x)
        rootY = self.find(y)
        
        if rootX != rootY:
            # Union by size: attach the smaller tree under the larger one
            if self.size[rootX] < self.size[rootY]:
                self.parent[rootX] = rootY
                self.size[rootY] += self.size[rootX]
            else:
                self.parent[rootY] = rootX
                self.size[rootX] += self.size[rootY]

# Example usage of the Disjoint Set data structure
if __name__ == "__main__":
    n = 5  # Number of elements (0 to 4)
    ds = DisjointSet(n)
    
    # Performing union operations
    ds.union(0, 1)
    ds.union(1, 2)
    ds.union(3, 4)
    
    # Finding representatives of each element
    print(ds.find(0))  # Output: 0
    print(ds.find(1))  # Output: 0
    print(ds.find(2))  # Output: 0
    print(ds.find(3))  # Output: 3
    print(ds.find(4))  # Output: 3
    
    # Union 2 and 3
    ds.union(2, 3)
    
    # Now 0, 1, 2, and 3 should be in the same set
    print(ds.find(2))  # Output: 0
    print(ds.find(3))  # Output: 0


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 5 TODO : kruskal's algorithm
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/kruskals-algorithm-minimum-spanning-tree-g-47/


https://practice.geeksforgeeks.org/problems/minimum-spanning-tree/1

Kruskalâ€™s algorithm is a greedy algorithm used to find the minimum spanning tree (MST) of a graph. The algorithm works by sorting all the edges of the graph in non-decreasing order of their weights. Then, it adds edges to the MST one by one, ensuring no cycles are formed, by using the Disjoint Set Union-Find data structure to check for cycles.

'''
# method 1 : brute force approch
''' 
Time Complexity:
Sorting the edges: 
ğ‘‚
(
ğ¸
log
â¡
ğ¸
)
O(ElogE), where 
ğ¸
E is the number of edges. Sorting the edges is the most time-consuming operation in Kruskalâ€™s algorithm.
Union-Find Operations: Each find and union operation takes 
ğ‘‚
(
ğ›¼
(
ğ‘‰
)
)
O(Î±(V)), where 
ğ›¼
(
ğ‘‰
)
Î±(V) is the inverse Ackermann function (which grows extremely slowly and is practically constant). Since we perform at most 
ğ¸
E operations, the total time complexity for the union-find operations is 
ğ‘‚
(
ğ¸
ğ›¼
(
ğ‘‰
)
)
O(EÎ±(V)).
Thus, the overall time complexity is:

ğ‘‚
(
ğ¸
log
â¡
ğ¸
+
ğ¸
ğ›¼
(
ğ‘‰
)
)
O(ElogE+EÎ±(V))
Since 
ğ›¼
(
ğ‘‰
)
Î±(V) is almost constant for all practical purposes, this is roughly 
ğ‘‚
(
ğ¸
log
â¡
ğ¸
)
O(ElogE).

Space Complexity:
The space complexity is 
ğ‘‚
(
ğ‘‰
+
ğ¸
)
O(V+E), as we need to store the disjoint-set data structure (which requires 
ğ‘‚
(
ğ‘‰
)
O(V) space for the parent and rank arrays) and the edges array (which requires 
ğ‘‚
(
ğ¸
)
O(E) space).
''' 
class DisjointSet:
    def __init__(self, n):
        self.parent = [i for i in range(n)]  # Initially each node is its own parent
        self.rank = [0] * n  # Rank array for union by rank

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # Path compression
        return self.parent[x]

    def union(self, x, y):
        rootX = self.find(x)
        rootY = self.find(y)

        if rootX != rootY:
            # Union by rank: attach the smaller rank tree under the larger rank tree
            if self.rank[rootX] > self.rank[rootY]:
                self.parent[rootY] = rootX
            elif self.rank[rootX] < self.rank[rootY]:
                self.parent[rootX] = rootY
            else:
                self.parent[rootY] = rootX
                self.rank[rootX] += 1

def kruskal(V, edges):
    # V: number of vertices, edges: list of edges (weight, vertex1, vertex2)
    disjoint_set = DisjointSet(V)
    mst = []  # List to store the edges of MST
    edges.sort()  # Sort edges by weight

    for weight, u, v in edges:
        if disjoint_set.find(u) != disjoint_set.find(v):  # No cycle
            mst.append((u, v, weight))
            disjoint_set.union(u, v)

    return mst

# Example usage:
if __name__ == "__main__":
    V = 4  # Number of vertices
    edges = [
        (10, 0, 1),  # (weight, u, v)
        (15, 0, 2),
        (5, 1, 2),
        (20, 1, 3),
        (25, 2, 3)
    ]

    mst = kruskal(V, edges)
    print("Edges in the MST:")
    for u, v, weight in mst:
        print(f"({u}, {v}) with weight {weight}")


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 6 TODO : number of operations to make network connected
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/number-of-operations-to-make-network-connected-dsu-g-49/


https://leetcode.com/problems/number-of-operations-to-make-network-connected/


'''
# method 1 : brute force approch
''' 
Time Complexity:
Union-Find Operations:

The find and union operations each take 
ğ‘‚
(
ğ›¼
(
ğ‘‰
)
)
O(Î±(V)), where 
ğ›¼
(
ğ‘‰
)
Î±(V) is the inverse Ackermann function, which is extremely slow-growing and nearly constant.
For E edges, the time complexity for union-find operations is 
ğ‘‚
(
ğ¸
ğ›¼
(
ğ‘‰
)
)
O(EÎ±(V)).
Sorting Edges: No sorting is needed in this case, so the time complexity is dominated by the union-find operations.

Thus, the overall time complexity is:

ğ‘‚
(
ğ¸
ğ›¼
(
ğ‘‰
)
)
O(EÎ±(V))
where:

ğ¸
E is the number of edges (connections),
ğ‘‰
V is the number of nodes (vertices).
Space Complexity:
We use a parent array and a rank array to store the Union-Find structure, which takes 
ğ‘‚
(
ğ‘‰
)
O(V) space.
The connections array takes 
ğ‘‚
(
ğ¸
)
O(E) space.
Thus, the overall space complexity is:

ğ‘‚
(
ğ‘‰
+
ğ¸
)
O(V+E)

'''
class DisjointSet:
    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.rank = [0] * n

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # Path compression
        return self.parent[x]

    def union(self, x, y):
        rootX = self.find(x)
        rootY = self.find(y)

        if rootX != rootY:
            # Union by rank
            if self.rank[rootX] > self.rank[rootY]:
                self.parent[rootY] = rootX
            elif self.rank[rootX] < self.rank[rootY]:
                self.parent[rootX] = rootY
            else:
                self.parent[rootY] = rootX
                self.rank[rootX] += 1

def makeNetworkConnected(n, connections):
    if len(connections) < n - 1:
        return -1  # Not enough edges to connect all nodes

    disjoint_set = DisjointSet(n)
    
    for u, v in connections:
        disjoint_set.union(u, v)

    # Count how many distinct components (disjoint sets) there are
    components = set()
    for i in range(n):
        components.add(disjoint_set.find(i))

    # To connect all components, we need (components - 1) edges
    return len(components) - 1

# Example Usage
if __name__ == "__main__":
    n = 6  # Number of nodes
    connections = [
        [0, 1],
        [0, 2],
        [3, 4]
    ]
    
    result = makeNetworkConnected(n, connections)
    print(f"Minimum operations needed: {result}")


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 7 TODO : most stones removed with the same rows or columns
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/most-stones-removed-with-same-row-or-column-dsu-g-53/


https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/

Problem Statement: You are given a 2D grid, where each cell has either a stone (1) or is empty (0). The goal is to remove as many stones as possible, where stones in the same row or column can be removed. You can remove stones in a row or column by selecting all the stones in that row/column and marking them as removed.

The task is to return the maximum number of stones that can be removed while satisfying the above condition. The optimal approach involves utilizing connected components (like rows and columns being connected).

'''
# method 1 : brute force approch
''' 
Time Complexity:

DFS takes 
ğ‘‚
(
ğ¸
)
O(E), where 
ğ¸
E is the number of stones (since each stone is connected to at most 
ğ‘›
+
ğ‘š
n+m others).
The overall time complexity is 
ğ‘‚
(
ğ‘›
Ã—
ğ‘š
)
O(nÃ—m) because we visit each stone once, where 
ğ‘›
n and 
ğ‘š
m are the dimensions of the grid (number of stones).
Space Complexity:

The space complexity is 
ğ‘‚
(
ğ‘›
Ã—
ğ‘š
)
O(nÃ—m) for storing the visited nodes and the stones.

''' 
def removeStones(stones):
    # Helper function to perform DFS
    def dfs(stone, visited, stones_set):
        visited.add(stone)
        x, y = stone
        # Explore all stones in the same row and column
        for next_stone in stones_set:
            if next_stone not in visited and (next_stone[0] == x or next_stone[1] == y):
                dfs(next_stone, visited, stones_set)

    stones_set = set(tuple(stone) for stone in stones)
    visited = set()
    components = 0

    for stone in stones:
        if tuple(stone) not in visited:
            dfs(tuple(stone), visited, stones_set)
            components += 1
    
    # The number of stones we can remove is equal to the number of stones minus the number of components
    return len(stones) - components

# Example Usage
stones = [[0, 0], [0, 1], [1, 0], [1, 1], [2, 2]]
print(removeStones(stones))  # Output: 3


# method 2 : better approch
''' 
Time Complexity:

The find and union operations are 
ğ‘‚
(
ğ›¼
(
ğ‘›
)
)
O(Î±(n)), where 
ğ›¼
(
ğ‘›
)
Î±(n) is the inverse Ackermann function (almost constant).
The loop over all pairs of stones results in 
ğ‘‚
(
ğ‘›
2
)
O(n 
2
 ), where 
ğ‘›
n is the number of stones.
Hence, the overall time complexity is 
ğ‘‚
(
ğ‘›
2
ğ›¼
(
ğ‘›
)
)
O(n 
2
 Î±(n)), where 
ğ‘›
n is the number of stones.
Space Complexity:

The space complexity is 
ğ‘‚
(
ğ‘›
)
O(n) for the Union-Find structure and mapping stones.

'''
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # Path compression
        return self.parent[x]

    def union(self, x, y):
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX != rootY:
            self.parent[rootY] = rootX  # Union

def removeStones(stones):
    # Map stone positions to unique indexes
    stone_map = {}
    idx = 0
    for i, stone in enumerate(stones):
        if tuple(stone) not in stone_map:
            stone_map[tuple(stone)] = idx
            idx += 1

    # Initialize UnionFind
    uf = UnionFind(len(stones))
    
    # Union stones in the same row or column
    for i, (x1, y1) in enumerate(stones):
        for j, (x2, y2) in enumerate(stones):
            if i != j:
                if x1 == x2 or y1 == y2:
                    uf.union(i, j)

    # Count distinct components
    components = len(set(uf.find(i) for i in range(len(stones))))
    
    # Maximum number of stones that can be removed
    return len(stones) - components

# Example Usage
stones = [[0, 0], [0, 1], [1, 0], [1, 1], [2, 2]]
print(removeStones(stones))  # Output: 3


# method 3 : optimal solution
# TC     -      
# SC     -      


# 8 TODO : accounts merge
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/accounts-merge-dsu-g-50/


https://leetcode.com/problems/accounts-merge/

Problem Statement: You are given a list of accounts, where each account is a list consisting of:

A name (string),
A list of email addresses (strings).
We need to merge accounts that share the same email address into one account. The result should contain each unique account, where emails are grouped and no duplicates are present.

'''
# method 1 : brute force approch
''' 
Time Complexity: 
ğ‘‚
(
ğ‘›
Ã—
ğ‘š
)
O(nÃ—m) where 
ğ‘›
n is the number of accounts, and 
ğ‘š
m is the number of emails per account. Each email is visited once, and we perform DFS on each connected component.
Space Complexity: 
ğ‘‚
(
ğ‘›
Ã—
ğ‘š
)
O(nÃ—m) due to the graph and the visited set.

'''
from collections import defaultdict

def accountsMerge(accounts):
    # Create a graph where emails are nodes
    graph = defaultdict(list)
    email_to_name = {}
    
    # Build the graph
    for account in accounts:
        name = account[0]
        for i in range(1, len(account)):
            email_to_name[account[i]] = name
            graph[account[i]].append(account[i - 1])
            graph[account[i - 1]].append(account[i])

    # Use DFS to find all connected emails
    def dfs(email, visited, emails):
        visited.add(email)
        emails.append(email)
        for neighbor in graph[email]:
            if neighbor not in visited:
                dfs(neighbor, visited, emails)

    visited = set()
    result = []

    # Run DFS for each email
    for email in email_to_name:
        if email not in visited:
            emails = []
            dfs(email, visited, emails)
            result.append([email_to_name[email]] + sorted(emails))

    return result

# Example Usage
accounts = [
    ["John", "john0@mail.com", "john1@mail.com"],
    ["John", "john1@mail.com", "john2@mail.com"],
    ["Mary", "mary0@mail.com"],
    ["John", "john2@mail.com", "john3@mail.com"]
]
print(accountsMerge(accounts))


# method 2 : better approch
''' 
Time Complexity: 
ğ‘‚
(
ğ‘›
ğ›¼
(
ğ‘›
)
)
O(nÎ±(n)), where 
ğ‘›
n is the number of unique emails. The union-find operations are efficient due to path compression and union by rank.
Space Complexity: 
ğ‘‚
(
ğ‘›
)
O(n) for the union-find data structure and the mapping of emails to indices.

'''
class UnionFind:
    def __init__(self, n):
        self.parent = {i: i for i in range(n)}
        self.rank = {i: 0 for i in range(n)}

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # Path compression
        return self.parent[x]

    def union(self, x, y):
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX != rootY:
            # Union by rank
            if self.rank[rootX] > self.rank[rootY]:
                self.parent[rootY] = rootX
            elif self.rank[rootX] < self.rank[rootY]:
                self.parent[rootX] = rootY
            else:
                self.parent[rootY] = rootX
                self.rank[rootX] += 1

def accountsMerge(accounts):
    email_to_index = {}
    uf = UnionFind(len(accounts))

    # Map emails to indices and unite accounts
    for i, account in enumerate(accounts):
        name = account[0]
        for email in account[1:]:
            if email not in email_to_index:
                email_to_index[email] = len(email_to_index)
            uf.union(email_to_index[account[1]], email_to_index[email])
    
    # Group all emails by their root
    root_to_emails = defaultdict(list)
    for email, idx in email_to_index.items():
        root = uf.find(idx)
        root_to_emails[root].append(email)

    # Prepare the result
    result = []
    for emails in root_to_emails.values():
        name = accounts[email_to_index[emails[0]]][0]
        result.append([name] + sorted(emails))
    
    return result

# Example Usage
accounts = [
    ["John", "john0@mail.com", "john1@mail.com"],
    ["John", "john1@mail.com", "john2@mail.com"],
    ["Mary", "mary0@mail.com"],
    ["John", "john2@mail.com", "john3@mail.com"]
]
print(accountsMerge(accounts))


# method 3 : optimal solution
# TC     -      
# SC     -      


# 9 TODO : number of islands - II
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/graph/number-of-islands-ii-online-queries-dsu-g-51/

https://leetcode.com/problems/number-of-islands-ii/

You are given a 2D grid representing a map of '0's (water) and '1's (land). Initially, all land cells are separated and isolated. Now you are given a sequence of k positions where land cells will be added one by one. After each addition of land, you are supposed to return the number of connected islands in the grid.

'''
# method 1 : brute force approch
''' 
Time Complexity: 
ğ‘‚
(
ğ‘˜
Ã—
ğ›¼
(
ğ‘›
Ã—
ğ‘š
)
)
O(kÃ—Î±(nÃ—m)), where 
ğ‘˜
k is the number of operations (positions) and 
ğ›¼
Î± is the inverse Ackermann function, which is nearly constant for practical input sizes.
Space Complexity: 
ğ‘‚
(
ğ‘š
Ã—
ğ‘›
)
O(mÃ—n), as we are maintaining a Union-Find structure for each grid cell and a 2D grid to track the land and water cells.

'''
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # Path compression
        return self.parent[x]
    
    def union(self, x, y):
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX != rootY:
            # Union by rank
            if self.rank[rootX] > self.rank[rootY]:
                self.parent[rootY] = rootX
            elif self.rank[rootX] < self.rank[rootY]:
                self.parent[rootX] = rootY
            else:
                self.parent[rootY] = rootX
                self.rank[rootX] += 1
            return 1
        return 0
    
    def connected(self, x, y):
        return self.find(x) == self.find(y)

def numIslands2(m, n, positions):
    uf = UnionFind(m * n)
    grid = [[0] * n for _ in range(m)]  # Initialize the grid with water (0)
    result = []
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Up, Down, Left, Right
    
    def index(x, y):
        return x * n + y
    
    island_count = 0
    for i, j in positions:
        if grid[i][j] == 1:  # If land is already there, skip
            result.append(island_count)
            continue
        
        grid[i][j] = 1  # Mark as land
        island_count += 1
        
        # Try to union with all valid neighbors
        for dx, dy in directions:
            ni, nj = i + dx, j + dy
            if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == 1:
                if uf.union(index(i, j), index(ni, nj)) == 1:
                    island_count -= 1
        
        result.append(island_count)
    
    return result

# Example Usage
m = 3
n = 3
positions = [(0, 0), (0, 1), (1, 2), (2, 1), (1, 1), (2, 2)]
print(numIslands2(m, n, positions))


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 10 TODO :  making a large island
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/making-a-large-island-dsu-g-52/


https://leetcode.com/problems/making-a-large-island/



'''
# method 1 : brute force approch
''' 
Time Complexity: 
ğ‘‚
(
ğ‘›
Ã—
ğ‘š
)
O(nÃ—m), where 
ğ‘›
n and 
ğ‘š
m are the number of rows and columns in the grid. This is because:
The DFS for labeling islands takes 
ğ‘‚
(
ğ‘›
Ã—
ğ‘š
)
O(nÃ—m).
The loop for flipping each water cell and checking its neighbors takes 
ğ‘‚
(
ğ‘›
Ã—
ğ‘š
)
O(nÃ—m), and checking each neighbor requires constant time due to the use of a set.
Space Complexity: 
ğ‘‚
(
ğ‘›
Ã—
ğ‘š
)
O(nÃ—m), because we store the grid (which has size 
ğ‘›
Ã—
ğ‘š
nÃ—m), the island_sizes dictionary, and the visited cells during DFS.

'''
class Solution:
    def largestIsland(self, grid):
        m, n = len(grid), len(grid[0])
        
        # Direction vectors for 4 directions (left, right, up, down)
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        # Helper function to perform DFS
        def dfs(x, y, island_id):
            stack = [(x, y)]
            island_cells = []
            grid[x][y] = island_id  # Mark this cell as visited and assign an island ID
            island_cells.append((x, y))
            while stack:
                cx, cy = stack.pop()
                for dx, dy in directions:
                    nx, ny = cx + dx, cy + dy
                    if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:
                        grid[nx][ny] = island_id
                        island_cells.append((nx, ny))
                        stack.append((nx, ny))
            return island_cells
        
        island_id = 2  # Start island ID from 2 (because 0 and 1 are already used in the grid)
        island_sizes = {}
        
        # Step 1: Perform DFS to find all the islands and record their sizes
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:  # If it's land, we perform DFS to find the island
                    island_cells = dfs(i, j, island_id)
                    island_sizes[island_id] = len(island_cells)
                    island_id += 1
        
        # Step 2: Try flipping each water cell (0) and calculate the size of the largest island
        max_island_size = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 0:  # Only consider flipping water cells
                    neighbor_islands = set()
                    # Check the 4 directions to find neighboring islands
                    for dx, dy in directions:
                        nx, ny = i + dx, j + dy
                        if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] > 1:
                            neighbor_islands.add(grid[nx][ny])  # Add the island ID
                    # If we flip this water cell, we can combine all the neighboring islands
                    new_island_size = 1  # The flipped cell itself counts as land
                    for island_id in neighbor_islands:
                        new_island_size += island_sizes[island_id]
                    max_island_size = max(max_island_size, new_island_size)
        
        # Step 3: If no water cell is flipped, return the size of the largest island
        return max(max_island_size, max(island_sizes.values(), default=0))

# Example Usage
sol = Solution()
grid = [[1, 0], [0, 1]]
print(sol.largestIsland(grid))  # Output: 3


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 11 TODO : swim in rising water
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://leetcode.com/problems/swim-in-rising-water/

You are given an n x n grid where each cell represents the elevation at that point (i, j). Initially, you are at the top-left corner (0, 0), and you can only move to adjacent cells (up, down, left, right). The goal is to find the minimum time it takes to swim from the top-left to the bottom-right corner of the grid, where the water level rises with time. The water level rises at the same rate for every cell, and the elevation in the grid represents the time when the water reaches that level.

You need to determine the minimum time when you can swim from (0, 0) to (n-1, n-1) such that the path you take is not blocked by water rising faster than your movement.

'''
# method 1 : brute force approch
''' 
Time Complexity:

The heap operations (push and pop) are 
ğ‘‚
(
log
â¡
ğ‘˜
)
O(logk), where k is the number of cells (n^2).
In the worst case, we will push and pop all cells from the heap, so the total time complexity is 
ğ‘‚
(
ğ‘›
2
log
â¡
ğ‘›
2
)
=
ğ‘‚
(
ğ‘›
2
log
â¡
ğ‘›
)
O(n 
2
 logn 
2
 )=O(n 
2
 logn).
Space Complexity:

We store the grid (O(n^2)), the heap (O(n^2)), and the visited set (O(n^2)), making the space complexity 
ğ‘‚
(
ğ‘›
2
)
O(n 
2
 ).

'''
from heapq import heappop, heappush

class Solution:
    def swimInWater(self, grid):
        n = len(grid)
        
        # Directions: up, down, left, right
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        # Min-heap to store the elevation of the cells in order of increasing elevation
        heap = [(grid[0][0], 0, 0)]  # (elevation, row, col)
        
        # Set to track visited cells
        visited = set()
        visited.add((0, 0))
        
        # The time to reach the destination (bottom-right corner)
        time = 0
        
        while heap:
            elevation, x, y = heappop(heap)
            # Update the time (water level at current position)
            time = max(time, elevation)
            
            # If we reached the bottom-right corner, return the time
            if x == n - 1 and y == n - 1:
                return time
            
            # Explore the 4 possible directions
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:
                    visited.add((nx, ny))
                    heappush(heap, (grid[nx][ny], nx, ny))
        
        return time

# Example Usage
sol = Solution()
grid = [[0, 2, 4], [3, 2, 1], [1, 0, 0]]
print(sol.swimInWater(grid))  # Output: 3


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# endregion





# region 15.6 GRAPHS - OTHER ALGORITHMS
# -------------------------------------

# 1 TODO :  bridges in graph
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/graph/bridges-in-graph-using-tarjans-algorithm-of-time-in-and-low-time-g-55/


https://leetcode.com/problems/critical-connections-in-a-network/discuss/382385/find-bridges-in-a-graph

In graph theory, a bridge (also known as a cut-edge) is an edge in a graph whose removal increases the number of connected components. Essentially, it's an edge that, if removed, would disconnect the graph. A common problem is to find all such bridges in an undirected graph.
'''
# method 1 : brute force approch
''' 
Time Complexity:

We perform DFS once for each vertex and edge. Each DFS call takes 
ğ‘‚
(
ğ‘‰
+
ğ¸
)
O(V+E), where V is the number of vertices and E is the number of edges.
Overall time complexity: 
ğ‘‚
(
ğ‘‰
+
ğ¸
)
O(V+E).
Space Complexity:

We store the graph using an adjacency list, and use arrays for visited status, discovery time, low values, and parents. The space complexity is 
ğ‘‚
(
ğ‘‰
+
ğ¸
)
O(V+E).

'''
class Solution:
    def __init__(self):
        self.time = 0  # Global time counter for DFS
        self.bridges = []  # List to store bridges
        self.visited = []
        self.parent = []
        self.low = []
        self.disc = []
    
    def dfs(self, graph, u):
        """ Helper function to perform DFS and find bridges """
        # Set discovery time and low value for u
        self.visited[u] = True
        self.disc[u] = self.low[u] = self.time
        self.time += 1
        
        # Recur for all the vertices adjacent to u
        for v in graph[u]:
            if not self.visited[v]:
                self.parent[v] = u
                self.dfs(graph, v)
                
                # Check if the subtree rooted at v has a back connection to one of the ancestors of u
                self.low[u] = min(self.low[u], self.low[v])
                
                # If the lowest vertex reachable from v is below u in DFS tree, then (u, v) is a bridge
                if self.low[v] > self.disc[u]:
                    self.bridges.append((u, v))
            
            elif v != self.parent[u]:  # A back edge (ignore the parent edge)
                self.low[u] = min(self.low[u], self.disc[v])
    
    def findBridges(self, n, edges):
        # Build the graph
        graph = [[] for _ in range(n)]
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        # Initialize the arrays
        self.visited = [False] * n
        self.parent = [-1] * n
        self.low = [-1] * n
        self.disc = [-1] * n
        
        # Call the DFS helper function for each unvisited vertex
        for i in range(n):
            if not self.visited[i]:
                self.dfs(graph, i)
        
        # Return the list of bridges
        return self.bridges

# Example Usage
sol = Solution()
n = 5  # Number of vertices
edges = [
    (0, 1), (0, 2), (1, 2), (1, 3), (3, 4)
]  # List of edges (u, v)
bridges = sol.findBridges(n, edges)
print("Bridges:", bridges)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : articulation point
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/articulation-point-in-graph-g-56/



https://bit.ly/3T2LPKu

An articulation point (also known as a cut vertex) in a graph is a vertex that, when removed, increases the number of connected components. Essentially, it's a vertex that, if removed, would disconnect the graph. The task is to find all such articulation points in an undirected graph.

We can efficiently solve this problem using DFS (Depth-First Search) and Tarjan's Algorithm.

'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution  (Tarjan's Algorithm)
''' 
Time Complexity:

The algorithm performs a DFS traversal over the graph, visiting each vertex and edge once.
Therefore, the time complexity is 
ğ‘‚
(
ğ‘‰
+
ğ¸
)
O(V+E), where V is the number of vertices and E is the number of edges.
Space Complexity:

We use arrays to store the graph, visited status, discovery times, low values, parent information, and articulation points.
The space complexity is 
ğ‘‚
(
ğ‘‰
+
ğ¸
)
O(V+E), where V is the number of vertices and E is the number of edges.

'''
class Solution:
    def __init__(self):
        self.time = 0  # Global time counter for DFS
        self.articulation_points = set()  # Set to store articulation points
        self.visited = []
        self.parent = []
        self.low = []
        self.disc = []
        self.children = []
    
    def dfs(self, graph, u):
        """ Helper function to perform DFS and find articulation points """
        self.visited[u] = True
        self.disc[u] = self.low[u] = self.time
        self.time += 1
        child_count = 0
        
        for v in graph[u]:
            if not self.visited[v]:
                self.parent[v] = u
                child_count += 1
                self.dfs(graph, v)
                
                # Check if the subtree rooted at v has a back connection to one of the ancestors of u
                self.low[u] = min(self.low[u], self.low[v])
                
                # Condition 1: u is root and has two or more children in DFS tree
                if self.parent[u] == -1 and child_count > 1:
                    self.articulation_points.add(u)
                
                # Condition 2: u is not root and low value of one of its child is more
                if self.parent[u] != -1 and self.low[v] >= self.disc[u]:
                    self.articulation_points.add(u)
            
            elif v != self.parent[u]:  # A back edge (ignore the parent edge)
                self.low[u] = min(self.low[u], self.disc[v])
    
    def findArticulationPoints(self, n, edges):
        # Build the graph
        graph = [[] for _ in range(n)]
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        # Initialize the arrays
        self.visited = [False] * n
        self.parent = [-1] * n
        self.low = [-1] * n
        self.disc = [-1] * n
        
        # Call the DFS helper function for each unvisited vertex
        for i in range(n):
            if not self.visited[i]:
                self.dfs(graph, i)
        
        # Return the list of articulation points
        return list(self.articulation_points)

# Example Usage
sol = Solution()
n = 5  # Number of vertices
edges = [
    (0, 1), (0, 2), (1, 2), (1, 3), (3, 4)
]  # List of edges (u, v)
articulation_points = sol.findArticulationPoints(n, edges)
print("Articulation Points:", articulation_points)


# 3 TODO : kosaraju's algorithm
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/graph/strongly-connected-components-kosarajus-algorithm-g-54/


https://bit.ly/3TbvByL

Kosaraju's algorithm is an efficient algorithm used to find all strongly connected components (SCCs) in a directed graph. A strongly connected component is a maximal subgraph in which any two vertices are reachable from one another. Kosaraju's algorithm uses two depth-first search (DFS) traversals and a reverse graph to find SCCs.

'''
# method 1 : brute force approch
''' 
Time Complexity:
The graph traversal and DFS operations each run in 
ğ‘‚
(
ğ‘‰
+
ğ¸
)
O(V+E), where 
ğ‘‰
V is the number of vertices and 
ğ¸
E is the number of edges. Therefore, the total time complexity is 
ğ‘‚
(
ğ‘‰
+
ğ¸
)
O(V+E).
Space Complexity:
We store the original graph, the transposed graph, the visited list, and the stack. The space complexity is 
ğ‘‚
(
ğ‘‰
+
ğ¸
)
O(V+E), as we need space for the graph representation and auxiliary arrays.
'''
class Kosaraju:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = [[] for _ in range(vertices)]  # Graph
        self.transposed_graph = [[] for _ in range(vertices)]  # Transposed Graph

    def add_edge(self, u, v):
        self.graph[u].append(v)
        self.transposed_graph[v].append(u)

    def dfs(self, v, visited, graph):
        """ Helper DFS function """
        visited[v] = True
        for neighbor in graph[v]:
            if not visited[neighbor]:
                self.dfs(neighbor, visited, graph)

    def fill_order(self, v, visited, stack):
        """ DFS to fill vertices in stack based on their finishing time """
        visited[v] = True
        for neighbor in self.graph[v]:
            if not visited[neighbor]:
                self.fill_order(neighbor, visited, stack)
        stack.append(v)

    def kosaraju(self):
        stack = []
        visited = [False] * self.V
        
        # 1st DFS - Fill vertices in stack according to their finishing times
        for i in range(self.V):
            if not visited[i]:
                self.fill_order(i, visited, stack)

        # 2nd DFS - Transpose the graph and do DFS based on stack order
        visited = [False] * self.V
        sccs = []

        while stack:
            v = stack.pop()
            if not visited[v]:
                # Store the SCC for the current DFS traversal
                scc = []
                self.dfs(v, visited, self.transposed_graph)
                sccs.append(scc)
        
        return sccs


# Example usage
kosaraju = Kosaraju(5)
kosaraju.add_edge(0, 1)
kosaraju.add_edge(1, 2)
kosaraju.add_edge(2, 0)
kosaraju.add_edge(1, 3)
kosaraju.add_edge(3, 4)

sccs = kosaraju.kosaraju()
print("Strongly Connected Components:", sccs)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      




# endregion






# region 16.1 DP - INTRODUCTION
# -----------------------------
# 1 TODO :  dynamic programming introduction
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://takeuforward.org/data-structure/dynamic-programming-introduction/


https://bit.ly/3UWkWrS


https://www.youtube.com/watch?v=EgG3jsGoPvQ&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=182
'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''
def f(n):
    if n <= 1:
        return n
    return f(n-1) + f(n-2)

if __name__ == "__main__":
    n = 5
    print(f(n)) 

# method 1 : memoization
'''
Time Complexity: O(N)

Reason: The overlapping subproblems will return the answer in constant time O(1). Therefore the total number of new subproblems we solve is â€˜nâ€™. Hence total time complexity is O(N).

Space Complexity: O(N)

Reason: We are using a recursion stack space(O(N)) and an array (again O(N)). Therefore total space complexity will be O(N) + O(N) â‰ˆ O(N)
'''
def f(n, dp):
    if n <= 1:
        return n
    
    if dp[n] != -1:
        return dp[n]
    dp[n] = f(n-1, dp) + f(n-2, dp)
    return dp[n]

if __name__ == "__main__":
    n = 5
    dp = [-1] * (n+1)
    print(f(n, dp)) 


# method 2 tabulation
'''
Time Complexity: O(N)

Reason: We are running a simple iterative loop

Space Complexity: O(N)

Reason: We are using an external array of size â€˜n+1â€™.
'''
from typing import List

def main():
    n = 5
    dp = [-1]*(n+1)

    dp[0] = 0
    dp[1] = 1

    for i in range(2, n+1):
        dp[i] = dp[i-1] + dp[i-2]
    
    print(dp[n])


# method 3 space optimization
'''
Time Complexity: O(N)

Reason: We are running a simple iterative loop

Space Complexity: O(1)

Reason: We are not using any extra space
'''
def main():
    n = 5
    prev2 = 0
    prev = 1

    for i in range(2, n+1):
        cur_i = prev2 + prev
        prev2 = prev
        prev = cur_i
    print(prev)

if __name__ == "__main__":
    main()


# endregion





# region 16.2 DP - 1D
# -------------------
# 1 TODO :  climbing stars, count ways to reach the N-th stairs
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://takeuforward.org/data-structure/dynamic-programming-climbing-stairs/


https://leetcode.com/problems/climbing-stairs/
https://www.youtube.com/watch?v=EgG3jsGoPvQ&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=183
'''
# method 1 : memoization
# TC     -      
# SC     -   

# method 2 : tabulation
'''
Time Complexity: O(N)

Reason: We are running a simple iterative loop

Space Complexity: O(N)

Reason: We are using an external array of size â€˜n+1â€™.
'''
def main():
    n = 3
    dp = [-1] * (n + 1)
    dp[0] = 1
    dp[1] = 1

    for i in range(2, n+1):
      dp[i] = dp[i-1] + dp[i-2]
    print(dp[n])


if __name__ == "__main__":
    main()  


# method 3 : space optimization
'''
Time Complexity: O(N)

Reason: We are running a simple iterative loop

Space Complexity: O(1)

Reason: We are not using any extra space.
'''
def main():
    n = 3
    prev2 = 1
    prev = 1

    for i in range(2, n+1):
        cur_i = prev2 + prev
        prev2 = prev
        prev = cur_i

    print(prev)

if __name__ == "__main__":
    main()   


# 2 TODO : frog jump (DP -3)
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://takeuforward.org/data-structure/dynamic-programming-frog-jump-dp-3/


https://bit.ly/3Xn0Kkw
https://www.youtube.com/watch?v=EgG3jsGoPvQ&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=184
'''


# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''
import sys
import math

def solve(ind, height):
    if ind == 0:
        return 0
    jumpTwo = sys.maxsize
    jumpOne = solve(ind-1, height) + abs(height[ind] - height[ind-1])
    if ind > 1:
        jumpTwo = solve(ind-2, height) + abs(height[ind] - height[ind-2])
    return min(jumpOne, jumpTwo)

if __name__ == "__main__":
    height = [30, 10, 60, 10, 60, 50]
    n = len(height)
    print(solve(n-1, height))

# method 1 : memoization
'''
Time Complexity: O(N)

Reason: The overlapping subproblems will return the answer in constant time O(1). Therefore the total number of new subproblems we solve is â€˜nâ€™. Hence total time complexity is O(N).

Space Complexity: O(N)

Reason: We are using a recursion stack space(O(N)) and an array (again O(N)). Therefore total space complexity will be O(N) + O(N) â‰ˆ O(N)
'''
import sys
import math

def solve(ind, height, dp):
    if ind == 0:
        return 0
    if dp[ind] != -1:
        return dp[ind]
    jumpTwo = sys.maxsize
    jumpOne = solve(ind-1, height, dp) + abs(height[ind] - height[ind-1])
    if ind > 1:
        jumpTwo = solve(ind-2, height, dp) + abs(height[ind] - height[ind-2])
    dp[ind] = min(jumpOne, jumpTwo)
    return dp[ind]

if __name__ == "__main__":
    height = [30, 10, 60, 10, 60, 50]
    n = len(height)
    dp = [-1] * n
    print(solve(n-1, height, dp))


# method 2 : tabulation
'''
Time Complexity: O(N)

Reason: We are running a simple iterative loop

Space Complexity: O(N)

Reason: We are using an external array of size â€˜n+1â€™.
'''
def main():
    height = [30, 10, 60, 10, 60, 50]
    n = len(height)
    dp = [-1 for _ in range(n)]
    dp[0] = 0
    for ind in range(1, n):
        jumpTwo = float('inf')
        jumpOne = dp[ind-1] + abs(height[ind]-height[ind-1])
        if ind > 1:
            jumpTwo = dp[ind-2] + abs(height[ind]-height[ind-2])
        dp[ind] = min(jumpOne, jumpTwo)
    print(dp[n-1])

if __name__ == "__main__":
    main()

    


# method 3 : space optimization
'''
Time Complexity: O(N)

Reason: We are running a simple iterative loop

Space Complexity: O(1)

Reason: We are not using any extra space.
'''
import sys
def main():
    height = [30, 10, 60, 10, 60, 50]
    n = len(height)
    prev = 0
    prev2 = 0
    for i in range(1, n):
        jumpTwo = sys.maxsize
        jumpOne = prev + abs(height[i] - height[i - 1])
        if i > 1:
            jumpTwo = prev2 + abs(height[i] - height[i - 2])

        cur_i = min(jumpOne, jumpTwo)
        prev2 = prev
        prev = cur_i

    print(prev)

if __name__ == "__main__":
    main()


# 3 TODO : frog jump with k distances(DP - 4)
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/dynamic-programming-frog-jump-with-k-distances-dp-4/


https://bit.ly/3GyNRya


https://www.youtube.com/watch?v=Kmh3rhyEtB8&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=185
'''


# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''
import sys

# Recursive function to calculate the minimum cost to reach the end
# from a given index with at most 'k' jumps.
def solveUtil(ind, height, k):
    # Base case: If we are at the beginning (index 0), no cost is needed.
    if ind == 0:
        return 0

    mmSteps = sys.maxsize

    # Loop to try all possible jumps from '1' to 'k'
    for j in range(1, k + 1):
        # Ensure that we do not jump beyond the beginning of the array
        if ind - j >= 0:
            # Calculate the cost for this jump and update mmSteps with the minimum cost
            jump = solveUtil(ind - j, height, k) + abs(height[ind] - height[ind - j])
            mmSteps = min(jump, mmSteps)
    return mmSteps

# Function to find the minimum cost to reach the end of the array
def solve(n, height, k):
    return solveUtil(n - 1, height, k)  # Start the recursion from the last index

def main():
    height = [30, 10, 60, 10, 60, 50]
    n = len(height)
    k = 2
    print(solve(n, height, k))  # Print the result of the solve function

if __name__ == "__main__":
    main()

# method 1 : memoization
'''
Time Complexity: O(N *K)

Reason: The overlapping subproblems will return the answer in constant time. Therefore the total number of new subproblems we solve is â€˜nâ€™. At every new subproblem, we are running another loop for K times. Hence total time complexity is O(N * K).

Space Complexity: O(N)

Reason: We are using a recursion stack space(O(N)) and an array (again O(N)). Therefore total space complexity will be O(N) + O(N) â‰ˆ O(N)
'''
import sys

# Recursive function to calculate the minimum cost to reach the end
# from a given index with at most 'k' jumps.
def solveUtil(ind, height, dp, k):
    # Base case: If we are at the beginning (index 0), no cost is needed.
    if ind == 0:
        return 0
    # If the result for this index has been previously calculated, return it.
    if dp[ind] != -1:
        return dp[ind]

    mmSteps = sys.maxsize

    # Loop to try all possible jumps from '1' to 'k'
    for j in range(1, k + 1):
        # Ensure that we do not jump beyond the beginning of the array
        if ind - j >= 0:
            # Calculate the cost for this jump and update mmSteps with the minimum cost
            jump = solveUtil(ind - j, height, dp, k) + abs(height[ind] - height[ind - j])
            mmSteps = min(jump, mmSteps)

    # Store the minimum cost for this index in the dp array and return it.
    dp[ind] = mmSteps
    return dp[ind]

# Function to find the minimum cost to reach the end of the array
def solve(n, height, k):
    dp = [-1] * n  # Initialize a memoization array to store calculated results
    return solveUtil(n - 1, height, dp, k)  # Start the recursion from the last index

def main():
    height = [30, 10, 60, 10, 60, 50]
    n = len(height)
    k = 2
    print(solve(n, height, k))  # Print the result of the solve function

if __name__ == "__main__":
    main()


# method 2 : tabulation 
'''
Time Complexity: O(N*K)

Reason: We are running two nested loops, where outer loops run from 1 to n-1 and the inner loop runs from 1 to K

Space Complexity: O(N)

Reason: We are using an external array of size â€˜nâ€™â€™.
'''
import sys

# Helper function to solve the problem using dynamic programming
def solve_util(n, height, dp, k):
    # Initialize the first element of the dp array as 0 since no steps are needed to reach the first position
    dp[0] = 0

    # Loop through the elements of the height array
    for i in range(1, n):
        mmSteps = sys.maxsize  # Initialize the minimum steps to a large value
        for j in range(1, k+1):
            if i - j >= 0:
                # Calculate the number of steps required to reach the current position from the previous positions
                jump = dp[i - j] + abs(height[i] - height[i - j])
                mmSteps = min(jump, mmSteps)  # Update the minimum steps
        dp[i] = mmSteps  # Store the minimum steps needed to reach the current position

    return dp[n-1]  # Return the minimum steps needed to reach the last position

# Main function to solve the problem
def solve(n, height, k):
    dp = [-sys.maxsize] * n  # Initialize a dp array with large negative values
    return solve_util(n, height, dp, k)  # Call the helper function

# Entry point of the program
def main():
    height = [30, 10, 60, 10, 60, 50]
    n = len(height)
    k = 2
    dp = [-sys.maxsize] * n  # Initialize dp array
    result = solve(n, height, k)  # Call the solve function
    print(result)  # Print the result

if __name__ == "__main__":
    main()




# method 3 : space optimization
# TC     -      
# SC     -      


# 4 TODO : house robber, maximum sum of non-adjacent elements (DP-5)
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/maximum-sum-of-non-adjacent-elements-dp-5/


https://leetcode.com/problems/house-robber/

https://www.youtube.com/watch?v=Kmh3rhyEtB8&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=186
'''


# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''
def solveUtil(ind, arr):
    
    # Base case: when the index is 0, return the value at that index
    if ind == 0:
        return arr[ind]
    
    # Base case: when the index is negative, return 0 (out of bounds)
    if ind < 0:
        return 0
    
    # Calculate the maximum value when picking the current element
    pick = arr[ind] + solveUtil(ind - 2, arr)
    
    # Calculate the maximum value when not picking the current element
    nonPick = 0 + solveUtil(ind - 1, arr)
    
    # Return the maximum value for the current index
    return max(pick, nonPick)

# Function to solve the problem for the given array
def solve(n, arr):
    
    # Call the recursive utility function to find the maximum value
    return solveUtil(n - 1, arr)

# Main function to test the code
def main():
    arr = [2, 1, 4, 9]
    n = len(arr)
    
    # Call the solve function and print the result
    print(solve(n, arr))

if __name__ == '__main__':
    main()

# method 1 : memoization
'''
Time Complexity: O(N)

Reason: The overlapping subproblems will return the answer in constant time O(1). Therefore the total number of new subproblems we solve is â€˜nâ€™. Hence total time complexity is O(N).

Space Complexity: O(N)

Reason: We are using a recursion stack space(O(N)) and an array (again O(N)). Therefore total space complexity will be O(N) + O(N) â‰ˆ O(N)
'''
# Function to solve the problem using dynamic programming
def solveUtil(ind, arr, dp):
    # Check if the solution for this index has already been calculated
    if dp[ind] != -1:
        return dp[ind]
    
    # Base case: when the index is 0, return the value at that index
    if ind == 0:
        return arr[ind]
    
    # Base case: when the index is negative, return 0 (out of bounds)
    if ind < 0:
        return 0
    
    # Calculate the maximum value when picking the current element
    pick = arr[ind] + solveUtil(ind - 2, arr, dp)
    
    # Calculate the maximum value when not picking the current element
    nonPick = 0 + solveUtil(ind - 1, arr, dp)
    
    # Store the maximum of the two choices in the DP table
    dp[ind] = max(pick, nonPick)
    
    # Return the maximum value for the current index
    return dp[ind]

# Function to solve the problem for the given array
def solve(n, arr):
    # Initialize a DP table with -1 values to store intermediate results
    dp = [-1 for i in range(n)]
    
    # Call the recursive utility function to find the maximum value
    return solveUtil(n - 1, arr, dp)

# Main function to test the code
def main():
    arr = [2, 1, 4, 9]
    n = len(arr)
    
    # Call the solve function and print the result
    print(solve(n, arr))

if __name__ == '__main__':
    main()

 


# method 2 : better approch
'''
Time Complexity: O(N)

Reason: We are running a simple iterative loop

Space Complexity: O(N)

Reason: We are using an external array of size â€˜n+1â€™.
'''
# Function to solve the problem using dynamic programming
def solveUtil(n, arr, dp):
    # Initialize the first element of the DP table with the first element of the array
    dp[0] = arr[0]
    
    # Loop through the array starting from the second element
    for i in range(1, n):
        # Calculate the maximum value when picking the current element
        pick = arr[i]
        
        # Check if there are at least two elements before the current element
        if i > 1:
            pick += dp[i - 2]
        
        # Calculate the maximum value when not picking the current element
        non_pick = 0 + dp[i - 1]
        
        # Store the maximum of the two choices in the DP table
        dp[i] = max(pick, non_pick)
    
    # Return the maximum value for the last index
    return dp[n - 1]

# Function to solve the problem for the given array
def solve(n, arr):
    # Initialize a DP table with -1 values to store intermediate results
    dp = [-1 for _ in range(n)]
    
    # Call the solveUtil function to find the maximum value
    return solveUtil(n, arr, dp)

# Main function to test the code
def main():
    arr = [2, 1, 4, 9]
    n = len(arr)
    
    # Call the solve function and print the result
    print(solve(n, arr))

if __name__ == '__main__':
    main()




# method 3 : optimal solution
'''
Time Complexity: O(N)

Reason: We are running a simple iterative loop

Space Complexity: O(1)

Reason: We are not using any extra space.
'''
# Function to solve the problem of finding the maximum sum of non-adjacent elements in an array
def solve(n, arr):
    # Initialize variables to keep track of the previous maximum and the one before that
    prev = arr[0]  # Initialize with the first element of the array
    prev2 = 0      # Initialize with 0 because there is no element before the first
    
    # Loop through the array starting from the second element
    for i in range(1, n):
        # Calculate the maximum value when picking the current element
        pick = arr[i]
        
        # Check if there are at least two elements before the current element
        if i > 1:
            pick += prev2
        
        # Calculate the maximum value when not picking the current element
        non_pick = 0 + prev
        
        # Calculate the maximum value for the current index
        cur_i = max(pick, non_pick)
        
        # Update the 'prev' and 'prev2' variables for the next iteration
        prev2 = prev
        prev = cur_i
    
    # Return the maximum value for the last index, which represents the solution
    return prev

# Main function to test the code
def main():
    arr = [2, 1, 4, 9]
    n = len(arr)
    
    # Call the solve function and print the result
    print(solve(n, arr))

if __name__ == "__main__":
    main()



# 5 TODO : house robber (DP-6)
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://takeuforward.org/data-structure/dynamic-programming-house-robber-dp-6/


https://leetcode.com/problems/house-robber-ii/


'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
# TC     -      
# SC     -     


# method 2 : tabulation
# TC     -      
# SC     -     


# method 3 : space optimization
'''
Time Complexity: O(N )

Reason: We are running a simple iterative loop, two times. Therefore total time complexity will be O(N) + O(N) â‰ˆ O(N)

Space Complexity: O(1)

Reason: We are not using extra space.
'''
def solve(arr):
    n = len(arr)
    prev = arr[0]
    prev2 = 0

    for i in range(1, n):
        pick = arr[i]
        if i > 1:
            pick += prev2
        nonPick = 0 + prev

        cur_i = max(pick, nonPick)
        prev2 = prev
        prev = cur_i

    return prev

def robStreet(n, arr):
    arr1 = []
    arr2 = []

    if n == 1:
        return arr[0]

    for i in range(n):
        if i != 0:
            arr1.append(arr[i])
        if i != n - 1:
            arr2.append(arr[i])

    ans1 = solve(arr1)
    ans2 = solve(arr2)

    return max(ans1, ans2)

def main():
    arr = [1, 5, 1, 2, 6]
    n = len(arr)
    print(robStreet(n, arr))

if __name__ == '__main__':
    main()   




# endregion




# region 16.3 DP - 2D/3D/GRIDS
# ----------------------------
# 1 TODO :  ninjas's training (Dp-7)
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/dynamic-programming-ninjas-training-dp-7/


https://bit.ly/3glc9kp

https://www.youtube.com/watch?v=AE39gJYuRog&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=188
'''


# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''
def f(day, last, points):

    # Base case: When we reach day 0, return the maximum point for the last day.
    if day == 0:
        maxi = 0
        for i in range(3):
            if i != last:
                maxi = max(maxi, points[0][i])
        return maxi

    maxi = 0
    # Iterate through all activities for the current day.
    for i in range(3):
        if i != last:
            # Calculate the total points for the current day's activity and recursively call for the previous day.
            activity = points[day][i] + f(day - 1, i, points)
            maxi = max(maxi, activity)
    return maxi

def ninjaTraining(n, points):

    # Start the recursive function from the last day with no previous activity.
    return f(n - 1, 3, points)

def main():
    # Define the points matrix for each day.
    points = [[10, 40, 70],
              [20, 50, 80],
              [30, 60, 90]]

    n = len(points)  # Get the number of days.
    # Call the ninjaTraining function to find the maximum points.
    print(ninjaTraining(n, points))

if __name__ == '__main__':
    main()

# method 1 : memoization
'''
Time Complexity: O(N*4*3)

Reason: There are N*4 states and for every state, we are running a for loop iterating three times.

Space Complexity: O(N) + O(N*4)

Reason: We are using a recursion stack space(O(N)) and a 2D array (again O(N*4)). Therefore total space complexity will be O(N) + O(N) â‰ˆ O(N)
'''
def f(day, last, points, dp):
    # Check if the result for this day and last activity is already computed.
    if dp[day][last] != -1:
        return dp[day][last]

    # Base case: When we reach day 0, return the maximum point for the last day.
    if day == 0:
        maxi = 0
        for i in range(3):
            if i != last:
                maxi = max(maxi, points[0][i])
        dp[day][last] = maxi
        return dp[day][last]

    maxi = 0
    # Iterate through all activities for the current day.
    for i in range(3):
        if i != last:
            # Calculate the total points for the current day's activity and recursively call for the previous day.
            activity = points[day][i] + f(day - 1, i, points, dp)
            maxi = max(maxi, activity)

    # Store the maximum points in the DP table and return it.
    dp[day][last] = maxi
    return dp[day][last]

def ninjaTraining(n, points):
    # Initialize a DP table to store the computed results.
    dp = [[-1 for j in range(4)] for i in range(n)]
    # Start the recursive function from the last day with no previous activity.
    return f(n - 1, 3, points, dp)

def main():
    # Define the points matrix for each day.
    points = [[10, 40, 70],
              [20, 50, 80],
              [30, 60, 90]]

    n = len(points)  # Get the number of days.
    # Call the ninjaTraining function to find the maximum points.
    print(ninjaTraining(n, points))

if __name__ == '__main__':
    main()



# method 2 : tabulation
Time Complexity: O(N*4*3)

Reason: There are three nested loops

Space Complexity: O(N*4)

Reason: We are using an external array of size â€˜N*4â€™â€™.

def ninjaTraining(n, points):
    # Initialize a DP table with dimensions (n x 4) to store the maximum points.
    dp = [[0 for j in range(4)] for i in range(n)]

    # Initialize the DP table for day 0 with base cases.
    dp[0][0] = max(points[0][1], points[0][2])
    dp[0][1] = max(points[0][0], points[0][2])
    dp[0][2] = max(points[0][0], points[0][1])
    dp[0][3] = max(points[0][0], max(points[0][1], points[0][2]))

    # Loop through the days starting from the second day.
    for day in range(1, n):
        for last in range(4):
            dp[day][last] = 0  # Initialize the maximum points for the current day and last activity.
            for task in range(3):
                if task != last:
                    # Calculate the total points for the current day's activity and the previous day's maximum points.
                    activity = points[day][task] + dp[day - 1][task]
                    dp[day][last] = max(dp[day][last], activity)

    # Return the maximum points achievable after the last day with any activity.
    return dp[n - 1][3]

def main():
    # Define the points matrix for each day.
    points = [[10, 40, 70],
              [20, 50, 80],
              [30, 60, 90]]
    n = len(points)  # Get the number of days.
    # Call the ninjaTraining function to find the maximum points.
    print(ninjaTraining(n, points))

if __name__ == '__main__':
    main()




# method 3 : space optimization
Time Complexity: O(N*4*3)

Reason: There are three nested loops

Space Complexity: O(4)

Reason: We are using an external array of size â€˜4â€™ to store only one row.

def ninjaTraining(n, points):
    # Initialize a list 'prev' to store the maximum points for each possible last activity on the previous day.
    prev = [0] * 4

    # Initialize 'prev' with the maximum points for the first day's activities.
    prev[0] = max(points[0][1], points[0][2])
    prev[1] = max(points[0][0], points[0][2])
    prev[2] = max(points[0][0], points[0][1])
    prev[3] = max(points[0][0], max(points[0][1], points[0][2]))

    # Loop through the days starting from the second day.
    for day in range(1, n):
        # Initialize a temporary list 'temp' to store the maximum points for each possible last activity on the current day.
        temp = [0] * 4

        for last in range(4):
            # Initialize 'temp' for the current last activity.
            temp[last] = 0

            for task in range(3):
                if task != last:
                    # Calculate the total points for the current day's activity and the previous day's maximum points.
                    activity = points[day][task] + prev[task]
                    # Update 'temp' with the maximum points for the current last activity.
                    temp[last] = max(temp[last], activity)

        # Update 'prev' with 'temp' for the next iteration.
        prev = temp

    # Return the maximum points achievable after the last day with any activity.
    return prev[3]

def main():
    # Define the points matrix for each day.
    points = [[10, 40, 70],
              [20, 50, 80],
              [30, 60, 90]]
    n = len(points)  # Get the number of days.
    # Call the ninjaTraining function to find and print the maximum points.
    print(ninjaTraining(n, points))

if __name__ == '__main__':
    main()

 


# 2 TODO : grid unique paths : DP on grids (DP-8)
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/grid-unique-paths-dp-on-grids-dp8/


https://leetcode.com/problems/unique-paths/


https://www.youtube.com/watch?v=sdE0A2Oxofw&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=189
'''


# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''
def countWaysUtil(i, j):
    # Base case: If we reach the top-left corner (i=0, j=0), there is one way to reach there.
    if i == 0 and j == 0:
        return 1
    # If either i or j goes out of bounds (negative), there is no way to reach that cell.
    if i < 0 or j < 0:
        return 0
    
    # Recursive calls to count the number of ways to reach the current cell.
    up = countWaysUtil(i - 1, j)    # Moving up one row.
    left = countWaysUtil(i, j - 1)  # Moving left one column.

    return up + left

def countWays(m, n):
    
    # Call the utility function to compute the number of ways to reach the bottom-right cell (m-1, n-1).
    return countWaysUtil(m - 1, n - 1)

def main():
    m = 3
    n = 2
    # Call the countWays function to calculate and print the number of ways to reach the destination.
    print(countWays(m, n))

if __name__ == '__main__':
    main()


# method 1 : memoization
'''
Time Complexity: O(M*N)

Reason: At max, there will be M*N calls of recursion.

Space Complexity: O((N-1)+(M-1)) + O(M*N)

Reason: We are using a recursion stack space: O((N-1)+(M-1)), here (N-1)+(M-1) is the path length and an external DP Array of size â€˜M*Nâ€™.
'''
def countWaysUtil(i, j, dp):
    # Base case: If we reach the top-left corner (i=0, j=0), there is one way to reach there.
    if i == 0 and j == 0:
        return 1
    # If either i or j goes out of bounds (negative), there is no way to reach that cell.
    if i < 0 or j < 0:
        return 0
    # If we have already calculated the number of ways for this cell, return it from the dp array.
    if dp[i][j] != -1:
        return dp[i][j]
    
    # Recursive calls to count the number of ways to reach the current cell.
    up = countWaysUtil(i - 1, j, dp)    # Moving up one row.
    left = countWaysUtil(i, j - 1, dp)  # Moving left one column.
    
    # Store the result in the dp array and return it.
    dp[i][j] = up + left
    return dp[i][j]

def countWays(m, n):
    # Initialize a memoization (dp) array to store intermediate results.
    dp = [[-1 for j in range(n)] for i in range(m)]
    
    # Call the utility function to compute the number of ways to reach the bottom-right cell (m-1, n-1).
    return countWaysUtil(m - 1, n - 1, dp)

def main():
    m = 3
    n = 2
    # Call the countWays function to calculate and print the number of ways to reach the destination.
    print(countWays(m, n))

if __name__ == '__main__':
    main()




# method 2 : tabulation
'''
Time Complexity: O(M*N)

Reason: There are two nested loops

Space Complexity: O(M*N)

Reason: We are using an external array of size â€˜M*Nâ€™â€™.
'''
def countWaysUtil(m, n, dp):
    # Loop through each cell in the grid
    for i in range(m):
        for j in range(n):
            # Base condition: If we are at the top-left corner, there is one way to reach it.
            if i == 0 and j == 0:
                dp[i][j] = 1
                continue
            
            # Initialize variables to store the number of ways from above and from the left.
            up = 0
            left = 0
            
            # Check if moving up is a valid option (not out of bounds).
            if i > 0:
                up = dp[i - 1][j]
            
            # Check if moving left is a valid option (not out of bounds).
            if j > 0:
                left = dp[i][j - 1]
            
            # Calculate and store the number of ways to reach the current cell.
            dp[i][j] = up + left
    
    # The bottom-right cell (m-1, n-1) now contains the total number of ways to reach there.
    return dp[m - 1][n - 1]

def countWays(m, n):
    # Initialize a memoization (dp) array to store intermediate results.
    dp = [[-1 for j in range(n)] for i in range(m)]
    
    # Call the utility function to compute the number of ways to reach the destination.
    return countWaysUtil(m, n, dp)

def main():
    m = 3
    n = 2
    # Call the countWays function to calculate and print the number of ways to reach the destination.
    print(countWays(m, n))

if __name__ == '__main__':
    main()



# method 3 : space optimization
'''
Time Complexity: O(M*N)

Reason: There are two nested loops

Space Complexity: O(N)

Reason: We are using an external array of size â€˜Nâ€™ to store only one row.
'''
def countWays(m, n):
    # Initialize a previous row to store intermediate results.
    prev = [0] * n

    # Loop through each row of the grid.
    for i in range(m):
        # Initialize a temporary row to store current row results.
        temp = [0] * n
        
        # Loop through each column of the grid.
        for j in range(n):
            # Base case: If we are at the top-left corner, there is one way to reach it.
            if i == 0 and j == 0:
                temp[j] = 1
                continue
            
            # Initialize variables to store the number of ways from above and from the left.
            up = 0
            left = 0
            
            # Check if moving up is a valid option (not out of bounds).
            if i > 0:
                up = prev[j]
            
            # Check if moving left is a valid option (not out of bounds).
            if j > 0:
                left = temp[j - 1]
                
            # Calculate and store the number of ways to reach the current cell.
            temp[j] = up + left
        
        # Update the previous row with the current row results.
        prev = temp
    
    # The last element in the previous row (prev) now contains the total number of ways to reach the destination.
    return prev[n - 1]

def main():
    m = 3
    n = 2
    # Call the countWays function to calculate and print the number of ways to reach the destination.
    print(countWays(m, n))

if __name__ == '__main__':
    main()




# 3 TODO : maze obstacles, grid unique paths 2 (DP - 9)
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/grid-unique-paths-2-dp-9/


https://leetcode.com/problems/unique-paths-ii/

https://www.youtube.com/watch?v=TmhpgXScLyY&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=190
'''


# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''
def mazeObstaclesUtil(i, j, maze):
    # Base case: If we are out of bounds or at an obstacle, return 0.
    if i < 0 or j < 0 or maze[i][j] == -1:
        return 0

    # Base case: If we reach the starting point, return 1 (we found a path).
    if i == 0 and j == 0:
        return 1

    # Move up and left in the maze, and recursively calculate the number of paths.
    up = mazeObstaclesUtil(i - 1, j, maze)
    left = mazeObstaclesUtil(i, j - 1, maze)

    return up + left

def mazeObstacles(n, m, maze):
    # Call the utility function to find the number of paths.
    return mazeObstaclesUtil(n - 1, m - 1, maze)

def main():
    # Example maze with 0s representing open paths and -1 representing obstacles.
    maze = [[0, 0, 0], [0, -1, 0], [0, 0, 0]]
    n = len(maze)
    m = len(maze[0])

    # Call the mazeObstacles function and print the result.
    print(mazeObstacles(n, m, maze))

if __name__ == '__main__':
    main()



# method 1 : memoization
'''
Time Complexity: O(N*M)

Reason: At max, there will be N*M calls of recursion.

Space Complexity: O((M-1)+(N-1)) + O(N*M)

Reason: We are using a recursion stack space:O((M-1)+(N-1)), here (M-1)+(N-1) is the path length and an external DP Array of size â€˜N*Mâ€™.
'''
def mazeObstaclesUtil(i, j, maze, dp):
    # Base case: If we are out of bounds or at an obstacle, return 0.
    if i < 0 or j < 0 or maze[i][j] == -1:
        return 0

    # Base case: If we reach the starting point, return 1 (we found a path).
    if i == 0 and j == 0:
        return 1

    # If we've already computed the number of paths for this position, return it.
    if dp[i][j] != -1:
        return dp[i][j]

    # Move up and left in the maze, and recursively calculate the number of paths.
    up = mazeObstaclesUtil(i - 1, j, maze, dp)
    left = mazeObstaclesUtil(i, j - 1, maze, dp)

    # Store the result in the DP table and return it.
    dp[i][j] = up + left
    return dp[i][j]

def mazeObstacles(n, m, maze):
    # Create a DP table initialized with -1 values.
    dp = [[-1 for j in range(m)] for i in range(n)]
    
    # Call the utility function to find the number of paths.
    return mazeObstaclesUtil(n - 1, m - 1, maze, dp)

def main():
    # Example maze with 0s representing open paths and -1 representing obstacles.
    maze = [[0, 0, 0], [0, -1, 0], [0, 0, 0]]
    n = len(maze)
    m = len(maze[0])

    # Call the mazeObstacles function and print the result.
    print(mazeObstacles(n, m, maze))

if __name__ == '__main__':
    main()




# method 2 : tabulation
'''
Time Complexity: O(N*M)

Reason: There are two nested loops

Space Complexity: O(N*M)

Reason: We are using an external array of size â€˜N*Mâ€™â€™.
'''
def mazeObstaclesUtil(n, m, maze, dp):
    # Loop through each cell in the maze
    for i in range(n):
        for j in range(m):
            # Base conditions:
            # If we encounter an obstacle or we are out of bounds, set dp[i][j] to 0.
            if i > 0 and j > 0 and maze[i][j] == -1:
                dp[i][j] = 0
                continue
            # If we are at the starting point, set dp[i][j] to 1.
            if i == 0 and j == 0:
                dp[i][j] = 1
                continue
            
            # Initialize variables to store the number of paths coming from up and left.
            up = 0
            left = 0
            
            # If we can move up (i > 0), update 'up' with the value from the cell above.
            if i > 0:
                up = dp[i - 1][j]
            
            # If we can move left (j > 0), update 'left' with the value from the cell to the left.
            if j > 0:
                left = dp[i][j - 1]
            
            # Calculate the total number of paths to reach this cell and store it in dp[i][j].
            dp[i][j] = up + left
    
    # The result is stored in the bottom-right corner of the DP table.
    return dp[n - 1][m - 1]

def mazeObstacles(n, m, maze):
    # Create a DP table initialized with -1 values.
    dp = [[-1 for j in range(m)] for i in range(n)]
    
    # Call the utility function to find the number of paths.
    return mazeObstaclesUtil(n, m, maze, dp)

def main():
    # Example maze with 0s representing open paths and -1 representing obstacles.
    maze = [[0, 0, 0],
            [0, -1, 0],
            [0, 0, 0]]
    n = len(maze)
    m = len(maze[0])
    
    # Call the mazeObstacles function and print the result.
    print(mazeObstacles(n, m, maze))

if __name__ == "__main__":
    main()

 


# method 3 : space optimization
'''
Time Complexity: O(M*N)

Reason: There are two nested loops

Space Complexity: O(N)

Reason: We are using an external array of size â€˜Nâ€™ to store only one row.
'''
def mazeObstacles(n, m, maze):
    # Initialize the 'prev' list to keep track of the number of paths in the previous row.
    prev = [0] * m
    
    # Loop through each row of the maze.
    for i in range(n):
        # Initialize a temporary list to store the number of paths for the current row.
        temp = [0] * m
        
        # Loop through each cell in the current row.
        for j in range(m):
            # Base conditions:
            # If we encounter an obstacle or we are out of bounds, set 'temp[j]' to 0.
            if i > 0 and j > 0 and maze[i][j] == -1:
                temp[j] = 0
                continue
            # If we are at the starting point, set 'temp[j]' to 1.
            if i == 0 and j == 0:
                temp[j] = 1
                continue
            
            # Initialize variables to store the number of paths coming from up and left.
            up = 0
            left = 0
            
            # If we can move up (i > 0), update 'up' with the value from the previous row.
            if i > 0:
                up = prev[j]
            
            # If we can move left (j > 0), update 'left' with the value from the current row.
            if j > 0:
                left = temp[j - 1]
            
            # Calculate the total number of paths to reach this cell and store it in 'temp[j]'.
            temp[j] = up + left
        
        # Update 'prev' with the 'temp' list for the next iteration.
        prev = temp
    
    # The result is stored in the last element of the 'prev' list (bottom-right corner).
    return prev[m - 1]

def main():
    # Example maze with 0s representing open paths and -1 representing obstacles.
    maze = [[0, 0, 0],
            [0, -1, 0],
            [0, 0, 0]]
    n = len(maze)
    m = len(maze[0])
    
    # Call the mazeObstacles function and print the result.
    print(mazeObstacles(n, m, maze))

if __name__ == "__main__":
    main()



# 4 TODO : minimum path sum in grid (DP-10)
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/minimum-path-sum-in-a-grid-dp-10/


https://leetcode.com/problems/minimum-path-sum/


https://www.youtube.com/watch?v=_rgTlyky1uQ&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=191
'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
'''
Time Complexity: O(N*M)

Reason: At max, there will be N*M calls of recursion.

Space Complexity: O((M-1)+(N-1)) + O(N*M)

Reason: We are using a recursion stack space: O((M-1)+(N-1)), here (M-1)+(N-1) is the path length and an external DP Array of size â€˜N*Mâ€™.
'''
def minSumPathUtil(i, j, matrix, dp):
    # Base case: If we are at the top-left corner, return the value of that cell.
    if i == 0 and j == 0:
        return matrix[0][0]
    
    # Base case: If we are out of bounds (negative indices), return a very large value.
    if i < 0 or j < 0:
        return int(1e9)
    
    # If we have already calculated the minimum sum for this cell, return it.
    if dp[i][j] != -1:
        return dp[i][j]

    # Calculate the minimum sum path recursively by considering both up and left moves.
    up = matrix[i][j] + minSumPathUtil(i-1, j, matrix, dp)
    left = matrix[i][j] + minSumPathUtil(i, j-1, matrix, dp)

    # Store the minimum of the two possible paths in the DP table.
    dp[i][j] = min(up, left)
    return dp[i][j]


def minSumPath(n, m, matrix):
    # Create a DP table initialized with -1 values.
    dp = [[-1 for j in range(m)] for i in range(n)]
    
    # Call the utility function to find the minimum sum path.
    return minSumPathUtil(n-1, m-1, matrix, dp)


def main():
    # Example matrix with values representing cell costs.
    matrix = [[5, 9, 6],
              [11, 5, 2]]

    n = len(matrix)
    m = len(matrix[0])

    # Call the minSumPath function and print the result.
    print(minSumPath(n, m, matrix))


if __name__ == '__main__':
    main()




# method 2 : tabulation
'''
Time Complexity: O(N*M)

Reason: There are two nested loops

Space Complexity: O(N*M)

Reason: We are using an external array of size â€˜N*Mâ€™â€™.
'''
def minSumPath(n, m, matrix):
    # Create a DP table initialized with zeros.
    dp = [[0 for j in range(m)] for i in range(n)]
    
    # Loop through each cell in the matrix.
    for i in range(n):
        for j in range(m):
            if i == 0 and j == 0:
                # Base case: If we are at the top-left corner, set dp[i][j] to the value of that cell.
                dp[i][j] = matrix[i][j]
            else:
                # Calculate the cost of moving up from the cell (i, j).
                up = matrix[i][j]
                if i > 0:
                    up += dp[i-1][j]
                else:
                    # If we are at the top row and can't move up, set 'up' to a large value.
                    up += int(1e9)
                
                # Calculate the cost of moving left from the cell (i, j).
                left = matrix[i][j]
                if j > 0:
                    left += dp[i][j-1]
                else:
                    # If we are at the leftmost column and can't move left, set 'left' to a large value.
                    left += int(1e9)
                
                # Store the minimum cost of reaching the current cell in dp[i][j].
                dp[i][j] = min(up, left)
    
    # The result is stored in the bottom-right corner of the DP table.
    return dp[n-1][m-1]

def main():
    # Example matrix with values representing cell costs.
    matrix = [[5, 9, 6], [11, 5, 2]]
    n = len(matrix)
    m = len(matrix[0])
    
    # Call the minSumPath function and print the result.
    print(minSumPath(n, m, matrix))

if __name__ == "__main__":
    main()




# method 3 : space optimization
'''
Time Complexity: O(M*N)

Reason: There are two nested loops

Space Complexity: O(N)

Reason: We are using an external array of size â€˜Nâ€™ to store only one row.
'''
def minSumPath(n, m, matrix):
    # Initialize the 'prev' list to keep track of the minimum cost in the previous row.
    prev = [0] * m
    
    # Loop through each row of the matrix.
    for i in range(n):
        # Initialize a temporary list to store the minimum cost for the current row.
        temp = [0] * m
        
        # Loop through each cell in the current row.
        for j in range(m):
            if i == 0 and j == 0:
                # Base case: If we are at the top-left corner, set 'temp[j]' to the value of that cell.
                temp[j] = matrix[i][j]
            else:
                # Calculate the cost of moving up from the cell (i, j).
                up = matrix[i][j]
                if i > 0:
                    up += prev[j]
                else:
                    # If we are at the top row and can't move up, set 'up' to a large value.
                    up = int(1e9)
                
                # Calculate the cost of moving left from the cell (i, j).
                left = matrix[i][j]
                if j > 0:
                    left += temp[j-1]
                else:
                    # If we are at the leftmost column and can't move left, set 'left' to a large value.
                    left = int(1e9)
                
                # Store the minimum cost of reaching the current cell in 'temp[j]'.
                temp[j] = min(up, left)
        
        # Update 'prev' with the 'temp' list for the next iteration.
        prev = temp
    
    # The result is stored in the last element of the 'prev' list (bottom-right corner).
    return prev[m - 1]

def main():
    # Example matrix with values representing cell costs.
    matrix = [[5, 9, 6], [11, 5, 2]]
    n = len(matrix)
    m = len(matrix[0])
    
    # Call the minSumPath function and print the result.
    print(minSumPath(n, m, matrix))

if __name__ == '__main__':
    main()

    


# 5 TODO : minimum path sum in triangular grid (DP-11)
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://takeuforward.org/data-structure/minimum-path-sum-in-triangular-grid-dp-11/


https://leetcode.com/problems/triangle/


https://www.youtube.com/watch?v=SrP-PiLSYC0&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=192
'''


# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''



# method : memoization
'''

For these patterns,
- represent in (i,j) with base cases 
- explore all paths
- iteration starts from (0,0) previously we started from end but now from start
- min of all paths


Time Complexity: O(N*N)

Reason: There are two nested loops

Space Complexity: O(N*N)

Reason: We are using an external array of size â€˜N*Nâ€™. The stack space will be eliminated.
'''
def minimumPathSumUtil(i, j, triangle, n, dp):
    # Check if we have already computed the minimum path sum for this cell
    if dp[i][j] != -1:
        return dp[i][j]

    # If we are at the bottom of the triangle, return the value in the current cell
    if i == n - 1:
        return triangle[i][j]

    # Calculate the minimum path sum by considering two possible moves: down and diagonal
    down = triangle[i][j] + minimumPathSumUtil(i + 1, j, triangle, n, dp)
    diagonal = triangle[i][j] + minimumPathSumUtil(i + 1, j + 1, triangle, n, dp)

    # Store the computed minimum path sum in the memoization table
    dp[i][j] = min(down, diagonal)
    return dp[i][j]

# Define a wrapper function to initialize memoization table and start the computation
def minimumPathSum(triangle, n):
    dp = [[-1 for j in range(n)] for i in range(n)]  # Initialize a memoization table with -1
    return minimumPathSumUtil(0, 0, triangle, n, dp)  # Start the recursive computation

# Define the main function where you set up the triangle and call the minimumPathSum function
def main():
    triangle = [[1], [2, 3], [3, 6, 7], [8, 9, 6, 10]]
    n = len(triangle)

    # Call the minimumPathSum function and print the result
    print(minimumPathSum(triangle, n))

# Check if this script is the main program entry point
if __name__ == "__main__":
    main()  # Call the main function to start the program

 


# method 2 : tabulation
'''
Time Complexity: O(N*N)

Reason: There are two nested loops

Space Complexity: O(N*N)

Reason: We are using an external array of size â€˜N*Nâ€™. The stack space will be eliminated.
'''
def minimum_path_sum(triangle, n):
    # Create a 2D array dp to store minimum path sums
    dp = [[0 for j in range(n)] for i in range(n)]
    
    # Initialize the bottom row of dp with the values from the last row of the triangle
    for j in range(n):
        dp[n - 1][j] = triangle[n - 1][j]
    
    # Start from the second-to-last row and work upwards
    for i in range(n - 2, -1, -1):
        for j in range(i, -1, -1):
            # Calculate the minimum path sum for the current cell by considering two possible moves: down and diagonal
            down = triangle[i][j] + dp[i + 1][j]
            diagonal = triangle[i][j] + dp[i + 1][j + 1]
            
            # Store the minimum of the two possible moves in dp
            dp[i][j] = min(down, diagonal)
    
    # The minimum path sum will be stored in dp[0][0] after the loops
    return dp[0][0]

def main():
    # Define the input triangle and its size
    triangle = [[1], [2, 3], [3, 6, 7], [8, 9, 6, 10]]
    n = len(triangle)
    
    # Call the minimum_path_sum function and print the result
    print(minimum_path_sum(triangle, n))

if __name__ == '__main__':
    main()



# method 3 : space optimization
'''
Time Complexity: O(N*N)

Reason: There are two nested loops

Space Complexity: O(N)

Reason: We are using an external array of size â€˜Nâ€™ to store only one row.
'''
def minimumPathSum(triangle, n):
    # Initialize two lists: front and cur to represent the current and previous rows in dp
    front = [0] * n  # This represents the previous row
    cur = [0] * n    # This represents the current row
    
    # Initialize the bottom row of dp (front) with the values from the last row of the triangle
    for j in range(n):
        front[j] = triangle[n - 1][j]
    
    # Start from the second-to-last row and work upwards
    for i in range(n - 2, -1, -1):
        for j in range(i, -1, -1):
            # Calculate the minimum path sum for the current cell by considering two possible moves: down and diagonal
            down = triangle[i][j] + front[j]
            diagonal = triangle[i][j] + front[j + 1]
            
            # Store the minimum of the two possible moves in the current row (cur)
            cur[j] = min(down, diagonal)
        
        # Update the previous row (front) with the current row (cur) for the next iteration
        front = cur
        
    # The minimum path sum will be stored in the first element of the front list after the loops
    return front[0]

def main():
    # Define the input triangle and its size
    triangle = [[1], [2, 3], [3, 6, 7], [8, 9, 6, 10]]
    n = len(triangle)
    
    # Call the minimumPathSum function and print the result
    print(minimumPathSum(triangle, n))

if __name__ == '__main__':
    main()

  


# 6 TODO : minimum/maximum falling path sum (DP-12)
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://takeuforward.org/data-structure/minimum-maximum-falling-path-sum-dp-12/


https://leetcode.com/problems/minimum-falling-path-sum/

https://www.youtube.com/watch?v=N_aJ5qQbYA0&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=193
'''


# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
'''
Time Complexity: O(N*N)

Reason: At max, there will be M*N calls of recursion to solve a new problem,

Space Complexity: O(N) + O(N*M)

Reason: We are using a recursion stack space: O(N), where N is the path length and an external DP Array of size â€˜N*Mâ€™.
'''
import sys

# Recursive function to find the maximum path sum starting from cell (i, j)
def getMaxUtil(i, j, m, matrix, dp):
    # Base case: If j is out of bounds, return a large negative value
    if j < 0 or j >= m:
        return -int(1e9)
    
    # Base case: If we are at the top row (i == 0), return the value in the current cell
    if i == 0:
        return matrix[0][j]
    
    # Check if the maximum path sum for this cell has already been computed
    if dp[i][j] != -1:
        return dp[i][j]
    
    # Calculate three possible moves: going up, going up-left, and going up-right
    up = matrix[i][j] + getMaxUtil(i - 1, j, m, matrix, dp)
    leftDiagonal = matrix[i][j] + getMaxUtil(i - 1, j - 1, m, matrix, dp)
    rightDiagonal = matrix[i][j] + getMaxUtil(i - 1, j + 1, m, matrix, dp)
    
    # Store the maximum of the three moves in the memoization table
    dp[i][j] = max(up, max(leftDiagonal, rightDiagonal))
    return dp[i][j]

# Function to find the maximum path sum in the matrix
def getMaxPathSum(matrix):
    n = len(matrix)  # Number of rows
    m = len(matrix[0])  # Number of columns
    dp = [[-1 for j in range(m)] for i in range(n)]  # Initialize a memoization table
    maxi = -sys.maxsize  # Initialize the maximum sum to a large negative value
    
    # Iterate through the first row and find the maximum path sum starting from each cell
    for j in range(m):
        ans = getMaxUtil(n - 1, j, m, matrix, dp)
        maxi = max(maxi, ans)
    
    return maxi  # Return the maximum path sum

def main():
    # Define the input matrix
    matrix = [[1, 2, 10, 4], [100, 3, 2, 1], [1, 1, 20, 2], [1, 2, 2, 1]]
    
    # Call the getMaxPathSum function and print the result
    print(getMaxPathSum(matrix))

if __name__ == "__main__":
    main()




# method 2 : tabulation
'''
Time Complexity: O(N*M)

Reason: There are two nested loops

Space Complexity: O(N*M)

Reason: We are using an external array of size â€˜N*Mâ€™. The stack space will be eliminated.
'''
import sys

# Function to find the maximum path sum in the matrix
def getMaxPathSum(matrix):
    n = len(matrix)  # Number of rows
    m = len(matrix[0])  # Number of columns
    
    # Initialize a dynamic programming table (dp) with zeros
    dp = [[0 for j in range(m)] for i in range(n)]
    
    # Initializing the first row of dp as the base condition
    for j in range(m):
        dp[0][j] = matrix[0][j]
    
    # Iterate through the matrix to compute the maximum path sum
    for i in range(1, n):
        for j in range(m):
            # Calculate the three possible moves: up, left diagonal, and right diagonal
            up = matrix[i][j] + dp[i - 1][j]
            
            # Handle left diagonal
            left_diagonal = matrix[i][j]
            if j - 1 >= 0:
                left_diagonal += dp[i - 1][j - 1]
            else:
                left_diagonal += -int(1e9)  # A large negative value if out of bounds
            
            # Handle right diagonal
            right_diagonal = matrix[i][j]
            if j + 1 < m:
                right_diagonal += dp[i - 1][j + 1]
            else:
                right_diagonal += -int(1e9)  # A large negative value if out of bounds
            
            # Store the maximum of the three moves in dp
            dp[i][j] = max(up, left_diagonal, right_diagonal)
    
    # Find the maximum path sum in the last row of dp
    maxi = -sys.maxsize
    for j in range(m):
        maxi = max(maxi, dp[n - 1][j])
    
    return maxi  # Return the maximum path sum

def main():
    # Define the input matrix
    matrix = [[1, 2, 10, 4], [100, 3, 2, 1], [1, 1, 20, 2], [1, 2, 2, 1]]
    
    # Call the getMaxPathSum function and print the result
    print(getMaxPathSum(matrix))

if __name__ == "__main__":
    main()

  


# method 3 : space optimization
'''
Time Complexity: O(N*M)

Reason: There are two nested loops

Space Complexity: O(M)

Reason: We are using an external array of size â€˜Mâ€™ to store only one row.
'''
import sys

# Function to find the maximum path sum in the matrix
def getMaxPathSum(matrix):
    n = len(matrix)  # Number of rows
    m = len(matrix[0])  # Number of columns

    # Initialize two lists: prev (previous row) and cur (current row)
    prev = [0] * m
    cur = [0] * m

    # Initializing the first row of prev as the base condition
    for j in range(m):
        prev[j] = matrix[0][j]

    # Iterate through the matrix to compute the maximum path sum
    for i in range(1, n):
        for j in range(m):
            # Calculate the three possible moves: up, left diagonal, and right diagonal
            up = matrix[i][j] + prev[j]

            leftDiagonal = matrix[i][j]
            if j - 1 >= 0:
                leftDiagonal += prev[j - 1]
            else:
                leftDiagonal += -int(1e9)  # A large negative value if out of bounds

            rightDiagonal = matrix[i][j]
            if j + 1 < m:
                rightDiagonal += prev[j + 1]
            else:
                rightDiagonal += -int(1e9)  # A large negative value if out of bounds

            # Store the maximum of the three moves in the current row (cur)
            cur[j] = max(up, max(leftDiagonal, rightDiagonal))

        # Update prev with the values of cur for the next iteration
        prev = cur[:]

    # Find the maximum path sum in the last row of prev
    maxi = -sys.maxsize
    for j in range(m):
        maxi = max(maxi, prev[j])

    return maxi  # Return the maximum path sum

def main():
    # Define the input matrix
    matrix = [[1, 2, 10, 4], [100, 3, 2, 1], [1, 1, 20, 2], [1, 2, 2, 1]]

    # Call the getMaxPathSum function and print the result
    print(getMaxPathSum(matrix))

if __name__ == '__main__':
    main()




# 7 TODO : 3D DP : ninja and his friends (DP-13)
'''



ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://takeuforward.org/data-structure/3-d-dp-ninja-and-his-friends-dp-13/

https://bit.ly/3U9k6XT


https://www.youtube.com/watch?v=QGfn7JeXK54&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=194
'''


# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
'''

express everything in terms of (i1,j1) and (i2,j2)
explore all the paths
max sum



Time Complexity: O(N*M*M) * 9

Reason: At max, there will be N*M*M calls of recursion to solve a new problem and in every call, two nested loops together run for 9 times.

Space Complexity: O(N) + O(N*M*M)

Reason: We are using a recursion stack space: O(N), where N is the path length and an external DP Array of size â€˜N*M*Mâ€™.
'''
import sys

# Recursive function to find the maximum chocolates collected
def maxChocoUtil(i, j1, j2, n, m, grid, dp):
    # Base cases:
    # - If either of the indices is out of bounds, return a large negative value
    # - If we're at the last row, return the sum of chocolates in the two selected columns
    if j1 < 0 or j1 >= m or j2 < 0 or j2 >= m:
        return int(-1e9)
    if i == n - 1:
        if j1 == j2:
            return grid[i][j1]
        else:
            return grid[i][j1] + grid[i][j2]
    
    # If the result for these indices has already been computed, return it
    if dp[i][j1][j2] != -1:
        return dp[i][j1][j2]
    
    # Initialize the maximum chocolates collected to a large negative value
    maxi = -sys.maxsize
    
    # Iterate through the adjacent cells in the next row
    for di in range(-1, 2):
        for dj in range(-1, 2):
            ans = 0
            if j1 == j2:
                ans = grid[i][j1] + maxChocoUtil(i + 1, j1 + di, j2 + dj, n, m, grid, dp)
            else:
                ans = grid[i][j1] + grid[i][j2] + maxChocoUtil(i + 1, j1 + di, j2 + dj, n, m, grid, dp)
            maxi = max(maxi, ans)
    
    # Store the maximum chocolates collected in the memoization table
    dp[i][j1][j2] = maxi
    return maxi

# Function to find the maximum chocolates collected
def maximumChocolates(n, m, grid):
    # Initialize a memoization table with -1 values
    dp = [[[-1 for j in range(m)] for i in range(m)] for k in range(n)]
    
    # Start the recursion from the first row, columns 0 and m-1
    return maxChocoUtil(0, 0, m - 1, n, m, grid, dp)

def main():
    # Define the input matrix and its dimensions
    matrix = [[2, 3, 1, 2], [3, 4, 2, 2], [5, 6, 3, 5]]
    n = len(matrix)
    m = len(matrix[0])
    
    # Call the maximumChocolates function and print the result
    print(maximumChocolates(n, m, matrix))

if __name__ == "__main__":
    main()



# method 2 : tabulation
'''
Time Complexity: O(N*M*M)*9

Reason: The outer nested loops run for (N*M*M) times and the inner two nested loops run for 9 times.

Space Complexity: O(N*M*M)

Reason: We are using an external array of size â€˜N*M*Mâ€™. The stack space will be eliminated.
'''
import sys

# Function to find the maximum chocolates collected
def maximumChocolates(n, m, grid):
    # Initialize a 3D memoization table dp with zeros
    dp = [[[0 for _ in range(m)] for _ in range(m)] for _ in range(n)]

    # Initialize the values for the last row of dp based on grid values
    for j1 in range(m):
        for j2 in range(m):
            if j1 == j2:
                dp[n - 1][j1][j2] = grid[n - 1][j1]
            else:
                dp[n - 1][j1][j2] = grid[n - 1][j1] + grid[n - 1][j2]

    # Iterate through rows from the second-to-last row to the first row
    for i in range(n - 2, -1, -1):
        for j1 in range(m):
            for j2 in range(m):
                maxi = -sys.maxsize

                # Try out 9 possible options by changing the indices
                for di in range(-1, 2):
                    for dj in range(-1, 2):
                        ans = 0
                        if j1 == j2:
                            ans = grid[i][j1]
                        else:
                            ans = grid[i][j1] + grid[i][j2]

                        if ((j1 + di < 0 or j1 + di >= m) or (j2 + dj < 0 or j2 + dj >= m)):
                            ans += int(-1e9)  # A large negative value if out of bounds
                        else:
                            ans += dp[i + 1][j1 + di][j2 + dj]  # Add the value from the next row

                        maxi = max(ans, maxi)

                # Store the maximum chocolates collected in the memoization table
                dp[i][j1][j2] = maxi

    # Return the maximum chocolates collected in the top row and the last column
    return dp[0][0][m - 1]

def main():
    # Define the input matrix and its dimensions
    matrix = [[2, 3, 1, 2], [3, 4, 2, 2], [5, 6, 3, 5]]
    n = len(matrix)
    m = len(matrix[0])

    # Call the maximumChocolates function and print the result
    print(maximumChocolates(n, m, matrix))

if __name__ == '__main__':
    main()




# method 3 : space optimization
'''
Time Complexity: O(N*M*M)*9

Reason: The outer nested loops run for (N*M*M) times and the inner two nested loops run for 9 times.

Space Complexity: O(M*M)

Reason: We are using an external array of size â€˜M*Mâ€™.
'''
import sys

# Function to find the maximum chocolates collected
def maximumChocolates(n, m, grid):
    # Initialize two matrices: front (for the current row) and cur (for the next row)
    front = [[0] * m for _ in range(m)]
    cur = [[0] * m for _ in range(m)]

    # Initialize the values for the last row of front based on grid values
    for j1 in range(m):
        for j2 in range(m):
            if j1 == j2:
                front[j1][j2] = grid[n - 1][j1]
            else:
                front[j1][j2] = grid[n - 1][j1] + grid[n - 1][j2]

    # Iterate through rows from the second-to-last row to the first row
    for i in range(n - 2, -1, -1):
        for j1 in range(m):
            for j2 in range(m):
                maxi = -sys.maxsize

                # Try out 9 possible options by changing the indices
                for di in range(-1, 2):
                    for dj in range(-1, 2):
                        ans = 0
                        if j1 == j2:
                            ans = grid[i][j1]
                        else:
                            ans = grid[i][j1] + grid[i][j2]

                        if ((j1 + di < 0 or j1 + di >= m) or (j2 + dj < 0 or j2 + dj >= m)):
                            ans += int(-1e9)  # A large negative value if out of bounds
                        else:
                            ans += front[j1 + di][j2 + dj]  # Add the value from the current front row

                        maxi = max(ans, maxi)
                cur[j1][j2] = maxi

        # Update front with the values of cur for the next iteration
        front = [row[:] for row in cur]

    # Return the maximum chocolates collected in the top-left corner of front
    return front[0][m - 1]

def main():
    # Define the input matrix and its dimensions
    matrix = [[2, 3, 1, 2], [3, 4, 2, 2], [5, 6, 3, 5]]
    n = len(matrix)
    m = len(matrix[0])

    # Call the maximumChocolates function and print the result
    print(maximumChocolates(n, m, matrix))

if __name__ == '__main__':
    main()





# endregion





# region 16.4 DP - SUBSEQUENCES
# -----------------------------
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://www.youtube.com/watch?v=fWX9xDmIzRI&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=195
'''


# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# 1 TODO :  subset sum equals to target (DP-14)
'''

https://takeuforward.org/data-structure/subset-sum-equal-to-target-dp-14/


https://practice.geeksforgeeks.org/problems/subset-sum-problem-1611555638/1

'''
# method 1 : memoization
'''
https://www.youtube.com/watch?v=fWX9xDmIzRI&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=195


Time Complexity: O(N*K)

Reason: There are N*K states therefore at max â€˜N*Kâ€™ new problems will be solved.

Space Complexity: O(N*K) + O(N)

Reason: We are using a recursion stack space(O(N)) and a 2D array ( O(N*K)).
'''
def subsetSumUtil(ind, target, arr, dp):
    # Check if the target sum has been achieved.
    if target == 0:
        return True

    # If we have reached the first element in the array.
    if ind == 0:
        return arr[0] == target

    # Check if the result for this combination of 'ind' and 'target' has already been computed.
    if dp[ind][target] != -1:
        return dp[ind][target]

    # Recursively try not taking the current element.
    notTaken = subsetSumUtil(ind - 1, target, arr, dp)

    taken = False
    # Check if the current element can be taken without exceeding the target.
    if arr[ind] <= target:
        taken = subsetSumUtil(ind - 1, target - arr[ind], arr, dp)

    # Store the result in the dp array to avoid recomputation.
    dp[ind][target] = notTaken or taken
    return dp[ind][target]

def subsetSumToK(n, k, arr):
    # Initialize a memoization table with -1.
    dp = [[-1 for j in range(k + 1)] for i in range(n)]

    # Call the utility function to find if a subset with the given target sum exists.
    return subsetSumUtil(n - 1, k, arr, dp)

def main():
    arr = [1, 2, 3, 4]
    k = 4
    n = len(arr)

    if subsetSumToK(n, k, arr):
        print("Subset with the given target found")
    else:
        print("Subset with the given target not found")

if __name__ == "__main__":
    main()




# method 2 : tabulation 
'''
Time Complexity: O(N*K)

Reason: There are two nested loops

Space Complexity: O(N*K)

Reason: We are using an external array of size â€˜N*Kâ€™. Stack Space is eliminated.
'''
def subsetSumToK(n, k, arr):
    # Initialize a 2D DP table with False values.
    dp = [[False for j in range(k + 1)] for i in range(n)]
    
    # Set the first column to True since a sum of 0 is always possible with an empty subset.
    for i in range(n):
        dp[i][0] = True
    
    # Check if the first element of the array can be used to make the target sum.
    if arr[0] <= k:
        dp[0][arr[0]] = True
    
    # Fill in the DP table iteratively.
    for ind in range(1, n):
        for target in range(1, k + 1):
            notTaken = dp[ind - 1][target]  # Not taking the current element.
            taken = False
            # Check if taking the current element is possible without exceeding the target.
            if arr[ind] <= target:
                taken = dp[ind - 1][target - arr[ind]]
            dp[ind][target] = notTaken or taken  # Update the DP table with the result.
    
    # The final result is stored in the bottom-right cell of the DP table.
    return dp[n - 1][k]

def main():
    arr = [1, 2, 3, 4]
    k = 4
    n = len(arr)

    if subsetSumToK(n, k, arr):
        print("Subset with the given target found")
    else:
        print("Subset with the given target not found")

if __name__ == '__main__':
    main()




# method 3 : space optimization
'''
Time Complexity: O(N*K)

Reason: There are three nested loops

Space Complexity: O(K)

Reason: We are using an external array of size â€˜K+1â€™ to store only one row.
'''
def subset_sum_to_k(n, k, arr):
    # Initialize a boolean array 'prev' with size (k + 1).
    prev = [False] * (k + 1)
    
    # Set the first element of 'prev' to True since an empty subset can sum up to 0.
    prev[0] = True
    
    # Check if the first element of 'arr' can directly contribute to the target sum 'k'.
    if arr[0] <= k:
        prev[arr[0]] = True

    # Loop through the elements of 'arr' and update 'prev' using dynamic programming.
    for ind in range(1, n):
        # Initialize a new boolean array 'cur' for the current element.
        cur = [False] * (k + 1)
        
        # An empty subset can always sum up to 0.
        cur[0] = True
        
        for target in range(1, k + 1):
            not_taken = prev[target]  # Previous result without including the current element.
            taken = False
            
            # Check if including the current element is possible without exceeding the target.
            if arr[ind] <= target:
                taken = prev[target - arr[ind]]
            
            # Update 'cur' with the result for the current 'target'.
            cur[target] = not_taken or taken
        
        # Update 'prev' with the results for the current element 'ind'.
        prev = cur

    # The final result is stored in 'prev[k]'.
    return prev[k]

def main():
    arr = [1, 2, 3, 4]
    k = 4
    n = len(arr)

    if subset_sum_to_k(n, k, arr):
        print("Subset with the given target found")
    else:
        print("Subset with the given target not found")

if __name__ == "__main__":
    main()




# 2 TODO : partition equal subset sum (DP-15)
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡




https://takeuforward.org/data-structure/partition-equal-subset-sum-dp-15/


https://leetcode.com/problems/partition-equal-subset-sum/


https://www.youtube.com/watch?v=7win3dcgo3k&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=196
'''


# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
'''
Time Complexity: O(N*K) + O(N)

Reason: There are N*K states therefore at max â€˜N*Kâ€™ new problems will be solved and we are running a for loop for â€˜Nâ€™ times to calculate the total sum

Space Complexity: O(N*K) + O(N)

Reason: We are using a recursion stack space(O(N)) and a 2D array ( O(N*K)).
'''
def subsetSumUtil(ind, target, arr, dp):
    # Base case: If the target sum is 0, we have found a subset that sums to the target.
    if target == 0:
        return True
    
    # Base case: If we have reached the first element of the array, check if it equals the target.
    if ind == 0:
        return arr[0] == target
    
    # Check if the result for this combination of 'ind' and 'target' has already been computed.
    if dp[ind][target] != -1:
        return dp[ind][target]
    
    # Recursive cases:
    # 1. Try not taking the current element.
    notTaken = subsetSumUtil(ind - 1, target, arr, dp)
    
    # 2. Try taking the current element if it is less than or equal to the target.
    taken = False
    if arr[ind] <= target:
        taken = subsetSumUtil(ind - 1, target - arr[ind], arr, dp)
        
    # Update the DP table and return the result.
    dp[ind][target] = notTaken or taken
    return dp[ind][target]

def canPartition(n, arr):
    # Calculate the total sum of the array elements.
    totSum = sum(arr)
    
    # If the total sum is odd, it cannot be partitioned into two equal subsets.
    if totSum % 2 == 1:
        return False
    else:
        # Calculate the target sum for each subset.
        k = totSum // 2
        
        # Initialize a memoization table for dynamic programming.
        dp = [[-1 for i in range(k + 1)] for j in range(n)]
        
        # Call the subsetSumUtil function to check if a subset with sum 'k' exists.
        return subsetSumUtil(n - 1, k, arr, dp)

def main():
    arr = [2, 3, 3, 3, 4, 5]
    n = len(arr)
    
    # Check if the array can be partitioned into two equal subsets and print the result.
    if canPartition(n, arr):
        print("The Array can be partitioned into two equal subsets")
    else:
        print("The Array cannot be partitioned into two equal subsets")

if __name__ == "__main__":
    main()




# method 2 : tabulation
'''
Time Complexity: O(N*K) +O(N)

Reason: There are two nested loops that account for O(N*K) and at starting we are running a for loop to calculate totSum.

Space Complexity: O(N*K)

Reason: We are using an external array of size â€˜N*Kâ€™. Stack Space is eliminated.
'''
def canPartition(n, arr):
    # Calculate the total sum of the array elements.
    totSum = sum(arr)
    
    # If the total sum is odd, it cannot be partitioned into two equal subsets.
    if totSum % 2 == 1:
        return False
    else:
        # Calculate the target sum for each subset.
        k = totSum // 2
        
        # Initialize a dynamic programming table (dp) to store subproblem results.
        dp = [[False for j in range(k + 1)] for i in range(n)]

        # Initialize the base case: An empty subset can always achieve a sum of 0.
        for i in range(n):
            dp[i][0] = True

        # Initialize the base case for the first element in the array.
        if arr[0] <= k:
            dp[0][arr[0]] = True

        # Fill in the DP table using a bottom-up approach.
        for ind in range(1, n):
            for target in range(1, k + 1):
                # If the current element is not taken, the result is the same as the previous row.
                notTaken = dp[ind - 1][target]
                
                # If the current element is taken, subtract its value from the target and check the previous row.
                taken = False
                if arr[ind] <= target:
                    taken = dp[ind - 1][target - arr[ind]]
                
                # Update the DP table with the result of taking or not taking the current element.
                dp[ind][target] = notTaken or taken
        
        # The final result is stored in the bottom-right cell of the DP table.
        return dp[n - 1][k]

def main():
    arr = [2, 3, 3, 3, 4, 5]
    n = len(arr)
    
    # Check if the array can be partitioned into two equal subsets and print the result.
    if canPartition(n, arr):
        print("The Array can be partitioned into two equal subsets")
    else:
        print("The Array cannot be partitioned into two equal subsets")

if __name__ == '__main__':
    main()




# method 3 : space optimization
'''
Time Complexity: O(N*K) +O(N)

Reason: There are two nested loops that account for O(N*K) and at starting we are running a for loop to calculate totSum.

Space Complexity: O(K)

Reason: We are using an external array of size â€˜K+1â€™ to store only one row.
'''
def canPartition(n, arr):
    # Calculate the total sum of the array elements.
    totSum = sum(arr)
    
    # If the total sum is odd, it cannot be partitioned into two equal subsets.
    if totSum % 2 == 1:
        return False
    else:
        # Calculate the target sum for each subset.
        k = totSum // 2
        
        # Initialize a boolean array 'prev' to store the results for the previous row.
        prev = [False] * (k + 1)
        prev[0] = True  # Base case: An empty subset can always achieve a sum of 0.
        
        # Handle the base case for the first element in the array.
        if arr[0] <= k:
            prev[arr[0]] = True

        # Iterate through the elements in the array.
        for ind in range(1, n):
            # Initialize a new boolean array 'cur' for the current row.
            cur = [False] * (k + 1)
            cur[0] = True  # An empty subset can always achieve a sum of 0.

            # Fill in the 'cur' array using dynamic programming.
            for target in range(1, k + 1):
                # If the current element is not taken, the result is the same as the previous row.
                notTaken = prev[target]
                
                # If the current element is taken, subtract its value from the target and check the previous row.
                taken = False
                if arr[ind] <= target:
                    taken = prev[target - arr[ind]]
                
                # Update the 'cur' array with the result of taking or not taking the current element.
                cur[target] = notTaken or taken
            
            # Update 'prev' to 'cur' for the next iteration.
            prev = cur
        
        # The final result is stored in 'prev[k]', indicating whether a subset with sum 'k' is possible.
        return prev[k]

def main():
    arr = [2, 3, 3, 3, 4, 5]
    n = len(arr)
    
    # Check if the array can be partitioned into two equal subsets and print the result.
    if canPartition(n, arr):
        print("The Array can be partitioned into two equal subsets")
    else:
        print("The Array cannot be partitioned into two equal subsets")

if __name__ == "__main__":
    main()

    


# 3 TODO : partition set into 2 subsets with min absolute sum diff (DP-16)
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/partition-set-into-2-subsets-with-min-absolute-sum-diff-dp-16/


https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/


'''


# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
'''
Time Complexity: O(N*totSum) +O(N) +O(N)

Reason: There are two nested loops that account for O(N*totSum), at starting we are running a for loop to calculate totSum and at last a for loop to traverse the last row.

Space Complexity: O(N*totSum) + O(N)

Reason: We are using an external array of size â€˜N * totSumâ€™ and a stack space of O(N).
'''
def subsetSumUtil(ind, target, arr, dp):
    # Base case: If the target sum is 0, we have found a subset that sums to the target.
    if target == 0:
        return True

    # Base case: If we have reached the first element of the array, check if it equals the target.
    if ind == 0:
        return arr[0] == target

    # Check if the result for this combination of 'ind' and 'target' has already been computed.
    if dp[ind][target] != -1:
        return dp[ind][target]

    # Recursive cases:
    # 1. Try not taking the current element.
    notTaken = subsetSumUtil(ind - 1, target, arr, dp)

    # 2. Try taking the current element if it is less than or equal to the target.
    taken = False
    if arr[ind] <= target:
        taken = subsetSumUtil(ind - 1, target - arr[ind], arr, dp)

    # Update the DP table and return the result.
    dp[ind][target] = notTaken or taken
    return dp[ind][target]

def minSubsetSumDifference(arr):
    n = len(arr)
    totSum = sum(arr)

    # Initialize a DP table to store the subset sum information.
    dp = [[-1 for i in range(totSum + 1)] for j in range(n)]

    # Calculate dummy values for all possible sums using subsetSumUtil.
    for i in range(totSum + 1):
        dummy = subsetSumUtil(n - 1, i, arr, dp)

    # Initialize a variable to track the minimum absolute difference.
    mini = int(1e9)

    # Iterate through all possible sums.
    for i in range(totSum + 1):
        if dp[n - 1][i] == True:
            # Calculate the difference between the current sum and the complement sum.
            diff = abs(i - (totSum - i))
            mini = min(mini, diff)

    return mini

def main():
    arr = [1, 2, 3, 4]
    print("The minimum absolute difference is:", minSubsetSumDifference(arr))

if __name__ == "__main__":
    main()




# method 2 : tabulation
'''
Time Complexity: O(N*totSum) +O(N) +O(N)

Reason: There are two nested loops that account for O(N*totSum), at starting we are running a for loop to calculate totSum, and at last a for loop to traverse the last row.

Space Complexity: O(N*totSum)

Reason: We are using an external array of size â€˜N * totSumâ€™. Stack Space is eliminated.
'''
def minSubsetSumDifference(arr, n):
    # Calculate the total sum of the array elements.
    totSum = sum(arr)

    # Initialize a DP table to store subset sum information.
    dp = [[False for i in range(totSum + 1)] for j in range(n)]

    # Initialize the base cases for the DP table.
    for i in range(n):
        dp[i][0] = True

    # Handle the base case for the first element in the array.
    if arr[0] <= totSum:
        dp[0][arr[0]] = True

    # Fill in the DP table using dynamic programming.
    for ind in range(1, n):
        for target in range(1, totSum + 1):
            # If the current element is not taken, the result is the same as the previous row.
            notTaken = dp[ind - 1][target]

            # If the current element is taken, subtract its value from the target and check the previous row.
            taken = False
            if arr[ind] <= target:
                taken = dp[ind - 1][target - arr[ind]]

            # Update the DP table with the result of taking or not taking the current element.
            dp[ind][target] = notTaken or taken

    # Initialize a variable to track the minimum absolute difference.
    mini = int(1e9)

    # Iterate through all possible sums.
    for i in range(totSum + 1):
        if dp[n - 1][i] == True:
            # Calculate the difference between the current sum and the complement sum.
            diff = abs(i - (totSum - i))
            mini = min(mini, diff)

    return mini

def main():
    arr = [1, 2, 3, 4]
    n = len(arr)

    # Find and print the minimum absolute difference between two subsets.
    print("The minimum absolute difference is:", minSubsetSumDifference(arr, n))

if __name__ == '__main__':
    main()

  


# method 3 : space optimization
'''
Time Complexity: O(N*totSum) +O(N) +O(N)

Reason: There are two nested loops that account for O(N*totSum), at starting we are running a for loop to calculate totSum and at last a for loop to traverse the last row.

Space Complexity: O(totSum)

Reason: We are using an external array of size â€˜totSum+1â€™ to store only one row.
'''
def minSubsetSumDifference(arr, n):
    # Calculate the total sum of the array elements.
    totSum = sum(arr)
    
    # Initialize a boolean array 'prev' to store the results for the previous row.
    prev = [False] * (totSum + 1)
    prev[0] = True  # Base case: An empty subset can always achieve a sum of 0.

    # Handle the base case for the first element in the array.
    if arr[0] <= totSum:
        prev[arr[0]] = True

    # Iterate through the elements in the array.
    for ind in range(1, n):
        # Initialize a new boolean array 'cur' for the current row.
        cur = [False] * (totSum + 1)
        cur[0] = True  # An empty subset can always achieve a sum of 0.

        # Fill in the 'cur' array using dynamic programming.
        for target in range(1, totSum + 1):
            # If the current element is not taken, the result is the same as the previous row.
            notTaken = prev[target]

            # If the current element is taken, subtract its value from the target and check the previous row.
            taken = prev[target - arr[ind]] if arr[ind] <= target else False

            # Update the 'cur' array with the result of taking or not taking the current element.
            cur[target] = notTaken or taken

        # Update 'prev' to 'cur' for the next iteration.
        prev = cur

    # Initialize a variable to track the minimum absolute difference.
    mini = int(1e9)

    # Iterate through all possible sums.
    for i in range(totSum + 1):
        if prev[i]:
            # Calculate the difference between the current sum and the complement sum.
            diff = abs(i - (totSum - i))
            mini = min(mini, diff)

    return mini

def main():
    arr = [1, 2, 3, 4]
    n = len(arr)
    
    # Find and print the minimum absolute difference between two subsets.
    print("The minimum absolute difference is:", minSubsetSumDifference(arr, n))

if __name__ == "__main__":
    main()



# 4 TODO : count subsets with sum K (DP-17)
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://takeuforward.org/data-structure/count-subsets-with-sum-k-dp-17/


https://bit.ly/3AwVr8I


'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
Time Complexity: O(N*K)

Reason: There are N*K states therefore at max â€˜N*Kâ€™ new problems will be solved.

Space Complexity: O(N*K) + O(N)

Reason: We are using a recursion stack space(O(N)) and a 2D array ( O(N*K)).

def findWays(num, k):
    n = len(num)
    
    # Initialize a 2D DP array to store the count of subsets for different targets.
    dp = [[0] * (k + 1) for _ in range(n)]
    
    # Base case: There is always one way to make a subset with a target sum of 0 (empty subset).
    for i in range(n):
        dp[i][0] = 1
    
    # Handle the base case for the first element in the array.
    if num[0] <= k:
        dp[0][num[0]] = 1

    # Iterate through the elements in the array.
    for ind in range(1, n):
        for target in range(1, k + 1):
            # If the current element is not taken, the count is the same as the previous row.
            notTaken = dp[ind - 1][target]
            
            # If the current element is taken, subtract its value from the target and check the previous row.
            taken = 0
            if num[ind] <= target:
                taken = dp[ind - 1][target - num[ind]]
            
            # Update the DP array with the total count of ways (taken + notTaken).
            dp[ind][target] = notTaken + taken

    # The result is stored in the bottom-right cell of the DP array.
    return dp[n - 1][k]

def main():
    arr = [1, 2, 2, 3]
    k = 3
    
    # Find and print the number of subsets that can be formed with a sum of 'k'.
    print("The number of subsets found are", findWays(arr, k))

if __name__ == "__main__":
    main()




# method 2 : tabulation
Time Complexity: O(N*K)

Reason: There are two nested loops

Space Complexity: O(N*K)

Reason: We are using an external array of size â€˜N*Kâ€™. Stack Space is eliminated.

def findWays(num, k):
    n = len(num)
    
    # Initialize a 2D DP array to store the count of subsets for different targets.
    dp = [[0] * (k + 1) for _ in range(n)]
    
    # Base case: There is always one way to make a subset with a target sum of 0 (empty subset).
    for i in range(n):
        dp[i][0] = 1
    
    # Handle the base case for the first element in the array.
    if num[0] <= k:
        dp[0][num[0]] = 1

    # Iterate through the elements in the array.
    for ind in range(1, n):
        for target in range(1, k + 1):
            # If the current element is not taken, the count is the same as the previous row.
            notTaken = dp[ind - 1][target]
            
            # If the current element is taken, subtract its value from the target and check the previous row.
            taken = 0
            if num[ind] <= target:
                taken = dp[ind - 1][target - num[ind]]
            
            # Update the DP array with the total count of ways (taken + notTaken).
            dp[ind][target] = notTaken + taken

    # The result is stored in the bottom-right cell of the DP array.
    return dp[n - 1][k]

def main():
    arr = [1, 2, 2, 3]
    k = 3
    
    # Find and print the number of subsets that can be formed with a sum of 'k'.
    print("The number of subsets found are", findWays(arr, k))

if __name__ == "__main__":
    main()




# method 3 : space optimization
Time Complexity: O(N*K)

Reason: There are two nested loops

Space Complexity: O(K)

Reason: We are using an external array of size â€˜K+1â€™ to store only one row.

def findWays(num, k):
    n = len(num)

    # Initialize a list 'prev' to store the count of subsets for different targets.
    prev = [0 for i in range(k + 1)]
    
    # Base case: There is always one way to make a subset with a target sum of 0 (empty subset).
    prev[0] = 1
    
    # Handle the base case for the first element in the array.
    if num[0] <= k:
        prev[num[0]] = 1
    
    # Iterate through the elements in the array.
    for ind in range(1, n):
        # Initialize a new list 'cur' to store the count for the current row.
        cur = [0 for i in range(k + 1)]
        cur[0] = 1
        
        for target in range(1, k + 1):
            # If the current element is not taken, the count is the same as the previous row.
            notTaken = prev[target]
    
            # If the current element is taken, subtract its value from the target and check the previous row.
            taken = 0
            if num[ind] <= target:
                taken = prev[target - num[ind]]
        
            # Update the 'cur' list with the total count of ways (taken + notTaken).
            cur[target] = notTaken + taken
        
        # Update 'prev' to 'cur' for the next iteration.
        prev = cur
    
    # The result is stored in 'prev[k]', indicating the count of subsets that can be formed with a sum of 'k'.
    return prev[k]

def main():
    arr = [1, 2, 2, 3]
    k = 3
    
    # Find and print the number of subsets that can be formed with a sum of 'k'.
    print("The number of subsets found are", findWays(arr, k))

if __name__ == "__main__":
    main()

  


# 5 TODO : count partitions with given difference (DP-18)
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/count-partitions-with-given-difference-dp-18/


https://bit.ly/3gkAM0s


'''


# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
Time Complexity: O(N*K)

Reason: There are N*K states therefore at max â€˜N*Kâ€™ new problems will be solved.

Space Complexity: O(N*K) + O(N)

Reason: We are using a recursion stack space(O(N)) and a 2D array ( O(N*K)).
mod = int(1e9 + 7)

def countPartitionsUtil(ind, target, arr, dp):
    if ind == 0:
        if target == 0 and arr[0] == 0:
            return 2
        if target == 0 or target == arr[0]:
            return 1
        return 0
    
    if dp[ind][target] != -1:
        return dp[ind][target]
        
    notTaken = countPartitionsUtil(ind-1, target, arr, dp)
    
    taken = 0
    if arr[ind] <= target:
        taken = countPartitionsUtil(ind-1, target-arr[ind], arr, dp)
        
    dp[ind][target] = (notTaken + taken) % mod
    return dp[ind][target]

def countPartitions(d, arr):
    n = len(arr)
    totSum = sum(arr)
    
    # Checking for edge cases
    if totSum - d < 0:
        return 0
    if (totSum - d) % 2 == 1:
        return 0
    
    s2 = (totSum - d) // 2
    
    dp = [[-1 for j in range(s2 + 1)] for i in range(n)]
    return countPartitionsUtil(n-1, s2, arr, dp)

def main():
    arr = [5, 2, 6, 4]
    d = 3

    print("The number of subsets found are", countPartitions(d, arr))

if __name__ == "__main__":
    main() 


# method 2 : tabulation
mod=int(1e9+7)
def findWays(num, tar):
    n = len(num)
    dp = [[0] * (tar + 1) for _ in range(n)]
    
    if num[0] == 0:
        dp[0][0] = 2 # 2 cases - pick and not pick
    else:
        dp[0][0] = 1 # 1 case - not pick
    
    if num[0] != 0 and num[0] <= tar:
        dp[0][num[0]] = 1 # 1 case - pick
    
    for ind in range(1, n):
        for target in range(tar + 1):
            notTaken = dp[ind - 1][target]
            taken = 0
            if num[ind] <= target:
                taken = dp[ind - 1][target - num[ind]]
        
            dp[ind][target] = (notTaken + taken) % mod
    return dp[n - 1][tar]

def countPartitions(n, d, arr):
    totSum = sum(arr)
    
    # Checking for edge cases
    if (totSum - d) < 0 or (totSum - d) % 2:
        return 0
    
    return findWays(arr, (totSum - d) // 2)

def main():
  arr = [5, 2, 6, 4]
  n = len(arr)
  d = 3
  print("The number of subsets found are", countPartitions(n, d, arr))
if __name__ == "__main__":
  main()  


# method 3 : space optimization
Time Complexity: O(N*K)

Reason: There are three nested loops

Space Complexity: O(K)

Reason: We are using an external array of size â€˜K+1â€™ to store only one row.
mod =int(1e9+7)

def findWays(num, tar):
    n = len(num)

    prev = [0] * (tar + 1)
    
    if num[0] == 0:
        prev[0] = 2  # 2 cases - pick and not pick
    else:
        prev[0] = 1  # 1 case - not pick
    
    if num[0] != 0 and num[0] <= tar:
        prev[num[0]] = 1  # 1 case - pick
    
    for ind in range(1, n):
        cur = [0] * (tar + 1)
        for target in range(tar + 1):
            notTaken = prev[target]
    
            taken = 0
            if num[ind] <= target:
                taken = prev[target - num[ind]]
        
            cur[target] = (notTaken + taken) % mod
        prev = cur
    return prev[tar]

def countPartitions(n, d, arr):
    totSum = 0
    for i in range(n):
        totSum += arr[i]
    
    # Checking for edge cases
    if totSum - d < 0 or (totSum - d) % 2:
        return 0
    
    return findWays(arr, (totSum - d) // 2)
  

def main():
    arr = [5, 2, 6, 4]
    n = len(arr)
    d = 3

    print("The number of subsets found are", countPartitions(n, d, arr))
if __name__ == '__main__':
  main()    


# 6 TODO : assign cookies
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://leetcode.com/problems/assign-cookies/



'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
# TC     -      
# SC     -     


# method 2 : tabulation
# TC     -      
# SC     -     


# method 3 : space optmization
# TC     -      
# SC     -      


# 7 TODO : minimum coins (DP-20)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/minimum-coins-dp-20/


https://leetcode.com/problems/coin-change/



'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
Time Complexity: O(N*T)

Reason: There are N*T states therefore at max â€˜N*Tâ€™ new problems will be solved.

Space Complexity: O(N*T) + O(N)

Reason: We are using a recursion stack space(O(N)) and a 2D array ( O(N*T)).

def minimumElementsUtil(arr, ind, T, dp):
    # Base case: If we have reached the first element in the array.
    if ind == 0:
        # If the target T is divisible by the first element, return the quotient as the minimum number of coins.
        if T % arr[0] == 0:
            return T // arr[0]
        else:
            # If not, it's not possible to achieve the target sum, so return a very large value.
            return int(1e9)

    # If the result for this state is already calculated, return it.
    if dp[ind][T] != -1:
        return dp[ind][T]

    # Initialize variables for cases when we don't take the current element.
    notTaken = 0 + minimumElementsUtil(arr, ind - 1, T, dp)

    # Initialize a variable for the case when we take the current element.
    taken = int(1e9)

    # Check if the current element can be used to reduce the target sum.
    if arr[ind] <= T:
        taken = 1 + minimumElementsUtil(arr, ind, T - arr[ind], dp)

    # Store the minimum of the two cases in the DP table.
    dp[ind][T] = min(notTaken, taken)
    return dp[ind][T]

def minimumElements(arr, T):
    n = len(arr)
    # Initialize a DP table with -1 values.
    dp = [[-1 for j in range(T + 1)] for i in range(n)]
    # Calculate the minimum number of coins required using the helper function.
    ans = minimumElementsUtil(arr, n - 1, T, dp)

    # If the result is still equal to a very large value, it means it's not possible to achieve the target sum.
    if ans >= int(1e9):
        return -1
    return ans

def main():
    arr = [1, 2, 3]
    T = 7
    print("The minimum number of coins required to form the target sum is", minimumElements(arr, T))

if __name__ == '__main__':
    main()

# method 2 : tabulation


Time Complexity: O(N*T)

Reason: There are two nested loops

Space Complexity: O(N*T)

Reason: We are using an external array of size â€˜N*Tâ€™. Stack Space is eliminated.

def minimumElements(arr, T):
    n = len(arr)
    # Initialize a DP table with 0 values for bottom-up dynamic programming.
    dp = [[0 for _ in range(T + 1)] for _ in range(n)]

    # Fill in the DP table for the first element in the array (base case).
    for i in range(T + 1):
        if i % arr[0] == 0:
            dp[0][i] = i // arr[0]
        else:
            # Set an initial large value to indicate that it's not possible to achieve the target sum.
            dp[0][i] = int(1e9)

    # Iterate over the array elements and target values to fill in the DP table.
    for ind in range(1, n):
        for target in range(T + 1):
            # Calculate the minimum number of elements needed to achieve the current target.
            notTake = dp[ind - 1][target]  # Option: Don't take the current element.
            take = int(1e9)  # Initialize as a large value.
            if arr[ind] <= target:
                # Option: Take the current element, reduce the target, and add 1 to the count.
                take = 1 + dp[ind][target - arr[ind]]
            # Store the minimum of the two options in the DP table.
            dp[ind][target] = min(notTake, take)

    # The result is stored in the last cell of the DP table.
    ans = dp[n - 1][T]
    # If the result is still equal to a very large value, it means it's not possible to achieve the target sum.
    if ans >= int(1e9):
        return -1
    return ans

def main():
    arr = [1, 2, 3]
    T = 7
    print("The minimum number of coins required to form the target sum is", minimumElements(arr, T))

if __name__ == "__main__":
    main()




# method 3 : space optimization
Time Complexity: O(N*T)

Reason: There are two nested loops.

Space Complexity: O(T)

Reason: We are using two external arrays of size â€˜T+1â€™.

def minimumElements(arr, T):
    n = len(arr)
    
    # Initialize two lists: 'prev' and 'cur' for dynamic programming.
    prev = [0] * (T + 1)  # To store results for the previous element.
    cur = [0] * (T + 1)   # To store results for the current element.

    # Fill in the DP table for the first element in the array (base case).
    for i in range(0, 1 + T):
        if i % arr[0] == 0:
            prev[i] = i // arr[0]
        else:
            # Set an initial large value to indicate that it's not possible to achieve the target sum.
            prev[i] = int(1e9)

    # Iterate over the array elements and target values to fill in the DP table.
    for ind in range(1, n):
        for target in range(T + 1):
            # Calculate the minimum number of elements needed to achieve the current target.
            not_take = prev[target]  # Option: Don't take the current element.
            take = int(1e9)          # Initialize as a large value.
            
            if arr[ind] <= target:
                # Option: Take the current element, reduce the target, and add 1 to the count.
                take = 1 + cur[target - arr[ind]]
                
            cur[target] = min(not_take, take)  # Store the minimum of the two options in the 'cur' list.

        prev = cur  # Update the 'prev' list with the values from the 'cur' list for the next iteration.

    # The result is stored in the 'prev' list for the target T.
    ans = prev[T]
    
    # If the result is still equal to a very large value, it means it's not possible to achieve the target sum.
    if ans >= int(1e9):
        return -1
    return ans

def main():
    arr = [1, 2, 3]
    T = 7

    print("The minimum number of coins required to form the target sum is", minimumElements(arr, T))

if __name__ == "__main__":
    main()




# 8 TODO : target sum (DP-21)
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/target-sum-dp-21/


https://leetcode.com/problems/target-sum/



'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
Time Complexity: O(N*K)

Reason: There are N*K states therefore at max â€˜N*Kâ€™ new problems will be solved.

Space Complexity: O(N*K) + O(N)

Reason: We are using a recursion stack space(O(N)) and a 2D array ( O(N*K)).

def countPartitionsUtil(ind, target, arr, dp):
    # Base case: If we have reached the first element in the array.
    if ind == 0:
        # Check if the target is zero and the first element is also zero, in which case there are two possibilities.
        if target == 0 and arr[0] == 0:
            return 2
        # If the target is equal to the first element, there is one possibility.
        if target == 0 or target == arr[0]:
            return 1
        # Otherwise, there is no valid partition.
        return 0

    # If the result for this state is already calculated, return it.
    if dp[ind][target] != -1:
        return dp[ind][target]

    # Calculate the number of possibilities when the current element is not taken.
    notTaken = countPartitionsUtil(ind - 1, target, arr, dp)
    
    # Initialize a variable for the number of possibilities when the current element is taken.
    taken = 0
    if arr[ind] <= target:
        taken = countPartitionsUtil(ind - 1, target - arr[ind], arr, dp)

    # Store the total number of possibilities in the DP table.
    dp[ind][target] = notTaken + taken
    return dp[ind][target]

def targetSum(n, target, arr):
    totSum = 0
    for i in range(len(arr)):
        totSum += arr[i]

    # Checking for edge cases
    if totSum - target < 0:
        return 0
    if (totSum - target) % 2 == 1:
        return 0

    s2 = (totSum - target) // 2

    dp = [[-1 for j in range(s2 + 1)] for i in range(n)]
    return countPartitionsUtil(n - 1, s2, arr, dp)

def main():
    arr = [1, 2, 3, 1]
    target = 3
    n = len(arr)
    print("The number of ways found is", targetSum(n, target, arr))

if __name__ == '__main__':
    main()




# method 2 : tabulation
Time Complexity: O(N*K)

Reason: There are two nested loops

Space Complexity: O(N*K)

Reason: We are using an external array of size â€˜N*Kâ€™. Stack Space is eliminated.

mod = int(1e9 + 7)

def findWays(num, tar):
    n = len(num)
    dp = [[0 for i in range(tar + 1)] for j in range(n)]

    if num[0] == 0:
        dp[0][0] = 2  # 2 cases - pick and not pick
    else:
        dp[0][0] = 1  # 1 case - not pick

    if num[0] != 0 and num[0] <= tar:
        dp[0][num[0]] = 1  # 1 case - pick

    for ind in range(1, n):
        for target in range(tar + 1):
            notTaken = dp[ind - 1][target]

            taken = 0
            if num[ind] <= target:
                taken = dp[ind - 1][target - num[ind]]

            dp[ind][target] = (notTaken + taken) % mod

    return dp[n - 1][tar]

def targetSum(n, target, arr):
    totSum = 0
    for i in range(n):
        totSum += arr[i]

    # Checking for edge cases
    if (totSum - target) < 0 or ((totSum - target) % 2):
        return 0

    return findWays(arr, (totSum - target) // 2)

def main():
    arr = [1, 2, 3, 1]
    target = 3
    n = len(arr)

    print("The number of ways found is", targetSum(n, target, arr))

if __name__ == "__main__":
    main()




# method 3 : space optimization
Time Complexity: O(N*K)

Reason: There are three nested loops

Space Complexity: O(K)

Reason: We are using an external array of size â€˜K+1â€™ to store only one row.   

mod = int(1e9 + 7)

# Function to find the number of ways to partition an array into two subsets
# with a given target difference using dynamic programming
def findWays(num, tar):
    n = len(num)

    # Initialize a list 'prev' to store results for the previous element
    prev = [0 for i in range(tar + 1)]

    # Initialize 'prev' based on the first element of 'num'
    if num[0] == 0:
        prev[0] = 2  # Two cases - pick and not pick
    else:
        prev[0] = 1  # One case - not pick

    if num[0] != 0 and num[0] <= tar:
        prev[num[0]] = 1  # One case - pick

    for ind in range(1, n):
        # Initialize a list 'cur' to store results for the current element
        cur = [0 for i in range(tar + 1)]
        for target in range(tar + 1):
            notTaken = prev[target]

            taken = 0
            if num[ind] <= target:
                taken = prev[target - num[ind]]

            # Store the result in 'cur' with modulo operation
            cur[target] = (notTaken + taken) % mod
        prev = cur

    # Return the result for the target sum
    return prev[tar]

# Function to calculate the number of ways to achieve a target sum
def targetSum(n, target, arr):
    totSum = 0
    for i in range(n):
        totSum += arr[i]

    # Checking for edge cases
    if (totSum - target) < 0 or ((totSum - target) % 2):
        return 0

    # Calculate and return the number of ways using 'findWays' function
    return findWays(arr, (totSum - target) // 2)

def main():
    arr = [1, 2, 3, 1]
    target = 3
    n = len(arr)

    # Print the number of ways found
    print("The number of ways found is", targetSum(n, target, arr))

if __name__ == "__main__":
    main()




# 9 TODO : coin change 2 (DP-22)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/coin-change-2-dp-22/


https://leetcode.com/problems/coin-change-2/


'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
Time Complexity: O(N*T)

Reason: There are N*W states therefore at max â€˜N*Tâ€™ new problems will be solved.

Space Complexity: O(N*T) + O(N)

Reason: We are using a recursion stack space(O(N)) and a 2D array ( O(N*T)).

def countWaysToMakeChangeUtil(arr, ind, T, dp):
    # Base case: If we have reached the first element in the array.
    if ind == 0:
        return 1 if T % arr[0] == 0 else 0

    # If the result for this state is already calculated, return it.
    if dp[ind][T] != -1:
        return dp[ind][T]

    # Calculate the number of ways when the current element is not taken.
    not_taken = countWaysToMakeChangeUtil(arr, ind - 1, T, dp)

    # Initialize a variable for the number of ways when the current element is taken.
    taken = 0
    if arr[ind] <= T:
        taken = countWaysToMakeChangeUtil(arr, ind, T - arr[ind], dp)

    # Store the total number of ways in the DP table.
    dp[ind][T] = not_taken + taken
    return dp[ind][T]

# Function to count the number of ways to make change for a given target amount
def countWaysToMakeChange(arr, n, T):
    # Create a DP table with initial values as -1.
    dp = [[-1 for i in range(T + 1)] for j in range(n)]
    return countWaysToMakeChangeUtil(arr, n - 1, T, dp)

def main():
    arr = [1, 2, 3]
    target = 4
    n = len(arr)
    print("The total number of ways is", countWaysToMakeChange(arr, n, target))

if __name__ == "__main__":
    main()





# method 2 : tabulation
Time Complexity: O(N*T)

Reason: There are two nested loops

Space Complexity: O(N*T)

Reason: We are using an external array of size â€˜N*Tâ€™. Stack Space is eliminated.

def countWaysToMakeChange(arr, n, T):
    # Create a DP table to store the number of ways for different target amounts
    dp = [[0 for j in range(T + 1)] for i in range(n)]
    
    # Initialize the base condition for the first element in the array
    for i in range(T + 1):
        if i % arr[0] == 0:
            dp[0][i] = 1
        # Else condition is automatically fulfilled, as dp array is initialized to zero

    # Iterate through the array elements and target amounts
    for ind in range(1, n):
        for target in range(T + 1):
            # Calculate the number of ways when the current element is not taken
            notTaken = dp[ind - 1][target]

            # Initialize a variable for the number of ways when the current element is taken
            taken = 0
            if arr[ind] <= target:
                taken = dp[ind][target - arr[ind]]

            # Store the total number of ways in the DP table
            dp[ind][target] = notTaken + taken

    # Return the total number of ways for the given target amount
    return dp[n - 1][T]

def main():
    arr = [1, 2, 3]
    target = 4
    n = len(arr)
    print("The total number of ways is", countWaysToMakeChange(arr, n, target))

if __name__ == "__main__":
    main()




# method 3 : space optimization
Time Complexity: O(N*T)

Reason: There are two nested loops.

Space Complexity: O(T)

Reason: We are using an external array of size â€˜T+1â€™ to store two rows only.

def countWaysToMakeChange(arr, n, T):
    # Initialize a list 'prev' to store the number of ways for different target amounts
    prev = [0] * (T + 1)
    
    # Initialize the base condition for the first element in the array
    for i in range(T + 1):
        if i % arr[0] == 0:
            prev[i] = 1
    # Else condition is automatically fulfilled, as 'prev' is initialized to zeros.

    # Iterate through the array elements and target amounts
    for ind in range(1, n):
        # Initialize a list 'cur' to store the number of ways for the current element
        cur = [0] * (T + 1)
        for target in range(T + 1):
            # Calculate the number of ways when the current element is not taken
            notTaken = prev[target]

            # Initialize a variable for the number of ways when the current element is taken
            taken = 0
            if arr[ind] <= target:
                taken = cur[target - arr[ind]]

            # Store the total number of ways in 'cur'
            cur[target] = notTaken + taken
        
        # Update 'prev' with the results from 'cur' for the next iteration
        prev = cur

    # Return the total number of ways for the given target amount
    return prev[T]

def main():
    arr = [1, 2, 3]
    target = 4
    n = len(arr)

    print("The total number of ways is", countWaysToMakeChange(arr, n, target))

if __name__ == '__main__':
    main()




# 10 TODO :  unbounded knapsack (DP-23)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/unbounded-knapsack-dp-23/


https://bit.ly/3Cbc5fz


'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
Time Complexity: O(N*W)

Reason: There are N*W states therefore at max â€˜N*Wâ€™ new problems will be solved.

Space Complexity: O(N*W) + O(N)

Reason: We are using a recursion stack space(O(N)) and a 2D array ( O(N*W)).

import sys

# Recursive function to solve the unbounded knapsack problem
def knapsackUtil(wt, val, ind, W, dp):
    # Base case: If there are no more items to consider (index is 0)
    if ind == 0:
        return (W // wt[0]) * val[0]

    # If the result for this state is already calculated, return it
    if dp[ind][W] != -1:
        return dp[ind][W]

    # Calculate the maximum value when the current item is not taken
    notTaken = knapsackUtil(wt, val, ind - 1, W, dp)

    # Initialize a variable to store the maximum value when the current item is taken
    taken = -sys.maxsize
    if wt[ind] <= W:
        taken = val[ind] + knapsackUtil(wt, val, ind, W - wt[ind], dp)

    # Store the maximum of "notTaken" and "taken" in the DP table
    dp[ind][W] = max(notTaken, taken)
    return dp[ind][W]

# Function to find the maximum value that can be obtained in unbounded knapsack
def unboundedKnapsack(n, W, val, wt):
    # Create a DP table initialized with -1
    dp = [[-1 for _ in range(W + 1)] for _ in range(n)]
    return knapsackUtil(wt, val, n - 1, W, dp)

def main():
    wt = [2, 4, 6]
    val = [5, 11, 13]
    W = 10
    n = len(wt)

    print("The Maximum value of items the thief can steal is", unboundedKnapsack(n, W, val, wt))

if __name__ == "__main__":
    main()





# method 2 : tabulation
Time Complexity: O(N*W)

Reason: There are two nested loops

Space Complexity: O(N*W)

Reason: We are using an external array of size â€˜N*Wâ€™. Stack Space is eliminated.

import sys

# Function to solve the unbounded knapsack problem using dynamic programming
def unboundedKnapsack(n, W, val, wt):
    # Create a DP table to store the maximum value for different capacities
    dp = [[0 for j in range(W + 1)] for i in range(n)]

    # Initialize the base condition for the first item
    for i in range(wt[0], W + 1, wt[0]):
        dp[0][i] = ((i // wt[0]) * val[0])

    # Fill in the DP table for the remaining items and capacities
    for ind in range(1, n):
        for cap in range(W + 1):
            # Calculate the maximum value when the current item is not taken
            notTaken = 0 + dp[ind - 1][cap]

            # Initialize a variable to store the maximum value when the current item is taken
            taken = -sys.maxsize
            if wt[ind] <= cap:
                taken = val[ind] + dp[ind][cap - wt[ind]]

            # Store the maximum of "notTaken" and "taken" in the DP table
            dp[ind][cap] = max(notTaken, taken)

    # The maximum value for the entire knapsack is at dp[n-1][W]
    return dp[n - 1][W]

def main():
    wt = [2, 4, 6]
    val = [5, 11, 13]
    W = 10
    n = len(wt)

    print("The Maximum value of items the thief can steal is", unboundedKnapsack(n, W, val, wt))

if __name__ == "__main__":
    main()





# method 3 : space optimization
Time Complexity: O(N*W)

Reason: There are two nested loops.

Space Complexity: O(W)

Reason: We are using an external array of size â€˜W+1â€™ to store only one row.

import sys

# Function to solve the unbounded knapsack problem using dynamic programming
def unboundedKnapsack(n, W, val, wt):
    # Create a list 'cur' to store the maximum value for different capacities
    cur = [0] * (W + 1)

    # Initialize the base condition for the first item
    for i in range(wt[0], W + 1):
        cur[i] = (i // wt[0]) * val[0]

    # Fill in the 'cur' list for the remaining items and capacities
    for ind in range(1, n):
        for cap in range(W + 1):
            # Calculate the maximum value when the current item is not taken
            notTaken = cur[cap]

            # Initialize a variable to store the maximum value when the current item is taken
            taken = -sys.maxsize
            if wt[ind] <= cap:
                taken = val[ind] + cur[cap - wt[ind]]

            # Store the maximum of "notTaken" and "taken" in the 'cur' list
            cur[cap] = max(notTaken, taken)

    # The maximum value for the entire knapsack is at 'cur[W]'
    return cur[W]

def main():
    wt = [2, 4, 6]
    val = [5, 11, 13]
    W = 10
    n = len(wt)

    print("The Maximum value of items the thief can steal is", unboundedKnapsack(n, W, val, wt))

if __name__ == "__main__":
    main()




# 11 TODO : red cutting problem (DP-24)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/rod-cutting-problem-dp-24/

https://practice.geeksforgeeks.org/problems/rod-cutting0840/1'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
Time Complexity: O(N*W)

Reason: There are N*W states therefore at max â€˜N*Wâ€™ new problems will be solved.

Space Complexity: O(N*W) + O(N)

Reason: We are using a recursion stack space(O(N)) and a 2D array ( O(N*W)).

import sys

# Recursive function to solve the unbounded knapsack problem
def knapsackUtil(wt, val, ind, W, dp):
    # Base case: If there are no more items to consider (index is 0)
    if ind == 0:
        return (W // wt[0]) * val[0]

    # If the result for this state is already calculated, return it
    if dp[ind][W] != -1:
        return dp[ind][W]

    # Calculate the maximum value when the current item is not taken
    notTaken = knapsackUtil(wt, val, ind - 1, W, dp)

    # Initialize a variable to store the maximum value when the current item is taken
    taken = -sys.maxsize
    if wt[ind] <= W:
        taken = val[ind] + knapsackUtil(wt, val, ind, W - wt[ind], dp)

    # Store the maximum of "notTaken" and "taken" in the DP table
    dp[ind][W] = max(notTaken, taken)
    return dp[ind][W]

# Function to find the maximum value that can be obtained in unbounded knapsack
def unboundedKnapsack(n, W, val, wt):
    # Create a DP table initialized with -1
    dp = [[-1 for _ in range(W + 1)] for _ in range(n)]
    return knapsackUtil(wt, val, n - 1, W, dp)

def main():
    wt = [2, 4, 6]
    val = [5, 11, 13]
    W = 10
    n = len(wt)

    print("The Maximum value of items the thief can steal is", unboundedKnapsack(n, W, val, wt))

if __name__ == "__main__":
    main()





# method 2 : tabulation
Time Complexity: O(N*W)

Reason: There are two nested loops

Space Complexity: O(N*W)

Reason: We are using an external array of size â€˜N*Wâ€™. Stack Space is eliminated.

import sys

# Function to solve the unbounded knapsack problem using dynamic programming
def unboundedKnapsack(n, W, val, wt):
    # Create a DP table to store the maximum value for different capacities
    dp = [[0 for j in range(W + 1)] for i in range(n)]

    # Initialize the base condition for the first item
    for i in range(wt[0], W + 1, wt[0]):
        dp[0][i] = ((i // wt[0]) * val[0])

    # Fill in the DP table for the remaining items and capacities
    for ind in range(1, n):
        for cap in range(W + 1):
            # Calculate the maximum value when the current item is not taken
            notTaken = 0 + dp[ind - 1][cap]

            # Initialize a variable to store the maximum value when the current item is taken
            taken = -sys.maxsize
            if wt[ind] <= cap:
                taken = val[ind] + dp[ind][cap - wt[ind]]

            # Store the maximum of "notTaken" and "taken" in the DP table
            dp[ind][cap] = max(notTaken, taken)

    # The maximum value for the entire knapsack is at dp[n-1][W]
    return dp[n - 1][W]

def main():
    wt = [2, 4, 6]
    val = [5, 11, 13]
    W = 10
    n = len(wt)

    print("The Maximum value of items the thief can steal is", unboundedKnapsack(n, W, val, wt))

if __name__ == "__main__":
    main()





# method 3 : space optimization
Time Complexity: O(N*W)

Reason: There are two nested loops.

Space Complexity: O(W)

Reason: We are using an external array of size â€˜W+1â€™ to store only one row.

import sys

# Function to solve the unbounded knapsack problem using dynamic programming
def unboundedKnapsack(n, W, val, wt):
    # Create a list 'cur' to store the maximum value for different capacities
    cur = [0] * (W + 1)

    # Initialize the base condition for the first item
    for i in range(wt[0], W + 1):
        cur[i] = (i // wt[0]) * val[0]

    # Fill in the 'cur' list for the remaining items and capacities
    for ind in range(1, n):
        for cap in range(W + 1):
            # Calculate the maximum value when the current item is not taken
            notTaken = cur[cap]

            # Initialize a variable to store the maximum value when the current item is taken
            taken = -sys.maxsize
            if wt[ind] <= cap:
                taken = val[ind] + cur[cap - wt[ind]]

            # Store the maximum of "notTaken" and "taken" in the 'cur' list
            cur[cap] = max(notTaken, taken)

    # The maximum value for the entire knapsack is at 'cur[W]'
    return cur[W]

def main():
    wt = [2, 4, 6]
    val = [5, 11, 13]
    W = 10
    n = len(wt)

    print("The Maximum value of items the thief can steal is", unboundedKnapsack(n, W, val, wt))

if __name__ == "__main__":
    main()





# endregion





# region 16.5 DP - STRINGS
# ------------------------

# 1 TODO :  longest common subsequence (DP-25)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/longest-common-subsequence-dp-25/


https://leetcode.com/problems/longest-common-subsequence/

https://www.youtube.com/watch?v=NPZn9jBrX8U&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=206
'''


# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
'''
Time Complexity: O(N*M)

Reason: There are N*M states therefore at max â€˜N*Mâ€™ new problems will be solved.

Space Complexity: O(N*M) + O(N+M)

Reason: We are using an auxiliary recursion stack space(O(N+M)) (see the recursive tree, in the worst case, we will go till N+M calls at a time) and a 2D array ( O(N*M)).
'''
def lcsUtil(s1, s2, ind1, ind2, dp):
    # Base case: If either of the strings has reached the end
    if ind1 < 0 or ind2 < 0:
        return 0
    
    # If the result for this state is already calculated, return it
    if dp[ind1][ind2] != -1:
        return dp[ind1][ind2]
    
    # If the characters at the current indices match, include them in the LCS
    if s1[ind1] == s2[ind2]:
        dp[ind1][ind2] = 1 + lcsUtil(s1, s2, ind1 - 1, ind2 - 1, dp)
    else:
        # If the characters do not match, consider both possibilities:
        # 1. Exclude character from s1 and continue matching in s2
        # 2. Exclude character from s2 and continue matching in s1
        dp[ind1][ind2] = max(lcsUtil(s1, s2, ind1, ind2 - 1, dp), lcsUtil(s1, s2, ind1 - 1, ind2, dp))
    
    return dp[ind1][ind2]

def lcs(s1, s2):
    n = len(s1)
    m = len(s2)
    dp = [[-1 for j in range(m)] for i in range(n)]
    return lcsUtil(s1, s2, n - 1, m - 1, dp)

def main():
    s1 = "acd"
    s2 = "ced"
    print("The Length of Longest Common Subsequence is", lcs(s1, s2))

if __name__ == '__main__':
    main()



# method 2 : tabulation
'''
Time Complexity: O(N*M)

Reason: There are two nested loops

Space Complexity: O(N*M)

Reason: We are using an external array of size â€˜N*M)â€™. Stack Space is eliminated.
'''
def lcs(s1, s2):
    n = len(s1)
    m = len(s2)
    
    # Create a DP table of size (n+1) x (m+1) initialized with -1
    dp = [[-1 for j in range(m + 1)] for i in range(n + 1)]

    # Initialize the base cases:
    # - The length of LCS with an empty string is 0, so dp[i][0] = 0 for all i
    # - The length of LCS with an empty string is 0, so dp[0][j] = 0 for all j
    for i in range(n + 1):
        dp[i][0] = 0
    for j in range(m + 1):
        dp[0][j] = 0

    # Fill in the DP table by considering characters from both strings
    for ind1 in range(1, n + 1):
        for ind2 in range(1, m + 1):
            if s1[ind1 - 1] == s2[ind2 - 1]:
                # If the characters match, increment the LCS length
                dp[ind1][ind2] = 1 + dp[ind1 - 1][ind2 - 1]
            else:
                # If the characters do not match, take the maximum of
                # LCS length without one character from s1 or s2
                dp[ind1][ind2] = max(dp[ind1 - 1][ind2], dp[ind1][ind2 - 1])
    
    # The value in dp[n][m] represents the length of the Longest Common Subsequence
    return dp[n][m]

def main():
    s1 = "acd"
    s2 = "ced"
    print("The Length of Longest Common Subsequence is", lcs(s1, s2))

if __name__ == "__main__":
    main()




# method 3 : space optimization
'''
Time Complexity: O(N*M)

Reason: There are two nested loops.

Space Complexity: O(M)

Reason: We are using an external array of size â€˜M+1â€™ to store only two rows.
'''
def lcs(s1, s2):
    n = len(s1)
    m = len(s2)

    # Initialize two arrays, 'prev' and 'cur', to store the DP values
    prev = [0] * (m + 1)
    cur = [0] * (m + 1)

    # Loop through the characters of both strings to compute LCS
    for ind1 in range(1, n + 1):
        for ind2 in range(1, m + 1):
            if s1[ind1 - 1] == s2[ind2 - 1]:
                # If the characters match, increment LCS length by 1
                cur[ind2] = 1 + prev[ind2 - 1]
            else:
                # If the characters do not match, take the maximum of LCS
                # by excluding one character from s1 or s2
                cur[ind2] = max(prev[ind2], cur[ind2 - 1])
        
        # Update 'prev' to be the same as 'cur' for the next iteration
        prev = cur[:]

    # The value in 'prev[m]' represents the length of the Longest Common Subsequence
    return prev[m]

def main():
    s1 = "acd"
    s2 = "ced"

    print("The Length of Longest Common Subsequence is", lcs(s1, s2))

if __name__ == '__main__':
    main()




# 2 TODO : print longest common subsequence (DP-26)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/print-longest-common-subsequence-dp-26/


https://bit.ly/3T1Va4U

https://www.youtube.com/watch?v=-zI4mrF2Pb4&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=207
'''


# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
'''
Time Complexity: O(N*M)

Reason: There are two nested loops

Space Complexity: O(N*M)

Reason: We are using an external array of size â€˜N*Mâ€™. Stack Space is eliminated.
'''
def lcs(s1, s2):
    n = len(s1)
    m = len(s2)
    
    dp = [[0 for j in range(m + 1)] for i in range(n + 1)]
    for i in range(n + 1):
        dp[i][0] = 0
    for i in range(m + 1):
        dp[0][i] = 0

    for ind1 in range(1, n + 1):
        for ind2 in range(1, m + 1):
            if s1[ind1 - 1] == s2[ind2 - 1]:
                dp[ind1][ind2] = 1 + dp[ind1 - 1][ind2 - 1]
            else:
                dp[ind1][ind2] = 0+max(dp[ind1 - 1][ind2], dp[ind1][ind2 - 1])

    len_ = dp[n][m]
    i = n
    j = m
    
    index = len_ - 1
    str_ = ""
    for k in range(1,1+len_):
      str_+="$" #dummy string
    
    while i > 0 and j > 0:
        if s1[i - 1] == s2[j - 1]:
            str_ = s1[i - 1] + str_[:-1]
            index -= 1
            i -= 1
            j -= 1
        elif s1[i - 1] > s2[j - 1]:
            i -= 1
        else:
            j -= 1
    
    print("The Longest Common Subsequence is", str_)

def main():
    s1 = "abcde"
    s2 = "bdgek"
    
    lcs(s1, s2)

if __name__ == "__main__":
    main()

# method 2 : tabulation
# TC     -      
# SC     -     


# method 3 : space optimization
# TC     -      
# SC     -      


# 3 TODO : longest common substring (DP-27)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/longest-common-substring-dp-27/


https://practice.geeksforgeeks.org/problems/longest-common-substring1452/1


https://www.youtube.com/watch?v=_wP9mWNPL5w&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=208

substring -> consecutive characters without character in between
'''


# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
# TC     -      
# SC     -     


# method 2 : tabulation
'''
Time Complexity: O(N*M)

Reason: There are two nested loops

Space Complexity: O(N*M)

Reason: We are using an external array of size â€˜N*M)â€™. Stack Space is eliminated.
'''
def lcs(s1, s2):
    n = len(s1)
    m = len(s2)
    
    # Create a DP table with dimensions (n+1) x (m+1) initialized to zeros
    dp = [[0] * (m + 1) for _ in range(n + 1)]

    # Initialize a variable 'ans' to keep track of the maximum LCS length
    ans = 0
    
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if s1[i - 1] == s2[j - 1]:
                # If the characters match, increment LCS length by 1
                val = 1 + dp[i - 1][j - 1]
                dp[i][j] = val
                ans = max(ans, val)
            else:
                # If the characters do not match, reset LCS length to zero
                dp[i][j] = 0
    
    # 'ans' contains the length of the Longest Common Substring
    return ans

def main():
    s1 = "abcjklp"
    s2 = "acjkp"

    print("The Length of Longest Common Substring is", lcs(s1, s2))

if __name__ == '__main__':
    main()




# method 3 : space optimization
'''
Time Complexity: O(N*M)

Reason: There are two nested loops.

Space Complexity: O(M)

Reason: We are using an external array of size â€˜M+1â€™ to store only two rows.
'''
def lcs(s1, s2):
    n = len(s1)
    m = len(s2)
    
    # Initialize two arrays 'prev' and 'cur' to store the LCS lengths
    prev = [0 for i in range(m + 1)]
    cur = [0 for i in range(m + 1)]

    # Initialize a variable 'ans' to keep track of the maximum LCS length
    ans = 0
    
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if s1[i-1] == s2[j-1]:
                # If the characters match, increment LCS length by 1
                val = 1 + prev[j-1]
                cur[j] = val
                ans = max(ans, val)
            else:
                # If the characters do not match, reset LCS length to zero
                cur[j] = 0
        prev = cur[:]  # Update 'prev' with the values of 'cur'
    
    # 'ans' contains the length of the Longest Common Substring
    return ans

def main():
    s1 = "abcjklp"
    s2 = "acjkp"

    print("The Length of Longest Common Substring is", lcs(s1, s2))

if __name__ == '__main__':
    main()




# 4 TODO : longest pallindromic subsequence (DP-28)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/longest-palindromic-subsequence-dp-28/


https://leetcode.com/problems/longest-palindromic-subsequence/


https://www.youtube.com/watch?v=6i_T5kkfv4A&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=209
'''


# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
# TC     -      
# SC     -     


# method 2 : tabulation
'''
Time Complexity: O(N*N)

Reason: There are two nested loops

Space Complexity: O(N*N)

Reason: We are using an external array of size â€˜(N*N)â€™. Stack Space is eliminated.
'''
def lcs(s1, s2):
    n = len(s1)
    m = len(s2)

    # Initialize a 2D array to store the length of the LCS
    dp = [[-1] * (m + 1) for i in range(n + 1)]

    # Initialize the first row and first column with 0
    for i in range(n + 1):
        dp[i][0] = 0
    for i in range(m + 1):
        dp[0][i] = 0

    # Fill in the dp array using dynamic programming
    for ind1 in range(1, n + 1):
        for ind2 in range(1, m + 1):
            if s1[ind1 - 1] == s2[ind2 - 1]:
                dp[ind1][ind2] = 1 + dp[ind1 - 1][ind2 - 1]
            else:
                dp[ind1][ind2] = max(dp[ind1 - 1][ind2], dp[ind1][ind2 - 1])

    # The final value in dp will be the length of the LCS
    return dp[n][m]

def longestPalindromeSubsequence(s):
    # Reverse the input string
    t = s
    s = s[::-1]

    # Find the longest common subsequence between s and its reverse
    return lcs(s, t)

def main():
    s = "bbabcbcab"

    # Calculate and print the length of the longest palindromic subsequence
    print("The Length of Longest Palindromic Subsequence is", longestPalindromeSubsequence(s))

if __name__ == "__main__":
    main()



# method 3 : space optimization
'''
Time Complexity: O(N*N)

Reason: There are two nested loops.

Space Complexity: O(N)

Reason: We are using an external array of size â€˜N+1â€™ to store only two rows.
'''
def lcs(s1, s2):
    n = len(s1)
    m = len(s2)

    # Initialize two lists, prev and cur, for dynamic programming
    prev = [0] * (m + 1)
    cur = [0] * (m + 1)

    # Base Case is covered as we have initialized the prev and cur to 0.
    for ind1 in range(1, n + 1):
        for ind2 in range(1, m + 1):
            if s1[ind1 - 1] == s2[ind2 - 1]:
                cur[ind2] = 1 + prev[ind2 - 1]
            else:
                cur[ind2] = max(prev[ind2], cur[ind2 - 1])
        prev = cur[:]  # Update prev to be a copy of cur for the next iteration

    # The final value in prev will be the length of the LCS
    return prev[m]


def longestPalindromeSubsequence(s):
    # Reverse the input string
    t = s[::-1]

    # Find the length of the longest common subsequence between s and its reverse
    return lcs(s, t)


def main():
    s = "bbabcbcab"

    # Calculate and print the length of the longest palindromic subsequence
    print("The Length of Longest Palindromic Subsequence is", longestPalindromeSubsequence(s))


if __name__ == "__main__":
    main()




# 5 TODO : minimum insertions to make string pallindromic (DP-29)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/minimum-insertions-to-make-string-palindrome-dp-29/


https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/

https://www.youtube.com/watch?v=yMnH0jrir0Q&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=210
'''


# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
# TC     -      
# SC     -     


# method 2 : tabulation
'''
Time Complexity: O(N*N)

Reason: There are two nested loops

Space Complexity: O(N*N)

Reason: We are using an external array of size (N*N). Stack Space is eliminated.
'''
def lcs(s1, s2):
    n = len(s1)
    m = len(s2)

    # Initialize a 2D array to store the length of the Longest Common Subsequence (LCS)
    dp = [[-1 for i in range(m + 1)] for j in range(n + 1)]

    # Base cases: When one of the strings is empty, LCS length is 0.
    for i in range(n + 1):
        dp[i][0] = 0
    for i in range(m + 1):
        dp[0][i] = 0

    # Fill in the dp array using dynamic programming
    for ind1 in range(1, n + 1):
        for ind2 in range(1, m + 1):
            if s1[ind1 - 1] == s2[ind2 - 1]:
                dp[ind1][ind2] = 1 + dp[ind1 - 1][ind2 - 1]
            else:
                dp[ind1][ind2] = max(dp[ind1 - 1][ind2], dp[ind1][ind2 - 1])

    # The final value in dp will be the length of the LCS
    return dp[n][m]

def longestPalindromeSubsequence(s):
    # Reverse the input string
    t = s
    s = s[::-1]

    # Find the length of the longest common subsequence between s and its reverse
    return lcs(s, t)

def minInsertion(s):
    n = len(s)

    # Calculate the length of the longest palindromic subsequence
    k = longestPalindromeSubsequence(s)

    # The minimum insertions required to make the string palindrome is the difference between its length and the length of its longest palindromic subsequence
    return n - k

def main():
    s = "abcaa"
    print("The Minimum insertions required to make the string palindrome:", minInsertion(s))

if __name__ == '__main__':
    main()




# method 3 : space optimization
'''
Time Complexity: O(N*M)

Reason: There are two nested loops.

Space Complexity: O(M)

Reason: We are using an external array of size â€˜M+1â€™ to store only two rows.
'''
def lcs(s1, s2):
    n = len(s1)
    m = len(s2)

    # Initialize two lists, prev and cur, for dynamic programming
    prev = [0] * (m + 1)
    cur = [0] * (m + 1)

    # Base Case is covered as we have initialized the prev and cur to 0.

    for ind1 in range(1, n + 1):
        for ind2 in range(1, m + 1):
            if s1[ind1 - 1] == s2[ind2 - 1]:
                cur[ind2] = 1 + prev[ind2 - 1]
            else:
                cur[ind2] = max(prev[ind2], cur[ind2 - 1])

        prev = cur[:]  # Update prev to be a copy of cur for the next iteration

    # The final value in prev will be the length of the LCS
    return prev[m]

def longestPalindromeSubsequence(s):
    # Reverse the input string
    t = s
    s = s[::-1]

    # Find the length of the longest common subsequence between s and its reverse
    return lcs(s, t)

def minInsertion(s):
    n = len(s)

    # Calculate the length of the longest palindromic subsequence
    k = longestPalindromeSubsequence(s)

    # The minimum insertions required to make the string palindrome is the difference between its length and the length of its longest palindromic subsequence
    return n - k

def main():
    s = "abcaa"
    print("The Minimum insertions required to make the string palindrome:", minInsertion(s))

if __name__ == '__main__':
    main()


# 6 TODO : minimum insertions/deletions to convert string (DP-30)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/data-structure/minimum-insertions-deletions-to-convert-string-dp-30/


https://leetcode.com/problems/delete-operation-for-two-strings/

https://www.youtube.com/watch?v=yMnH0jrir0Q&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=211
'''


# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
# TC     -      
# SC     -     


# method 2 : tabulation
'''
Time Complexity: O(N*M)

Reason: There are two nested loops

Space Complexity: O(N*M)

Reason: We are using an external array of size (N*M). Stack Space is eliminated.
'''
def lcs(s1, s2):
    n = len(s1)
    m = len(s2)

    # Initialize a 2D array to store the length of the LCS
    dp = [[-1 for i in range(m + 1)] for j in range(n + 1)]

    # Base cases: When one of the strings is empty, LCS length is 0.
    for i in range(n + 1):
        dp[i][0] = 0
    for i in range(m + 1):
        dp[0][i] = 0

    # Fill in the dp array using dynamic programming
    for ind1 in range(1, n + 1):
        for ind2 in range(1, m + 1):
            if s1[ind1 - 1] == s2[ind2 - 1]:
                dp[ind1][ind2] = 1 + dp[ind1 - 1][ind2 - 1]
            else:
                dp[ind1][ind2] = max(dp[ind1 - 1][ind2], dp[ind1][ind2 - 1])

    # The final value in dp will be the length of the LCS
    return dp[n][m]

# Function to calculate the minimum operations required to convert str1 to str2
def canYouMake(str1, str2):
    n = len(str1)
    m = len(str2)

    # Calculate the length of the LCS between str1 and str2
    k = lcs(str1, str2)

    # The minimum operations required is the sum of the deletions needed in both strings
    return (n - k) + (m - k)

def main():
    str1 = "abcd"
    str2 = "anc"

    # Calculate and print the minimum operations required to convert str1 to str2
    print("The Minimum operations required to convert str1 to str2:", canYouMake(str1, str2))

if __name__ == '__main__':
    main()




# method 3 : space optimization
'''
Time Complexity: O(N*M)

Reason: There are two nested loops.

Space Complexity: O(M)

Reason: We are using an external array of size â€˜M+1â€™ to store only two rows.
'''
def lcs(s1, s2):
    n = len(s1)
    m = len(s2)

    # Initialize two lists, prev and cur, for dynamic programming
    prev = [0] * (m + 1)
    cur = [0] * (m + 1)

    # Base Case is covered as we have initialized the prev and cur to 0.
    for ind1 in range(1, n + 1):
        for ind2 in range(1, m + 1):
            if s1[ind1 - 1] == s2[ind2 - 1]:
                cur[ind2] = 1 + prev[ind2 - 1]
            else:
                cur[ind2] = max(prev[ind2], cur[ind2 - 1])

        prev = cur[:]  # Update prev to be a copy of cur for the next iteration

    # The final value in prev will be the length of the LCS
    return prev[m]

# Function to calculate the minimum operations required to convert str1 to str2
def canYouMake(str1, str2):
    n = len(str1)
    m = len(str2)

    # Calculate the length of the LCS between str1 and str2
    k = lcs(str1, str2)

    # The minimum operations required is the sum of the deletions needed in both strings
    return (n - k) + (m - k)

def main():
    str1 = "abcd"
    str2 = "anc"

    # Calculate and print the minimum operations required to convert str1 to str2
    print("The Minimum operations required to convert str1 to str2:", canYouMake(str1, str2))

if __name__ == '__main__':
    main()




# 7 TODO : shortest common supersequence (DP-31)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/data-structure/shortest-common-supersequence-dp-31/


https://leetcode.com/problems/shortest-common-supersequence/

https://www.youtube.com/watch?v=xElxAuBcvsU&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=212
'''
# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
'''
Time Complexity: O(N*M)

Reason: There are two nested loops

Space Complexity: O(N*M)

Reason: We are using an external array of size (N*M).
'''
def shortestSupersequence(s1, s2):
    n = len(s1)
    m = len(s2)

    dp = [[0 for i in range(m + 1)] for j in range(n + 1)]
    for i in range(n + 1):
        dp[i][0] = 0
    for i in range(m + 1):
        dp[0][i] = 0

    for ind1 in range(1, n + 1):
        for ind2 in range(1, m + 1):
            if s1[ind1 - 1] == s2[ind2 - 1]:
                dp[ind1][ind2] = 1 + dp[ind1 - 1][ind2 - 1]
            else:
                dp[ind1][ind2] = 0+ max(dp[ind1 - 1][ind2], dp[ind1][ind2 - 1])

    len_ = dp[n][m]
    i = n
    j = m

    index = len_ - 1
    ans = ""

    while i > 0 and j > 0:
        if s1[i - 1] == s2[j - 1]:
            ans += s1[i - 1]
            index -= 1
            i -= 1
            j -= 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            ans += s1[i - 1]
            i -= 1
        else:
            ans += s2[j - 1]
            j -= 1
    #Adding Remaing Characters - Only one of the below two while loops will run 
    while i > 0:
        ans += s1[i - 1]
        i -= 1
    while j > 0:
        ans += s2[j - 1]
        j -= 1

    ans=ans[::-1]
    return ans

def main():
    s1 = "brute"
    s2 = "groot"
    print("The Longest Common Supersequence is " + shortestSupersequence(s1, s2))

if __name__ == "__main__":
    main()  


# method 2 : tabulation
# TC     -      
# SC     -     


# method 3 : space optimization
# TC     -      
# SC     -      


# 8 TODO : distinct subsequences (DP-32)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/distinct-subsequences-dp-32/


https://leetcode.com/problems/distinct-subsequences/

https://www.youtube.com/watch?v=nVG7eTiD2bY&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=213
'''
# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
'''
Time Complexity: O(N*M)

Reason: There are N*M states therefore at max â€˜N*Mâ€™ new problems will be solved.

Space Complexity: O(N*M) + O(N+M)

Reason: We are using a recursion stack space(O(N+M)) and a 2D array ( O(N*M)).

prime = int(1e9 + 7)
'''
# Recursive function to count distinct subsequences of s1 that match s2
def countUtil(s1, s2, ind1, ind2, dp):
    # If we have exhausted s2, we found a valid subsequence
    if ind2 < 0:
        return 1
    # If we have exhausted s1, but not s2, no valid subsequence found
    if ind1 < 0:
        return 0
    
    # If this subproblem has already been solved, return the cached result
    if dp[ind1][ind2] != -1:
        return dp[ind1][ind2]
    
    # If the current characters match, we can either choose to leave one character
    # or stay with the current character in s1
    if s1[ind1] == s2[ind2]:
        leaveOne = countUtil(s1, s2, ind1 - 1, ind2 - 1, dp)
        stay = countUtil(s1, s2, ind1 - 1, ind2, dp)
        
        # Store the result in the DP table and return it modulo prime
        dp[ind1][ind2] = (leaveOne + stay) % prime
        return dp[ind1][ind2]
    else:
        # If the characters don't match, we can only skip the character in s1
        dp[ind1][ind2] = countUtil(s1, s2, ind1 - 1, ind2, dp)
        return dp[ind1][ind2]
    
# Main function to count distinct subsequences of s1 that match s2
def subsequenceCounting(s1, s2, lt, ls):
    # Initialize a DP table to store intermediate results
    dp = [[-1 for j in range(ls)] for i in range(lt)]
    
    # Call the recursive function to count distinct subsequences
    return countUtil(s1, s2, lt - 1, ls - 1, dp)

def main():
    s1 = "babgbag"
    s2 = "bag"

    # Calculate and print the count of distinct subsequences
    print("The Count of Distinct Subsequences is", subsequenceCounting(s1, s2, len(s1), len(s2)))

if __name__ == "__main__":
    main()




# method 2 : tabulation
'''
Time Complexity: O(N*M)

Reason: There are two nested loops

Space Complexity: O(N*M)

Reason: We are using an external array of size â€˜N*Mâ€™. Stack Space is eliminated.

prime = int(1e9 + 7)
'''
# Function to count distinct subsequences of s1 that match s2
def subsequenceCounting(s1, s2, n, m):
    # Initialize a DP table to store the count of distinct subsequences
    dp = [[0 for i in range(m + 1)] for j in range(n + 1)]

    # Base case: There is exactly one subsequence of an empty string s2 in s1
    for i in range(n + 1):
        dp[i][0] = 1

    # Initialize dp[0][i] to 0 for i > 0 since an empty s1 cannot have a non-empty subsequence of s2
    for i in range(1, m + 1):
        dp[0][i] = 0

    # Fill in the DP table using dynamic programming
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            # If the current characters match, we have two choices:
            # 1. Include the current character in both s1 and s2 (dp[i-1][j-1])
            # 2. Skip the current character in s1 (dp[i-1][j])
            dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % prime if s1[i - 1] == s2[j - 1] else dp[i - 1][j]

    # The final value in dp[n][m] is the count of distinct subsequences
    return dp[n][m]

def main():
    s1 = "babgbag"
    s2 = "bag"
    
    # Calculate and print the count of distinct subsequences
    print("The Count of Distinct Subsequences is", subsequenceCounting(s1, s2, len(s1), len(s2)))

if __name__ == "__main__":
    main()



# method 3 : space optimization
'''
Time Complexity: O(N*M)

Reason: There are two nested loops.

Space Complexity: O(M)

Reason: We are using an external array of size â€˜M+1â€™ to store only one row.

prime = int(1e9 + 7)
'''
# Function to count distinct subsequences of s1 that match s2
def subsequenceCounting(s1, s2, n, m):
    # Initialize a list to store the previous row of the DP table
    prev = [0 for i in range(m + 1)]
    
    # Initialize the first element of prev to 1, as there's always one way to match an empty s2
    prev[0] = 1

    # Loop through s1 and s2 in reverse direction
    for i in range(1, n + 1):
        for j in range(m, 0, -1):
            # If the current characters match, update prev[j] based on previous values
            if s1[i - 1] == s2[j - 1]:
                prev[j] = (prev[j - 1] + prev[j]) % prime
            # If the characters don't match, keep prev[j] unchanged (omit this statement)
            else:
                prev[j] = prev[j]

    # The final value in prev[m] is the count of distinct subsequences
    return prev[m]

def main():
    s1 = "babgbag"
    s2 = "bag"
    
    # Calculate and print the count of distinct subsequences
    result = subsequenceCounting(s1, s2, len(s1), len(s2))
    print("The Count of Distinct Subsequences is", result)

if __name__ == '__main__':
    main()




# 9 TODO : edit distance (DP-33)

'''


ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/edit-distance-dp-33/


https://leetcode.com/problems/edit-distance/


https://www.youtube.com/watch?v=fJaKO8FbDdo&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=214
'''
# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
'''
Time Complexity: O(N*M)

Reason: There are N*M states therefore at max â€˜N*Mâ€™ new problems will be solved.

Space Complexity: O(N*M) + O(N+M)

Reason: We are using a recursion stack space(O(N+M)) and a 2D array ( O(N*M)).
'''
def editDistanceUtil(S1, S2, i, j, dp):
    # Base cases
    if i < 0:
        return j + 1
    if j < 0:
        return i + 1

    # If the result for this subproblem is already computed, return it
    if dp[i][j] != -1:
        return dp[i][j]

    # If the characters at the current positions match, no operation is needed
    if S1[i] == S2[j]:
        dp[i][j] = editDistanceUtil(S1, S2, i - 1, j - 1, dp)
    else:
        # Calculate the minimum of three choices:
        # 1. Replace the current character (diagonal move)
        # 2. Insert a character into S1 (move up)
        # 3. Delete a character from S1 (move left)
        dp[i][j] = 1 + min(
            editDistanceUtil(S1, S2, i - 1, j - 1, dp),
            min(editDistanceUtil(S1, S2, i - 1, j, dp), editDistanceUtil(S1, S2, i, j - 1, dp))
        )

    return dp[i][j]

def editDistance(S1, S2):
    n = len(S1)
    m = len(S2)

    # Initialize a 2D DP array with -1 values
    dp = [[-1 for _ in range(m)] for _ in range(n)]

    # Calculate and return the edit distance
    return editDistanceUtil(S1, S2, n - 1, m - 1, dp)

def main():
    s1 = "horse"
    s2 = "ros"

    # Calculate and print the minimum number of operations required
    print("The minimum number of operations required is:", editDistance(s1, s2))

if __name__ == "__main__":
    main()




# method 2 : tabulation
'''
Time Complexity: O(N*M)

Reason: There are two nested loops

Space Complexity: O(N*M)

Reason: We are using an external array of size â€˜N*Mâ€™. Stack Space is eliminated.
'''
def editDistance(S1, S2):
    n = len(S1)
    m = len(S2)

    # Initialize a 2D DP array of size (n+1) x (m+1) with all elements set to 0
    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]

    # Initialize the first row and first column of the DP array
    for i in range(n + 1):
        dp[i][0] = i
    for j in range(m + 1):
        dp[0][j] = j

    # Fill in the DP array using dynamic programming
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            # If the characters at the current positions match, no operation is needed
            if S1[i - 1] == S2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                # Calculate the minimum of three choices:
                # 1. Replace the current character (diagonal move)
                # 2. Insert a character into S1 (move up)
                # 3. Delete a character from S1 (move left)
                dp[i][j] = 1 + min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]))

    # The final value in dp[n][m] is the minimum number of operations required
    return dp[n][m]

def main():
    s1 = "horse"
    s2 = "ros"

    # Calculate and print the minimum number of operations required
    print("The minimum number of operations required is:", editDistance(s1, s2))

if __name__ == "__main__":
    main()




# method 3 : space optimization
'''
Time Complexity: O(N*M)

Reason: There are two nested loops.

Space Complexity: O(M)

Reason: We are using an external array of size â€˜M+1â€™ to store two rows.
'''
def editDistance(S1, S2):
    n = len(S1)
    m = len(S2)

    # Initialize two lists, prev and cur, to store the previous and current rows of the DP array
    prev = [j for j in range(m + 1)]
    cur = [0 for _ in range(m + 1)]

    # Loop through the characters of S1 and S2
    for i in range(1, n + 1):
        cur[0] = i  # Initialize the first element of the current row

        for j in range(1, m + 1):
            # If the characters at the current positions match, no operation is needed
            if S1[i - 1] == S2[j - 1]:
                cur[j] = prev[j - 1]
            else:
                # Calculate the minimum of three choices:
                # 1. Replace the current character (diagonal move)
                # 2. Insert a character into S1 (move up)
                # 3. Delete a character from S1 (move left)
                cur[j] = 1 + min(prev[j - 1], min(prev[j], cur[j - 1]))

        prev, cur = cur, prev  # Update prev to be the current row, and cur to be the new empty row

    # The final value in prev[m] is the minimum number of operations required
    return prev[m]

def main():
    s1 = "horse"
    s2 = "ros"

    # Calculate and print the minimum number of operations required
    print("The minimum number of operations required is:", editDistance(s1, s2))

if __name__ == "__main__":
    main()




# 10 TODO :  wildcard matching (DP-34)
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://takeuforward.org/data-structure/wildcard-matching-dp-34/


https://leetcode.com/problems/wildcard-matching/


https://www.youtube.com/watch?v=ZmlQ3vgAOMo&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=215
'''
# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
'''
Time Complexity: O(N*M)

Reason: There are N*M states therefore at max â€˜N*Mâ€™ new problems will be solved.

Space Complexity: O(N*M) + O(N+M)

Reason: We are using a recursion stack space(O(N+M)) and a 2D array ( O(N*M)).
'''
def isAllStars(S1, i):
    # Helper function to check if all characters up to index i in S1 are '*'
    for j in range(i + 1):
        if S1[j] != '*':
            return False
    return True

def wildcardMatchingUtil(S1, S2, i, j, dp):
    # Base conditions
    if i < 0 and j < 0:
        return True
    if i < 0 and j >= 0:
        return False
    if j < 0 and i >= 0:
        return isAllStars(S1, i)

    # If the result for this subproblem is already computed, return it
    if dp[i][j] != -1:
        return dp[i][j]

    if S1[i] == S2[j] or S1[i] == '?':
        # Characters match or S1 has a '?'; move to the previous characters in both strings
        dp[i][j] = wildcardMatchingUtil(S1, S2, i - 1, j - 1, dp)
    elif S1[i] == '*':
        # If S1 has a '*', there are two choices:
        # 1. '*' represents an empty string in S1, so move to the previous character in S1 (i-1, j).
        # 2. '*' represents one or more characters in S1, so move to the previous character in S2 (i, j-1).
        dp[i][j] = wildcardMatchingUtil(S1, S2, i - 1, j, dp) or wildcardMatchingUtil(S1, S2, i, j - 1, dp)
    else:
        dp[i][j] = False  # Characters don't match, and S1[i] is not '*'

    return dp[i][j]

def wildcardMatching(S1, S2):
    n = len(S1)
    m = len(S2)

    # Initialize a 2D DP array with -1 values
    dp = [[-1 for _ in range(m)] for _ in range(n)]

    # Calculate and return the result of wildcard matching
    return wildcardMatchingUtil(S1, S2, n - 1, m - 1, dp)

def main():
    S1 = "ab*cd"
    S2 = "abdefcd"

    if wildcardMatching(S1, S2):
        print("String S1 and S2 do match")
    else:
        print("String S1 and S2 do not match")

if __name__ == "__main__":
    main()



# method 2 : tabulation
'''
Time Complexity: O(N*M)

Reason: There are two nested loops

Space Complexity: O(N*M)

Reason: We are using an external array of size â€˜N*Mâ€™. Stack Space is eliminated.
'''
def isAllStars(S1, i):
    # Helper function to check if all characters up to index i in S1 are '*'
    for j in range(1, i + 1):
        if S1[j - 1] != '*':
            return False
    return True

def wildcardMatching(S1, S2):
    n = len(S1)
    m = len(S2)

    # Initialize a 2D DP array dp with dimensions (n+1) x m and fill it with False values
    dp = [[False for _ in range(m)] for _ in range(n + 1)]

    # Initialize dp[0][0] to True since two empty strings match
    dp[0][0] = True

    # Initialize the first row of dp
    for j in range(1, m):
        dp[0][j] = False

    # Initialize the first column of dp based on whether S1 consists of all '*' characters up to that position
    for i in range(1, n + 1):
        dp[i][0] = isAllStars(S1, i)

    # Fill in the DP array using dynamic programming
    for i in range(1, n + 1):
        for j in range(1, m):
            if S1[i - 1] == S2[j - 1] or S1[i - 1] == '?':
                # Characters match or S1 has a '?'; continue matching with the previous characters
                dp[i][j] = dp[i - 1][j - 1]
            elif S1[i - 1] == '*':
                # If S1 has a '*', there are two choices:
                # 1. '*' represents an empty string in S1, so move to the previous character in S1 (i-1, j).
                # 2. '*' represents one or more characters in S1, so move to the previous character in S2 (i, j-1).
                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]
            else:
                dp[i][j] = False  # Characters don't match, and S1[i-1] is not '*'

    # The final value in dp[n][m-1] is True if the two strings match, False otherwise
    return dp[n][m-1]

def main():
    S1 = "ab*cd"
    S2 = "abdefcd"

    if wildcardMatching(S1, S2):
        print("String S1 and S2 do match")
    else:
        print("String S1 and S2 do not match")

if __name__ == "__main__":
    main()




# method 3 : space optimization
'''
Time Complexity: O(N*M)

Reason: There are two nested loops.

Space Complexity: O(M)

Reason: We are using an external array of size â€˜M+1â€™ to store two rows.
'''
def isAllStars(S1, i):
    # Helper function to check if all characters up to index i in S1 are '*'
    for j in range(1, i + 1):
        if S1[j - 1] != '*':
            return False
    return True

def wildcardMatching(S1, S2):
    n = len(S1)
    m = len(S2)

    # Initialize two lists, prev and cur, to store the previous and current rows of the DP array
    prev = [False for _ in range(m + 1)]
    cur = [False for _ in range(m + 1)]

    prev[0] = True  # Initialize the first element of prev to True

    for i in range(1, n + 1):
        cur[0] = isAllStars(S1, i)  # Initialize the first element of cur based on '*' characters in S1
        for j in range(1, m + 1):

            if S1[i - 1] == S2[j - 1] or S1[i - 1] == '?':
                # Characters match or S1 has a '?'; continue matching with the previous characters
                cur[j] = prev[j - 1]
            elif S1[i - 1] == '*':
                # If S1 has a '*', there are two choices:
                # 1. '*' represents an empty string in S1, so move to the previous character in S1 (i-1, j).
                # 2. '*' represents one or more characters in S1, so move to the previous character in S2 (i, j-1).
                cur[j] = prev[j] or cur[j - 1]
            else:
                cur[j] = False  # Characters don't match, and S1[i-1] is not '*'

        prev = cur  # Update prev to be the current row

    # The final value in prev[m] is True if the two strings match, False otherwise
    return prev[m]

def main():
    S1 = "ab*cd"
    S2 = "abdefcd"

    if wildcardMatching(S1, S2):
        print("String S1 and S2 do match")
    else:
        print("String S1 and S2 do not match")

if __name__ == "__main__":
    main()





# endregion





# region 16.6 DP - STOCKS
# -----------------------

# 1 TODO : best time to bus stocks - I (DP -35)  
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/stock-buy-and-sell-dp-35/


https://leetcode.com/problems/best-time-to-buy-and-sell-stock/

https://www.youtube.com/watch?v=excAOvwF_Wk


'''

# method 0 : recursion
''' 
Time Complexity : O(N)
Space Complexity : O(1)
'''
def main_function(arr):
  mini = arr[0]
  profit = 0
  for i in range(1, len(arr)):
    cost = arr[i] - mini
    profit = max(profit, cost)
    mini = min(mini, arr[i])
    return profit

arr = [7,1,5,3,6,4]
print(main_function(arr))



# method 1 : memoization
# TC     -   
# SC     -   




# method 2 : tabulation
# TC     -     
# SC     -     




# method 3 : space optimization
# TC     -      
# SC     -      



# 2 TODO : buy and sell stock - II (DP - 36)
'''
ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/data-structure/buy-and-sell-stock-ii-dp-36/

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/

https://www.youtube.com/watch?v=nGJmxkUJQGs&list=PLgUwDviBIf0oF6QL8m22w1hIDC1vJ_BHz&index=216

'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''
def getMaximumProfit(Arr, n):
    # Function to calculate the maximum profit from buying and selling stocks
    
    if n == 0:
        return 0  # If there are no stocks, the profit is zero

    def getAns(ind, buy):
        # Recursive function to calculate the maximum profit
        
        if ind == n:
            return 0  # Base case: If we have reached the end of the array, return zero profit

        profit = 0
        
        if buy == 0:
            # We can buy the stock
            profit = max(0 + getAns(ind + 1, 0), -Arr[ind] + getAns(ind + 1, 1))
        elif buy == 1:
            # We can sell the stock
            profit = max(0 + getAns(ind + 1, 1), Arr[ind] + getAns(ind + 1, 0))
        
        return profit

    ans = getAns(0, 0)  # Start with buying (0) at the first day (0)
    return ans

def main():
    n = 6
    Arr = [7, 1, 5, 3, 6, 4]

    max_profit = getMaximumProfit(Arr, n)
    print("The maximum profit that can be generated is", max_profit)

if __name__ == "__main__":
    main()

# method 1 : memoization
'''
Time Complexity: O(N*2) 

Reason: There are N*2 states therefore at max â€˜N*2â€™ new problems will be solved and we are running a for loop for â€˜Nâ€™ times to calculate the total sum

Space Complexity: O(N*2) + O(N)

Reason: We are using a recursion stack space(O(N)) and a 2D array ( O(N*2)).
'''

def getMaximumProfit(Arr, n):
    # Function to calculate the maximum profit from buying and selling stocks
    
    if n == 0:
        return 0  # If there are no stocks, the profit is zero

    dp = [[-1 for _ in range(2)] for _ in range(n)]  # Initialize a DP table with -1 values

    def getAns(ind, buy):
        # Recursive function to calculate the maximum profit
        
        if ind == n:
            return 0  # Base case: If we have reached the end of the array, return zero profit
        
        if dp[ind][buy] != -1:
            return dp[ind][buy]  # If the result is already computed, return it
        
        profit = 0
        
        if buy == 0:
            # We can buy the stock
            profit = max(0 + getAns(ind + 1, 0), -Arr[ind] + getAns(ind + 1, 1))
        elif buy == 1:
            # We can sell the stock
            profit = max(0 + getAns(ind + 1, 1), Arr[ind] + getAns(ind + 1, 0))
        
        dp[ind][buy] = profit  # Store the result in the DP table
        return profit

    ans = getAns(0, 0)  # Start with buying (0) at the first day (0)
    return ans

def main():
    n = 6
    Arr = [7, 1, 5, 3, 6, 4]

    max_profit = getMaximumProfit(Arr, n)
    print("The maximum profit that can be generated is", max_profit)

if __name__ == "__main__":
    main()





# method 2 : tabulation
Time Complexity: O(N*2) 

Reason: There are two nested loops that account for O(N*2) complexity.

Space Complexity: O(N*2)

Reason: We are using an external array of size â€˜N*2â€™. Stack Space is eliminated.


def getMaximumProfit(Arr, n):
    # Function to calculate the maximum profit from buying and selling stocks
    
    # Create a 2D DP table with dimensions (n+1) x 2 and initialize it with -1 values
    dp = [[-1 for _ in range(2)] for _ in range(n + 1)]
    
    # Base condition: Initialize the last row of DP table to 0 since there are no more days to trade
    dp[n][0] = dp[n][1] = 0
    
    for ind in range(n - 1, -1, -1):
        for buy in range(2):
            profit = 0
            
            if buy == 0:
                # We can buy the stock
                profit = max(0 + dp[ind + 1][0], -Arr[ind] + dp[ind + 1][1])
            elif buy == 1:
                # We can sell the stock
                profit = max(0 + dp[ind + 1][1], Arr[ind] + dp[ind + 1][0])
            
            dp[ind][buy] = profit  # Store the result in the DP table
    
    return dp[0][0]

def main():
    n = 6
    Arr = [7, 1, 5, 3, 6, 4]

    max_profit = getMaximumProfit(Arr, n)
    print("The maximum profit that can be generated is", max_profit)

if __name__ == "__main__":
    main()





# method 3 : space optimization
Time Complexity: O(N*2)

Reason: There are two nested loops that account for O(N*2) complexity

Space Complexity: O(1)

Reason: We are using an external array of size â€˜2â€™.


def getMaximumProfit(Arr, n):
    # Function to calculate the maximum profit from buying and selling stocks
    
    ahead = [0, 0]  # Initialize two lists, 'ahead' and 'cur', to keep track of profits for buying and selling
    cur = [0, 0]
    
    # Base condition: Initialize both 'ahead' and 'cur' to 0, as there are no more days to trade
    ahead[0] = ahead[1] = 0
    
    for ind in range(n - 1, -1, -1):
        for buy in range(2):
            profit = 0
            
            if buy == 0:
                # We can buy the stock
                profit = max(0 + ahead[0], -Arr[ind] + ahead[1])
            elif buy == 1:
                # We can sell the stock
                profit = max(0 + ahead[1], Arr[ind] + ahead[0])
            cur[buy] = profit  # Store the result in the 'cur' list
        
        ahead = cur  # Update 'ahead' to be the same as 'cur'
    
    return cur[0]

def main():
    n = 6
    Arr = [7, 1, 5, 3, 6, 4]

    max_profit = getMaximumProfit(Arr, n)
    print("The maximum profit that can be generated is", max_profit)

if __name__ == "__main__":
    main()






# 3 TODO : buy and sell stock - III (DP-37)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/data-structure/buy-and-sell-stock-iii-dp-37/


https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/

'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
Time Complexity: O(N*2*3) 

Reason: There are N*2*3 states therefore at max â€˜N*2*3â€™ new problems will be solved.

Space Complexity: O(N*2*3) + O(N)

Reason: We are using a recursion stack space(O(N)) and a 3D array ( O(N*2*3)).


def maxProfit(prices):
    n = len(prices)
    
    # Create a 3D DP table with dimensions (n) x 2 x 3 and initialize it with -1 values
    dp = [[[-1 for _ in range(3)] for _ in range(2)] for _ in range(n)]
    
    def getAns(ind, buy, cap):
        # Recursive function to calculate the maximum profit
        
        if ind == n or cap == 0:
            return 0  # Base case: If we have reached the end of the array or used up all transactions, return zero profit
        
        if dp[ind][buy][cap] != -1:
            return dp[ind][buy][cap]  # If the result is already computed, return it
        
        profit = 0
        
        if buy == 0:
            # We can buy the stock
            profit = max(0 + getAns(ind + 1, 0, cap), -prices[ind] + getAns(ind + 1, 1, cap))
        elif buy == 1:
            # We can sell the stock
            profit = max(0 + getAns(ind + 1, 1, cap), prices[ind] + getAns(ind + 1, 0, cap - 1))
        
        dp[ind][buy][cap] = profit  # Store the result in the DP table
        return profit

    return getAns(0, 0, 2)  # Start with buying (0) and 2 transactions available (cap=2)

def main():
    prices = [3, 3, 5, 0, 0, 3, 1, 4]

    max_profit = maxProfit(prices)
    print("The maximum profit that can be generated is", max_profit)

if __name__ == "__main__":
    main()




# method 2 : tabulation
Time Complexity: O(N*2*3) 

Reason: There are three nested loops that account for O(N*2*3) complexity.

Space Complexity: O(N*2*3)

Reason: We are using an external array of size â€˜N*2*3â€™. Stack Space is eliminated.


def maxProfit(prices):
    n = len(prices)
    
    # Create a 3D DP table with dimensions (n+1) x 2 x 3 and initialize it to 0 values
    dp = [[[0 for _ in range(3)] for _ in range(2)] for _ in range(n + 1)]
    
    # The base case is already covered as the DP array is initialized to 0
    
    for ind in range(n - 1, -1, -1):
        for buy in range(2):
            for cap in range(1, 3):
                
                if buy == 0:
                    # We can buy the stock
                    dp[ind][buy][cap] = max(0 + dp[ind + 1][0][cap], -prices[ind] + dp[ind + 1][1][cap])
                elif buy == 1:
                    # We can sell the stock
                    dp[ind][buy][cap] = max(0 + dp[ind + 1][1][cap], prices[ind] + dp[ind + 1][0][cap - 1])
    
    return dp[0][0][2]

def main():
    prices = [3, 3, 5, 0, 0, 3, 1, 4]

    max_profit = maxProfit(prices)
    print("The maximum profit that can be generated is", max_profit)

if __name__ == "__main__":
    main()





# method 3 : space optimization
Time Complexity: O(N*2*3)

Reason: There are three nested loops that account for O(N*2*3) complexity

Space Complexity: O(1)

Reason: We are using two external arrays of size â€˜2*3â€™.


def maxProfit(prices):
    n = len(prices)
    
    # Create two 2D arrays, ahead and cur, both of size 2x3, initialized to 0 values
    ahead = [[0 for _ in range(3)] for _ in range(2)]
    cur = [[0 for _ in range(3)] for _ in range(2)]
    
    for ind in range(n - 1, -1, -1):
        for buy in range(2):
            for cap in range(1, 3):
                
                if buy == 0:
                    # We can buy the stock
                    cur[buy][cap] = max(0 + ahead[0][cap], -prices[ind] + ahead[1][cap])
                elif buy == 1:
                    # We can sell the stock
                    cur[buy][cap] = max(0 + ahead[1][cap], prices[ind] + ahead[0][cap - 1])
        
        ahead = cur  # Update ahead with the current values
    
    return ahead[0][2]

def main():
    prices = [3, 3, 5, 0, 0, 3, 1, 4]

    max_profit = maxProfit(prices)
    print("The maximum profit that can be generated is", max_profit)

if __name__ == "__main__":
    main()





# 4 TODO : buy and sell stock - IV (DP-38)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/buy-and-sell-stock-iv-dp-38/


https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/

'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
Time Complexity: O(N*2*3) 

Reason: There are N*2*K states therefore at max â€˜N*2*Kâ€™ new problems will be solved.

Space Complexity: O(N*2*K) + O(N)

Reason: We are using a recursion stack space(O(N)) and a 3D array ( O(N*2*K)).


def get_max_profit(prices, n, ind, buy, cap, dp):
    # Base case: if we reach the end of the array or have no more capital left
    if ind == n or cap == 0:
        return 0

    # Check if the result is already calculated
    if dp[ind][buy][cap] != -1:
        return dp[ind][buy][cap]

    # Initialize profit
    profit = 0

    if buy == 0:  # We can buy the stock
        profit = max(
            0 + get_max_profit(prices, n, ind + 1, 0, cap, dp),
            -prices[ind] + get_max_profit(prices, n, ind + 1, 1, cap, dp)
        )

    if buy == 1:  # We can sell the stock
        profit = max(
            0 + get_max_profit(prices, n, ind + 1, 1, cap, dp),
            prices[ind] + get_max_profit(prices, n, ind + 1, 0, cap - 1, dp)
        )

    # Memoize the result and return
    dp[ind][buy][cap] = profit
    return profit


def maximum_profit(prices, n, k):
    # Creating a 3D dp array of size [n][2][k+1]
    dp = [[[(-1) for _ in range(k + 1)] for _ in range(2)] for _ in range(n)]

    return get_max_profit(prices, n, 0, 0, k, dp)


if __name__ == "__main__":
    prices = [3, 3, 5, 0, 0, 3, 1, 4]
    n = len(prices)
    k = 2

    result = maximum_profit(prices, n, k)
    print(f"The maximum profit that can be generated is {result}")





# method 2 : tabulation
Time Complexity: O(N*2*k) 

Reason: There are three nested loops that account for O(N*2*K) complexity.

Space Complexity: O(N*2*k)

Reason: We are using an external array of size â€˜N*2*Kâ€™. Stack Space is eliminated.


def maximum_profit(prices, n, k):
    # Creating a 3D dp array of size [n+1][2][k+1] initialized to 0
    dp = [[[0 for _ in range(k + 1)] for _ in range(2)] for _ in range(n + 1)]

    # Loop through the array from right to left
    for ind in range(n - 1, -1, -1):
        for buy in range(2):
            for cap in range(1, k + 1):

                if buy == 0:  # We can buy the stock
                    dp[ind][buy][cap] = max(0 + dp[ind + 1][0][cap],
                                            -prices[ind] + dp[ind + 1][1][cap])

                if buy == 1:  # We can sell the stock
                    dp[ind][buy][cap] = max(0 + dp[ind + 1][1][cap],
                                            prices[ind] + dp[ind + 1][0][cap - 1])

    return dp[0][0][k]


if __name__ == "__main__":
    prices = [3, 3, 5, 0, 0, 3, 1, 4]
    n = len(prices)
    k = 2

    result = maximum_profit(prices, n, k)
    print(f"The maximum profit that can be generated is {result}")


# method 3 : space optimization
Time Complexity: O(N*2*K)

Reason: There are three nested loops that account for O(N*2*K) complexity

Space Complexity: O(K)

Reason: We are using two external arrays of size â€˜2*Kâ€™.


def max_profit(prices, n, k):
    # Create two 2D arrays to store the current and ahead states
    ahead = [[0] * (k + 1) for _ in range(2)]
    cur = [[0] * (k + 1) for _ in range(2)]

    for ind in range(n - 1, -1, -1):
        for buy in range(2):
            for cap in range(1, k + 1):

                if buy == 0:  # We can buy the stock
                    cur[buy][cap] = max(0 + ahead[0][cap],
                                       -prices[ind] + ahead[1][cap])

                if buy == 1:  # We can sell the stock
                    cur[buy][cap] = max(0 + ahead[1][cap],
                                       prices[ind] + ahead[0][cap - 1])

        # Update the 'ahead' array with the current state
        ahead = cur.copy()

    return ahead[0][k]


if __name__ == "__main__":
    prices = [3, 3, 5, 0, 0, 3, 1, 4]
    n = len(prices)
    k = 2

    result = max_profit(prices, n, k)
    print(f"The maximum profit that can be generated is {result}")


# 5 TODO : buy and sell stock with cooldown (DP-39)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/buy-and-sell-stocks-with-cooldown-dp-39/


https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/


'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
Time Complexity: O(N*2) 

Reason: There are N*2 states therefore at max â€˜N*2â€™ new problems will be solved and we are running a for loop for â€˜Nâ€™ times to calculate the total sum

Space Complexity: O(N*2) + O(N)

Reason: We are using a recursion stack space(O(N)) and a 2D array ( O(N*2)).


def get_max_profit(prices, ind, buy, n, dp):
    # Base case: if we reach the end of the array
    if ind >= n:
        return 0

    # Check if the result is already calculated
    if dp[ind][buy] != -1:
        return dp[ind][buy]

    # Initialize profit
    profit = 0

    if buy == 0:  # We can buy the stock
        profit = max(
            0 + get_max_profit(prices, ind + 1, 0, n, dp),
            -prices[ind] + get_max_profit(prices, ind + 1, 1, n, dp)
        )

    if buy == 1:  # We can sell the stock
        profit = max(
            0 + get_max_profit(prices, ind + 1, 1, n, dp),
            prices[ind] + get_max_profit(prices, ind + 2, 0, n, dp)
        )

    # Memoize the result and return
    dp[ind][buy] = profit
    return profit


def stock_profit(prices):
    n = len(prices)
    dp = [[-1 for _ in range(2)] for _ in range(n)]

    ans = get_max_profit(prices, 0, 0, n, dp)
    return ans


if __name__ == "__main__":
    prices = [4, 9, 0, 4, 10]

    result = stock_profit(prices)
    print(f"The maximum profit that can be generated is {result}")





# method 2 : tabulation
Time Complexity: O(N*2) 

Reason: There are two nested loops that account for O(N*2) complexity.

Space Complexity: O(N*2)

Reason: We are using an external array of size â€˜N*2â€™. Stack Space is eliminated.


def stock_profit(prices):
    n = len(prices)
    
    # Create a 2D dp array of size [n+2][2] initialized to 0
    dp = [[0 for _ in range(2)] for _ in range(n + 2)]

    for ind in range(n - 1, -1, -1):
        for buy in range(2):
            profit = 0

            if buy == 0:  # We can buy the stock
                profit = max(
                    0 + dp[ind + 1][0],
                    -prices[ind] + dp[ind + 1][1]
                )

            if buy == 1:  # We can sell the stock
                profit = max(
                    0 + dp[ind + 1][1],
                    prices[ind] + dp[ind + 2][0]
                )

            dp[ind][buy] = profit

    return dp[0][0]


if __name__ == "__main__":
    prices = [4, 9, 0, 4, 10]

    result = stock_profit(prices)
    print(f"The maximum profit that can be generated is {result}")



# method 3 : space optimization
Time Complexity: O(N*2)

Reason: There are two nested loops that account for O(N*2) complexity

Space Complexity: O(1)

Reason: We are using three external arrays of size â€˜2â€™.


def stock_profit(prices):
    n = len(prices)
    
    # Initialize three lists to track the profit states
    cur = [0, 0]
    front1 = [0, 0]
    front2 = [0, 0]

    for ind in range(n - 1, -1, -1):
        for buy in range(2):
            profit = 0

            if buy == 0:  # We can buy the stock
                profit = max(
                    0 + front1[0],
                    -prices[ind] + front1[1]
                )

            if buy == 1:  # We can sell the stock
                profit = max(
                    0 + front1[1],
                    prices[ind] + front2[0]
                )

            cur[buy] = profit

        # Update the 'front' lists for the next iteration
        front2 = front1.copy()
        front1 = cur.copy()

    return cur[0]


if __name__ == "__main__":
    prices = [4, 9, 0, 4, 10]

    result = stock_profit(prices)
    print(f"The maximum profit that can be generated is {result}")


# 6 TODO : buy and sell stock with transaction fee (DP-40)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/buy-and-sell-stocks-with-transaction-fees-dp-40/


https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/


'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
Time Complexity: O(N*2) 

Reason: There are N*2 states therefore at max â€˜N*2â€™ new problems will be solved and we are running a for loop for â€˜Nâ€™ times to calculate the total sum

Space Complexity: O(N*2) + O(N)

Reason: We are using a recursion stack space(O(N)) and a 2D array ( O(N*2)).


def get_max_profit(prices, ind, buy, n, fee, dp):
    # Base case: if we reach the end of the array
    if ind == n:
        return 0

    # Check if the result is already calculated
    if dp[ind][buy] != -1:
        return dp[ind][buy]

    profit = 0

    if buy == 0:  # We can buy the stock
        profit = max(
            0 + get_max_profit(prices, ind + 1, 0, n, fee, dp),
            -prices[ind] + get_max_profit(prices, ind + 1, 1, n, fee, dp)
        )

    if buy == 1:  # We can sell the stock
        profit = max(
            0 + get_max_profit(prices, ind + 1, 1, n, fee, dp),
            prices[ind] - fee + get_max_profit(prices, ind + 1, 0, n, fee, dp)
        )

    dp[ind][buy] = profit
    return profit


def maximum_profit(n, fee, prices):
    dp = [[-1 for _ in range(2)] for _ in range(n)]

    if n == 0:
        return 0

    ans = get_max_profit(prices, 0, 0, n, fee, dp)
    return ans


if __name__ == "__main__":
    prices = [1, 3, 2, 8, 4, 9]
    n = len(prices)
    fee = 2

    result = maximum_profit(n, fee, prices)
    print(f"The maximum profit that can be generated is {result}")



# method 2 : tabulation
Time Complexity: O(N*2) 

Reason: There are two nested loops that account for O(N*2) complexity.

Space Complexity: O(N*2)

Reason: We are using an external array of size â€˜N*2â€™. Stack Space is eliminated.


def maximum_profit(n, fee, prices):
    if n == 0:
        return 0

    # Create a 2D dp array of size [n+1][2] initialized to 0
    dp = [[0 for _ in range(2)] for _ in range(n + 1)]

    # Loop through the array from right to left
    for ind in range(n - 1, -1, -1):
        for buy in range(2):
            profit = 0

            if buy == 0:  # We can buy the stock
                profit = max(
                    0 + dp[ind + 1][0],
                    -prices[ind] + dp[ind + 1][1]
                )

            if buy == 1:  # We can sell the stock
                profit = max(
                    0 + dp[ind + 1][1],
                    prices[ind] - fee + dp[ind + 1][0]
                )

            dp[ind][buy] = profit

    return dp[0][0]


if __name__ == "__main__":
    prices = [1, 3, 2, 8, 4, 9]
    n = len(prices)
    fee = 2

    result = maximum_profit(n, fee, prices)
    print(f"The maximum profit that can be generated is {result}")





# method 3 : space optimization
Time Complexity: O(N*2)

Reason: There are two nested loops that account for O(N*2) complexity

Space Complexity: O(1)

Reason: We are using an external array of size â€˜2â€™.


def maximum_profit(n, fee, prices):
    if n == 0:
        return 0

    # Initialize two lists to track the profit states
    ahead = [0, 0]
    cur = [0, 0]

    # Base condition
    ahead[0] = ahead[1] = 0

    for ind in range(n - 1, -1, -1):
        for buy in range(2):
            profit = 0

            if buy == 0:  # We can buy the stock
                profit = max(
                    0 + ahead[0],
                    -prices[ind] + ahead[1]
                )

            if buy == 1:  # We can sell the stock
                profit = max(
                    0 + ahead[1],
                    prices[ind] - fee + ahead[0]
                )

            cur[buy] = profit

        # Update the 'ahead' list for the next iteration
        ahead = cur.copy()

    return cur[0]


if __name__ == "__main__":
    prices = [1, 3, 2, 8, 4, 9]
    n = len(prices)
    fee = 2

    result = maximum_profit(n, fee, prices)
    print(f"The maximum profit that can be generated is {result}")




# endregion





# region 16.7 DP - LIS
# --------------------

# 1 TODO :  longest increasing subsequence (DP-41)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/longest-increasing-subsequence-dp-41/


https://leetcode.com/problems/longest-increasing-subsequence/


'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
Time Complexity: O(N*N)

Reason: There are N*N states therefore at max â€˜N*Nâ€™ new problems will be solved.

Space Complexity: O(N*N) + O(N)

Reason: We are using an auxiliary recursion stack space(O(N)) (see the recursive tree, in the worst case we will go till N calls at a time) and a 2D array ( O(N*N+1)).
def get_longest_increasing_subsequence_length(arr, n, ind, prev_index, dp):
    # Base condition
    if ind == n:
        return 0

    if dp[ind][prev_index + 1] != -1:
        return dp[ind][prev_index + 1]

    not_take = 0 + get_longest_increasing_subsequence_length(arr, n, ind + 1, prev_index, dp)

    take = 0

    if prev_index == -1 or arr[ind] > arr[prev_index]:
        take = 1 + get_longest_increasing_subsequence_length(arr, n, ind + 1, ind, dp)

    dp[ind][prev_index + 1] = max(not_take, take)
    return dp[ind][prev_index + 1]


def longest_increasing_subsequence_length(arr):
    n = len(arr)
    dp = [[-1 for _ in range(n + 1)] for _ in range(n)]

    return get_longest_increasing_subsequence_length(arr, n, 0, -1, dp)


if __name__ == "__main__":
    arr = [10, 9, 2, 5, 3, 7, 101, 18]

    result = longest_increasing_subsequence_length(arr)
    print("The length of the longest increasing subsequence is", result)  


# method 2 : tabulation
# TC     -      
# SC     -     


# method 3 : space optimization
# TC     -      
# SC     -      


# 2 TODO : printing longest increasing subsequence (DP-42)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/printing-longest-increasing-subsequence-dp-42/


https://bit.ly/3XiRbmG


'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
# TC     -      
# SC     -     


# method 2 : tabulation
# TC     -      
# SC     -     


# method 3 : space optimization
# TC     -      
# SC     -      


# 3 TODO : longest increasing subsequence (DP-43)

'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/longest-increasing-subsequence-binary-search-dp-43/



https://bit.ly/3Pxf84L


'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
Time Complexity: O(N*logN)

Reason: We iterate over the array of size N and in every iteration, we perform a binary search which takes logN time.

Space Complexity: O(N)

Reason: We are using an extra array of size N to store the temp variable.
def longest_increasing_subsequence_length(arr):
    n = len(arr)

    # Initialize a temporary list to store the increasing subsequence
    temp = [arr[0]]
    length = 1

    for i in range(1, n):
        if arr[i] > temp[-1]:
            # If arr[i] is greater than the last element of temp, extend the subsequence
            temp.append(arr[i])
            length += 1
        else:
            # Use binary search to find the position to replace the element in temp
            ind = bisect_left(temp, arr[i])
            temp[ind] = arr[i]

    return length


if __name__ == "__main__":
    arr = [10, 9, 2, 5, 3, 7, 101, 18]

    result = longest_increasing_subsequence_length(arr)
    print("The length of the longest increasing subsequence is", result)


# method 2 : tabulation
# TC     -      
# SC     -     


# method 3 : space optimization
# TC     -      
# SC     -      


# 4 TODO : largest divisible subset (DP-44)
'''


ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/longest-divisible-subset-dp-44/


https://leetcode.com/problems/largest-divisible-subset/


'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
Time Complexity: O(N*N)

Reason: There are two nested loops.

Space Complexity: O(N)

Reason: We are only using two rows of size n.
def longest_divisible_subset(arr):
    n = len(arr)

    # Sort the array in ascending order
    arr.sort()

    # Initialize dp and hash arrays with 1s
    dp = [1] * n
    hash_arr = list(range(n))

    # Iterate through the array
    for i in range(n):
        for prev_index in range(i):
            if arr[i] % arr[prev_index] == 0 and 1 + dp[prev_index] > dp[i]:
                dp[i] = 1 + dp[prev_index]
                hash_arr[i] = prev_index

    ans = -1
    last_index = -1

    # Find the maximum length and its corresponding index
    for i in range(n):
        if dp[i] > ans:
            ans = dp[i]
            last_index = i

    # Reconstruct the divisible subset
    result = [arr[last_index]]

    while hash_arr[last_index] != last_index:
        last_index = hash_arr[last_index]
        result.append(arr[last_index])

    return result


if __name__ == "__main__":
    arr = [1, 16, 7, 8, 4]

    ans = longest_divisible_subset(arr)

    print("The longest divisible subset elements are:", ans)


# method 2 : tabulation
# TC     -      
# SC     -     


# method 3 : space optimization
# TC     -      
# SC     -      


# 5 TODO : largest string chain (DP-45)
'''


ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/longest-string-chain-dp-45/


https://leetcode.com/problems/longest-string-chain/


'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
Time Complexity: O(N*N * l)

Reason: We are setting up two nested loops and the compare function can be estimated to l, where l is the length of the longest string in the words [ ] array. Also, we are sorting so the time complexity will be (N^2 * l + NlogN)

Space Complexity: O(N)

Reason: We are only using a single array of size n.
def is_predecessor(s1, s2):
    # Check if s2 is a predecessor of s1
    if len(s1) != len(s2) + 1:
        return False

    first = 0
    second = 0

    while first < len(s1):
        if second < len(s2) and s1[first] == s2[second]:
            first += 1
            second += 1
        else:
            first += 1

    return first == len(s1) and second == len(s2)


def longest_string_chain(arr):
    n = len(arr)

    # Sort the array in ascending order of string length
    arr.sort(key=len)

    dp = [1] * n
    maxi = 1

    for i in range(n):
        for prev_index in range(i):
            if is_predecessor(arr[i], arr[prev_index]) and 1 + dp[prev_index] > dp[i]:
                dp[i] = 1 + dp[prev_index]

        if dp[i] > maxi:
            maxi = dp[i]

    return maxi


if __name__ == "__main__":
    words = ["a", "b", "ba", "bca", "bda", "bdca"]

    result = longest_string_chain(words)

    print("The length of the longest string chain is:", result)



# method 2 : tabulation
# TC     -      
# SC     -     


# method 3 : space optimization
# TC     -      
# SC     -      


# 6 TODO : longest bitonic subsequence (DP-46)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´



https://takeuforward.org/data-structure/longest-bitonic-subsequence-dp-46/


https://practice.geeksforgeeks.org/problems/longest-bitonic-subsequence0824/1


'''


# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
Time Complexity: O(N*N)

Reason: There are two nested loops that are run twice.

Space Complexity: O(N)

Reason: We are only using two rows of size n.
def longest_bitonic_sequence(arr):
    n = len(arr)

    # Initialize two dynamic programming lists for increasing and decreasing subsequences
    dp1 = [1] * n
    dp2 = [1] * n

    # Calculate the length of the longest increasing subsequence
    for i in range(n):
        for prev_index in range(i):
            if arr[prev_index] < arr[i]:
                dp1[i] = max(dp1[i], 1 + dp1[prev_index])

    # Reverse the direction of nested loops to calculate the length of the longest decreasing subsequence
    for i in range(n - 1, -1, -1):
        for prev_index in range(n - 1, i, -1):
            if arr[prev_index] < arr[i]:
                dp2[i] = max(dp2[i], 1 + dp2[prev_index])

    maxi = -1

    # Find the maximum length of bitonic subsequence by combining increasing and decreasing lengths
    for i in range(n):
        maxi = max(maxi, dp1[i] + dp2[i] - 1)

    return maxi


if __name__ == "__main__":
    arr = [1, 11, 2, 10, 4, 5, 2, 1]
    n = len(arr)

    print("The length of the longest bitonic subsequence is", longest_bitonic_sequence(arr))


# method 2 : tabulation
# TC     -      
# SC     -     


# method 3 : space optimization
# TC     -      
# SC     -      


# 7 TODO : number of longest increasing subsequence (DP-47)
'''


ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/number-of-longest-increasing-subsequences-dp-47/


https://leetcode.com/problems/number-of-longest-increasing-subsequence/


'''


# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
Time Complexity: O(N*N)

Reason: There are two nested loops that are run twice.

Space Complexity: O(N)

Reason: We are only using two rows of size n.
def find_number_of_LIS(arr):
    n = len(arr)

    # Initialize two dynamic programming lists for lengths and counts
    dp = [1] * n
    count = [1] * n

    maxi = 1

    for i in range(n):
        for prev_index in range(i):
            if arr[prev_index] < arr[i] and dp[prev_index] + 1 > dp[i]:
                dp[i] = dp[prev_index] + 1
                # Inherit the count
                count[i] = count[prev_index]
            elif arr[prev_index] < arr[i] and dp[prev_index] + 1 == dp[i]:
                # Increase the count
                count[i] += count[prev_index]
        
        maxi = max(maxi, dp[i])

    num_of_LIS = 0

    # Count the number of Longest Increasing Subsequences
    for i in range(n):
        if dp[i] == maxi:
            num_of_LIS += count[i]

    return num_of_LIS


if __name__ == "__main__":
    arr = [1, 5, 4, 3, 2, 6, 7, 2]

    print("The count of Longest Increasing Subsequences is:", find_number_of_LIS(arr))  


# method 2 : tabulation

# TC     -      
# SC     -     


# method 3 : space optimization
# TC     -      
# SC     -      



# endregion






# region 16.8 DP - MCM/PARTITION
# ------------------------------

# 1 TODO :  bitonic chain multiplication (DP-48)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/dynamic-programming/matrix-chain-multiplication-dp-48/


https://bit.ly/3Cgg36D


'''


# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
# TC     -      
# SC     -     


# method 2 : tabulation
# TC     -      
# SC     -     


# method 3 : space optimization
# TC     -      
# SC     -      


# 2 TODO : matrix chain multiplication | Bottom up (DP-49)
'''


ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/matrix-chain-multiplication-tabulation-method-dp-49/


https://bit.ly/3Cgg36D


'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
Time Complexity: O(N*N*N)

Reason: There are N*N states and we explicitly run a loop inside the function which will run for N times, therefore at max â€˜N*N*Nâ€™ new problems will be solved.

Space Complexity: O(N*N)

Reason: We are using a 2D array ( O(N*N)) space.
def matrix_multiplication(arr):
    N = len(arr)
    
    # Initialize a 2D dp list with -1 values
    dp = [[-1 for _ in range(N)] for _ in range(N)]
    
    # Initialize the diagonal elements of the dp table to 0
    for i in range(N):
        dp[i][i] = 0
    
    # Loop through the dp table to calculate the minimum number of operations
    for i in range(N - 1, 0, -1):
        for j in range(i + 1, N):
            mini = float('inf')
            
            # Partitioning loop
            for k in range(i, j):
                ans = dp[i][k] + dp[k + 1][j] + arr[i - 1] * arr[k] * arr[j]
                mini = min(mini, ans)
            
            dp[i][j] = mini
    
    # The result is stored in the top-right corner of the dp table
    return dp[1][N - 1]


if __name__ == "__main__":
    arr = [10, 20, 30, 40, 50]

    print("The minimum number of operations is:", matrix_multiplication(arr))

# method 2 : tabulation
# TC     -      
# SC     -     


# method 3 : space optimization
# TC     -      
# SC     -      


# 3 TODO : minimum cost to cut the stick (DP-50)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/minimum-cost-to-cut-the-stick-dp-50/


https://leetcode.com/problems/minimum-cost-to-cut-a-stick/

'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
Time Complexity: Exponential


def min_cost(n, c, cuts):
    # Define a 2D memoization table to store intermediate results
    dp = [[0] * (c + 2) for _ in range(c + 2)]

    # Extend the cuts list with 0 and n, and sort it
    cuts = [0] + cuts + [n]
    cuts.sort()

    # Fill the memoization table using dynamic programming
    for length in range(2, c + 3):
        for i in range(c + 3 - length):
            j = i + length - 1
            dp[i][j] = float('inf')

            # Find the optimal partition point and calculate the cost
            for k in range(i + 1, j):
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + (cuts[j] - cuts[i]))

    # The result is stored in the top-right corner of the memoization table
    return dp[0][c + 1]

if __name__ == "__main__":
    cuts = [3, 5, 1, 4]
    c = len(cuts)
    n = 7

    print("The minimum cost incurred:", min_cost(n, c, cuts))





# method 2 : tabulation
Time Complexity: O(N*N*N)

Reason: There are 2 variables i and j, therefore, N*N states and we explicitly run a loop inside the function which will run for N times, therefore at max â€˜N*N*Nâ€™ new problems will be solved.

Space Complexity: O(N*N) + O(N)

Reason: We are using an auxiliary recursion stack space(O(N))and a 2D array ( O(N*N)).


def min_cost(n, c, cuts):
    # Define a 2D memoization table to store intermediate results
    dp = [[-1] * (c + 1) for _ in range(c + 1)]

    # Extend the cuts list with 0 and n, and sort it
    cuts = [0] + cuts + [n]
    cuts.sort()

    # Recursive function to find the minimum cost
    def f(i, j):
        # Base case
        if i > j:
            return 0
        
        if dp[i][j] != -1:
            return dp[i][j]
        
        mini = float('inf')
        
        for ind in range(i, j + 1):
            ans = cuts[j + 1] - cuts[i - 1] + f(i, ind - 1) + f(ind + 1, j)
            mini = min(mini, ans)
        
        dp[i][j] = mini
        return mini

    return f(1, c)

if __name__ == "__main__":
    cuts = [3, 5, 1, 4]
    c = len(cuts)
    n = 7

    print("The minimum cost incurred:", min_cost(n, c, cuts))



# method 3 : space optimization
Time Complexity: O(N*N*N)

Reason: There are 2 variables i and j, therefore, N*N states and we explicitly run a loop inside the function which will run for N times, therefore at max â€˜N*N*Nâ€™ new problems will be solved.

Space Complexity: O(N*N) 

Reason: We are using a 2D array ( O(N*N)).


def min_cost(n, c, cuts):
    # Extend the cuts list with 0 and n, and sort it
    cuts = [0] + cuts + [n]
    cuts.sort()
    
    # Create a 2D DP table initialized with zeros
    dp = [[0] * (c + 2) for _ in range(c + 2)]

    # Calculate the minimum cost using dynamic programming
    for i in range(c, 0, -1):
        for j in range(1, c + 1):
            if i > j:
                continue
            
            mini = float('inf')
            
            for ind in range(i, j + 1):
                ans = cuts[j + 1] - cuts[i - 1] + dp[i][ind - 1] + dp[ind + 1][j]
                mini = min(mini, ans)
            
            dp[i][j] = mini
    
    return dp[1][c]

if __name__ == "__main__":
    cuts = [3, 5, 1, 4]
    c = len(cuts)
    n = 7

    print("The minimum cost incurred:", min_cost(n, c, cuts))


# 4 TODO : burst balloons (DP-51)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/burst-balloons-partition-dp-dp-51/


https://leetcode.com/problems/burst-balloons/


'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
Time Complexity: Exponential


def maxCoins(a):
    n = len(a)
    a.insert(0, 1)
    a.append(1)

    # Create a 2D DP table initialized with zeros
    dp = [[0] * (n + 2) for _ in range(n + 2)]

    # Calculate the maximum coins using dynamic programming
    for length in range(1, n + 1):
        for i in range(1, n - length + 2):
            j = i + length - 1
            maxi = float('-inf')
            
            for ind in range(i, j + 1):
                cost = a[i - 1] * a[ind] * a[j + 1] + dp[i][ind - 1] + dp[ind + 1][j]
                maxi = max(maxi, cost)
            
            dp[i][j] = maxi
    
    return dp[1][n]

if __name__ == "__main__":
    a = [3, 1, 5, 8]
    ans = maxCoins(a)
    print(ans)





# method 2 : tabulation
Time Complexity: O(N3), There are total N2 no. of states. And for each state, we are running a partitioning loop roughly for N times.

Space Complexity: O(N2) + Auxiliary stack space of O(N), N2 for the dp array we are using. 


def maxCoins(a):
    n = len(a)
    
    # Extend the list 'a' with 1s at both ends
    a.insert(0, 1)
    a.append(1)

    # Create a 2D DP table initialized with -1s
    dp = [[-1] * (n + 2) for _ in range(n + 2)]

    def f(i, j):
        if i > j:
            return 0
        if dp[i][j] != -1:
            return dp[i][j]
        maxi = float('-inf')
        for ind in range(i, j + 1):
            cost = a[i - 1] * a[ind] * a[j + 1] + f(i, ind - 1) + f(ind + 1, j)
            maxi = max(maxi, cost)
        dp[i][j] = maxi
        return maxi

    return f(1, n)

if __name__ == "__main__":
    a = [3, 1, 5, 8]
    ans = maxCoins(a)
    print(ans)




# method 3 : space optimization
Time Complexity: O(N3), There are total N2 no. of states. And for each state, we are running a partitioning loop roughly for N times.

Space Complexity: O(N2), N2 for the dp array we are using.


def maxCoins(a):
    n = len(a)
    
    # Extend the list 'a' with 1s at both ends
    a.insert(0, 1)
    a.append(1)

    # Create a 2D DP table initialized with 0s
    dp = [[0] * (n + 2) for _ in range(n + 2)]

    # Loop from the end of 'a' to the beginning
    for i in range(n, 0, -1):
        for j in range(1, n + 1):
            if i > j:
                continue
            maxi = float('-inf')
            
            # Iterate through the balloons from 'i' to 'j'
            for ind in range(i, j + 1):
                cost = a[i - 1] * a[ind] * a[j + 1] + dp[i][ind - 1] + dp[ind + 1][j]
                maxi = max(maxi, cost)
            
            dp[i][j] = maxi
    
    return dp[1][n]

if __name__ == "__main__":
    a = [3, 1, 5, 8]
    ans = maxCoins(a)
    print(ans)






# 5 TODO : evaluate boolean expression to true (DP-52)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/evaluate-boolean-expression-to-true-partition-dp-dp-52/


https://leetcode.com/problems/parsing-a-boolean-expression/


'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
Time Complexity: Exponential


def evaluateExp(exp):
    n = len(exp)
    mod = 1000000007
    
    def f(i, j, isTrue):
        # Base case 1:
        if i > j:
            return 0
        # Base case 2:
        if i == j:
            if isTrue == 1:
                return int(exp[i] == 'T')
            else:
                return int(exp[i] == 'F')
        
        ways = 0
        for ind in range(i + 1, j, 2):
            lT = f(i, ind - 1, 1)
            lF = f(i, ind - 1, 0)
            rT = f(ind + 1, j, 1)
            rF = f(ind + 1, j, 0)

            if exp[ind] == '&':
                if isTrue:
                    ways = (ways + (lT * rT) % mod) % mod
                else:
                    ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod
            elif exp[ind] == '|':
                if isTrue:
                    ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod
                else:
                    ways = (ways + (lF * rF) % mod) % mod
            else:
                if isTrue:
                    ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod
                else:
                    ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod
        
        return ways
    
    return f(0, n - 1, 1)

if __name__ == "__main__":
    exp = "F|T^F"
    ways = evaluateExp(exp)
    print("The total number of ways:", ways)





# method 2 : tabulation
Time Complexity: O(N*N*2 * N) ~ O(N3) There are a total of 2*N2 no. of states. And for each state, we are running a partitioning loop roughly for N times.

Space Complexity: O(2*N2) + Auxiliary stack space of O(N), 2*N2 for the dp array we are using.


def evaluateExp(exp):
    n = len(exp)
    mod = 1000000007
    
    def f(i, j, isTrue, dp):
        # Base case 1:
        if i > j:
            return 0
        # Base case 2:
        if i == j:
            if isTrue == 1:
                return int(exp[i] == 'T')
            else:
                return int(exp[i] == 'F')
        
        if dp[i][j][isTrue] != -1:
            return dp[i][j][isTrue]
        
        ways = 0
        for ind in range(i + 1, j, 2):
            lT = f(i, ind - 1, 1, dp)
            lF = f(i, ind - 1, 0, dp)
            rT = f(ind + 1, j, 1, dp)
            rF = f(ind + 1, j, 0, dp)

            if exp[ind] == '&':
                if isTrue:
                    ways = (ways + (lT * rT) % mod) % mod
                else:
                    ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod
            elif exp[ind] == '|':
                if isTrue:
                    ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod
                else:
                    ways = (ways + (lF * rF) % mod) % mod
            else:
                if isTrue:
                    ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod
                else:
                    ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod
        
        dp[i][j][isTrue] = ways
        return ways
    
    dp = [[[ -1 for _ in range(2)] for _ in range(n)] for _ in range(n)]
    return f(0, n - 1, 1, dp)

if __name__ == "__main__":
    exp = "F|T^F"
    ways = evaluateExp(exp)
    print("The total number of ways:", ways)





# method 3 : space optimization
Time Complexity: O(N*N*2 * N) ~ O(N3) There are a total of 2*N2 no. of states. And for each state, we are running a partitioning loop roughly for N times.

Space Complexity: O(2*N2), 2*N2 for the dp array we are using.


def evaluateExp(exp):
    n = len(exp)
    mod = 1000000007
    
    # Create a 3D DP array to store the results of subproblems
    dp = [[[0 for _ in range(2)] for _ in range(n)] for _ in range(n)]
    
    # Iterate over the expression string
    for i in range(n - 1, -1, -1):
        for j in range(n):
            # Base case 1: Skip invalid ranges
            if i > j:
                continue
            
            # Iterate over possible values of 'isTrue' (0 or 1)
            for isTrue in range(2):
                # Base case 2: When i == j
                if i == j:
                    if isTrue == 1:
                        dp[i][j][isTrue] = int(exp[i] == 'T')
                    else:
                        dp[i][j][isTrue] = int(exp[i] == 'F')
                    continue
                
                # Recurrence logic
                ways = 0
                for ind in range(i + 1, j, 2):
                    lT = dp[i][ind - 1][1]
                    lF = dp[i][ind - 1][0]
                    rT = dp[ind + 1][j][1]
                    rF = dp[ind + 1][j][0]

                    if exp[ind] == '&':
                        if isTrue:
                            ways = (ways + (lT * rT) % mod) % mod
                        else:
                            ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod
                    elif exp[ind] == '|':
                        if isTrue:
                            ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod
                        else:
                            ways = (ways + (lF * rF) % mod) % mod
                    else:
                        if isTrue:
                            ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod
                        else:
                            ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod
                
                dp[i][j][isTrue] = ways
    
    # The final result is stored in dp[0][n - 1][1] when the expression is considered true
    return dp[0][n - 1][1]

if __name__ == "__main__":
    exp = "F|T^F"
    ways = evaluateExp(exp)
    print("The total number of ways:", ways)


# 6 TODO : pallindrome partioning - I (DP-53)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/palindrome-partitioning-ii-front-partition-dp-53/


https://leetcode.com/problems/palindrome-partitioning-ii/


'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
Time Complexity: Exponential


def is_palindrome(i, j, s):
    # Helper function to check if a substring s[i...j] is a palindrome
    while i < j:
        if s[i] != s[j]:
            return False
        i += 1
        j -= 1
    return True

def f(i, n, s):
    # Base case: If we reach the end of the string, no further partition is needed
    if i == n:
        return 0

    min_cost = float('inf')
    
    # Iterate over possible substrings starting from index i
    for j in range(i, n):
        if is_palindrome(i, j, s):
            # If s[i...j] is a palindrome, calculate the cost
            cost = 1 + f(j + 1, n, s)
            min_cost = min(min_cost, cost)

    return min_cost

def palindrome_partitioning(s):
    # Main function to find the minimum number of partitions
    n = len(s)
    return f(0, n, s) - 1  # Subtract 1 to exclude the initial unpartitioned string

if __name__ == "__main__":
    str = "BABABCBADCEDE"
    partitions = palindrome_partitioning(str)
    print("The minimum number of partitions:", partitions)



# method 2 : tabulation
Time Complexity: O(N2)
Reason: There are a total of N states and inside each state, a loop of size N(apparently) is running.

Space Complexity: O(N) + Auxiliary stack space O(N)
Reason: The first O(N) is for the dp array of size N.


def is_palindrome(i, j, s):
    # Helper function to check if a substring s[i...j] is a palindrome
    while i < j:
        if s[i] != s[j]:
            return False
        i += 1
        j -= 1
    return True

def f(i, n, s, dp):
    # Base case: If we reach the end of the string, no further partition is needed
    if i == n:
        return 0

    if dp[i] != -1:
        return dp[i]
    
    min_cost = float('inf')
    
    # Iterate over possible substrings starting from index i
    for j in range(i, n):
        if is_palindrome(i, j, s):
            # If s[i...j] is a palindrome, calculate the cost
            cost = 1 + f(j + 1, n, s, dp)
            min_cost = min(min_cost, cost)

    dp[i] = min_cost
    return dp[i]

def palindrome_partitioning(s):
    # Main function to find the minimum number of partitions
    n = len(s)
    dp = [-1] * n  # Initialize a memoization array with -1
    return f(0, n, s, dp) - 1  # Subtract 1 to exclude the initial unpartitioned string

if __name__ == "__main__":
    str = "BABABCBADCEDE"
    partitions = palindrome_partitioning(str)
    print("The minimum number of partitions:", partitions)





# method 3 : space optimization
Time Complexity: O(N2)
Reason: There are a total of N states and inside each state a loop of size N(apparently) is running.

Space Complexity: O(N)
Reason: O(N) is for the dp array we have used.


def is_palindrome(i, j, s):
    # Helper function to check if a substring s[i...j] is a palindrome
    while i < j:
        if s[i] != s[j]:
            return False
        i += 1
        j -= 1
    return True

def palindrome_partitioning(s):
    # Main function to find the minimum number of partitions
    n = len(s)
    dp = [0] * (n + 1)
    dp[n] = 0  # Initialize the last element of dp to 0
    for i in range(n - 1, -1, -1):  # Start from the second-to-last element and move backward
        min_cost = float('inf')
        # Iterate over possible substrings starting from index i
        for j in range(i, n):
            if is_palindrome(i, j, s):
                # If s[i...j] is a palindrome, calculate the cost
                cost = 1 + dp[j + 1]
                min_cost = min(min_cost, cost)
        dp[i] = min_cost

    return dp[0] - 1  # Subtract 1 to exclude the initial unpartitioned string

if __name__ == "__main__":
    str = "BABABCBADCEDE"
    partitions = palindrome_partitioning(str)
    print("The minimum number of partitions:", partitions)





# 7 TODO : partition array for maximumsum (DP-54)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/partition-array-for-maximum-sum-front-partition-dp-54/


https://leetcode.com/problems/partition-array-for-maximum-sum/


'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
Time Complexity: Exponential


def max_sum_after_partitioning(num, k):
    n = len(num)
    dp = [0] * (n + 1)

    for i in range(1, n + 1):
        max_val = 0
        for j in range(1, min(i, k) + 1):
            max_val = max(max_val, num[i - j])
            dp[i] = max(dp[i], dp[i - j] + max_val * j)

    return dp[n]

if __name__ == "__main__":
    num = [1, 15, 7, 9, 2, 5, 10]
    k = 3
    max_sum = max_sum_after_partitioning(num, k)
    print("The maximum sum is:", max_sum)





# method 2 : tabulation
Time Complexity: O(N*k)
Reason: There are a total of N states and for each state, we are running a loop from 0 to k.

Space Complexity: O(N) + Auxiliary stack space O(N)
Reason: First O(N) for the dp array we are using.


def max_sum_after_partitioning(num, k):
    n = len(num)
    dp = [-1] * n

    def f(ind):
        # Base case:
        if ind == n:
            return 0

        if dp[ind] != -1:
            return dp[ind]

        len_val = 0
        max_val = float('-inf')
        max_ans = float('-inf')

        for j in range(ind, min(ind + k, n)):
            len_val += 1
            max_val = max(max_val, num[j])
            summation = len_val * max_val + f(j + 1)
            max_ans = max(max_ans, summation)

        dp[ind] = max_ans
        return dp[ind]

    return f(0)

if __name__ == "__main__":
    num = [1, 15, 7, 9, 2, 5, 10]
    k = 3
    max_sum = max_sum_after_partitioning(num, k)
    print("The maximum sum is:", max_sum)





# method 3 : space optimization
Time Complexity: O(N*k)
Reason: There are a total of N states and for each state, we are running a loop from 0 to k.

Space Complexity: O(N)
Reason: O(N) for the dp array we are using.


def max_sum_after_partitioning(num, k):
    n = len(num)
    dp = [0] * (n + 1)

    for ind in range(n - 1, -1, -1):
        len_val = 0
        max_val = float('-inf')
        max_ans = float('-inf')

        for j in range(ind, min(ind + k, n)):
            len_val += 1
            max_val = max(max_val, num[j])
            summation = len_val * max_val + dp[j + 1]
            max_ans = max(max_ans, summation)

        dp[ind] = max_ans

    return dp[0]

if __name__ == "__main__":
    num = [1, 15, 7, 9, 2, 5, 10]
    k = 3
    max_sum = max_sum_after_partitioning(num, k)
    print("The maximum sum is:", max_sum)





# endregion






# region 16.9 DP - SQUARES
# ------------------------


# 1 TODO :  maximum rectangle area with all 1's (DP-55)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/maximum-rectangle-area-with-all-1s-dp-on-rectangles-dp-55/


https://leetcode.com/problems/maximal-rectangle/


'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
# TC     -      
# SC     -     


# method 2 : tabulation
# TC     -      
# SC     -     


# method 3 : space optimization
# TC     -      
# SC     -      


# 2 TODO : count square submatrices with all ones (DP-56)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/count-square-submatrices-with-all-1s-dp-on-rectangles-dp-56/


https://leetcode.com/problems/count-square-submatrices-with-all-ones/


'''

# method 0 : recursion 
'''
Time Complexity: 

Space Complexity: 

'''


# method 1 : memoization
# TC     -      
# SC     -     


# method 2 : tabulation
# TC     -      
# SC     -     


# method 3 : space optimization
# TC     -      
# SC     -      




# endregion






# region 17.1 TRIES - THEORY
# --------------------------

# 1 TODO :  implement trie | insert |search | startswith
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/implement-trie-1/


https://leetcode.com/problems/implement-trie-prefix-tree/

'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
'''
Time Complexity:

Insertion: O(N) where N is the length of the word being inserted. This is because we have to iterate over each letter of the word to find its corresponding node or create a node accordingly.

Search: O(N) where N is the length of the word being searched for. This is because in Trie search we traverse over each letter for the word from the root, checking if the current node contains a node at the index of the next letter. This process repeats until we reach the end of the word or encounter a node without the next letter.

Prefix Search: O(N) where N is the length of the prefix being searched for. Similar to searching for words, in prefix search we also iterate over each letter of the word to find its corresponding node.

Space Complexity: O(N) where N is the total number of characters across all unique words inserted into the Trie. For each character in a word, a new node may need to be created leading to space proportional to the number of characters.
'''                            
class Node:
    def __init__(self):
        # Array to store links to child nodes,
        # each index represents a letter
        self.links = [None] * 26
        # Flag indicating if the node
        # marks the end of a word
        self.flag = False

    # Check if the node contains
    # a specific key (letter)
    def containsKey(self, ch):
        return self.links[ord(ch) - ord('a')] is not None

    # Insert a new node with a specific
    # key (letter) into the Trie
    def put(self, ch, node):
        self.links[ord(ch) - ord('a')] = node

    # Get the node with a specific
    # key (letter) from the Trie
    def get(self, ch):
        return self.links[ord(ch) - ord('a')]

    # Set the current node
    # as the end of a word
    def setEnd(self):
        self.flag = True

    # Check if the current node
    # marks the end of a word
    def isEnd(self):
        return self.flag


class Trie:
    def __init__(self):
        # Constructor to initialize the
        # Trie with an empty root node
        self.root = Node()

    # Inserts a word into the Trie
    # Time Complexity O(len), where len
    # is the length of the word
    def insert(self, word):
        node = self.root
        for ch in word:
            if not node.containsKey(ch):
                # Create a new node for
                # the letter if not present
                node.put(ch, Node())
            # Move to the next node
            node = node.get(ch)
        # Mark the end of the word
        node.setEnd()

    # Returns if the word
    # is in the trie
    def search(self, word):
        node = self.root
        for ch in word:
            if not node.containsKey(ch):
                # If a letter is not found,
                # the word is not in the Trie
                return False
            # Move to the next node
            node = node.get(ch)
        # Check if the last node
        # marks the end of a word
        return node.isEnd()

    # Returns if there is any word in the
    # trie that starts with the given prefix
    def startsWith(self, prefix):
        node = self.root
        for ch in prefix:
            if not node.containsKey(ch):
                # If a letter is not found, there is
                # no word with the given prefix
                return False
            # Move to the next node
            node = node.get(ch)
        # The prefix is found in the Trie
        return True


if __name__ == "__main__":
    trie = Trie()
    print("Inserting words: Striver, Striving, String, Strike")
    trie.insert("striver")
    trie.insert("striving")
    trie.insert("string")
    trie.insert("strike")

    print("Search if Strawberry exists in trie: " +
          ("True" if trie.search("strawberry") else "False"))

    print("Search if Strike exists in trie: " +
          ("True" if trie.search("strike") else "False"))

    print("If words in Trie start with Stri: " +
          ("True" if trie.startsWith("stri") else "False"))




# endregion





# region 17.2 TRIES - PRACTICE PROBLEMS
# -------------------------------------

# 1 TODO :  implement trie -2 (prefix tree)
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/implement-trie-ii/


https://bit.ly/3qwT4OL

'''
# method 1 : brute force approch
Time Complexity: O(N) where N is the length of the word or prefix being processed.

Each method (insertion, counting words equal to a given word, counting words starting with a prefix, and erasing a word) requires traversing the Trie for each character of the input word or prefix.
Therefore, the time complexity is linear with respect to the length of the word or prefix being processed.
Space Complexity: O(N) where N is the total characters across all words inserted into the Trie. The space complexity is proportional to the number of unique words inserted into the Trie and the average length of those words.
                            
class Node:
    """
    Define a class for each node in the trie.
    """

    def __init__(self):
        # Array to store links
        # to child nodes
        self.links = [None] * 26
        # Counter for number of words
        # that end at this node
        self.cntEndWith = 0
        # Counter for number of words that
        # have this node as a prefix
        self.cntPrefix = 0

    def contains_key(self, ch):
        """
        Function to check if the
        node contains a specific key.
        """
        # Check if the link corresponding
        # to the character exists
        return self.links[ord(ch) - ord('a')] is not None

    def get(self, ch):
        """
        Function to get the child node
        corresponding to a key.
        """
        # Return the link corresponding
        # to the character
        return self.links[ord(ch) - ord('a')]

    def put(self, ch, node):
        """
        Function to insert a child node
        with a specific key.
        """
        # Set the link corresponding to
        # the character to the provided node
        self.links[ord(ch) - ord('a')] = node

    def increase_end(self):
        """
        Function to increment the count
        of words that end at this node.
        """
        # Increment the counter
        self.cntEndWith += 1

    def increase_prefix(self):
        """
        Function to increment the count of
        words that have this node as a prefix.
        """
        # Increment the counter
        self.cntPrefix += 1

    def delete_end(self):
        """
        Function to decrement the count of
        words that end at this node.
        """
        # Decrement the counter
        self.cntEndWith -= 1

    def reduce_prefix(self):
        """
        Function to decrement the count of 
        words that have this node as a prefix.
        """
        # Decrement the counter
        self.cntPrefix -= 1


class Trie:
    """
    Define a class for the
    trie data structure.
    """

    def __init__(self):
        """
        Constructor to initialize the
        trie with an empty root node.
        """
        # Create a new root node
        self.root = Node()

    def insert(self, word):
        """
        Function to insert a
        word into the trie.
        """
        # Start from the root node
        node = self.root
        
        # Iterate over each
        # character in the word
        for ch in word:
            # If the character is not
            # already in the trie
            
            if not node.contains_key(ch):
            
                # Create a new node
                # for the character
                node.put(ch, Node())
           
            # Move to the child node
            # corresponding to the character
            
            node = node.get(ch)
            # Increment the prefix
            # count for the node
            node.increase_prefix()
        # Increment the end count
        # for the last node of the word
        node.increase_end()

    def count_words_equal_to(self, word):
        """
        Function to count the number
        of words equal to a given word.
        """
        # Start from the
        # root node
        node = self.root
        # Iterate over each
        # character in the word
        for ch in word:
            # If the character is
            # found in the trie
            if node.contains_key(ch):
                # Move to the child node
                # corresponding to the character
                node = node.get(ch)
            else:
                # Return 0 if the
                # character is not found
                return 0
        # Return the count of
        # words ending at the node
        return node.cntEndWith

    def count_words_starting_with(self, word):
        """
        Function to count the number of
        words starting with a given prefix.
        """
        # Start from the root node
        node = self.root
        # Iterate over each
        # character in the prefix
        for ch in word:
            # If the character is
            # found in the trie
            if node.contains_key(ch):
                # Move to the child node
                # corresponding to the character
                node = node.get(ch)
            else:
                # Return 0 if the
                # character is not found
                return 0
        # Return the count of
        # words with the prefix
        return node.cntPrefix

    def erase(self, word):
        """
        Function to erase
        a word from the trie.
        """
        # Start from the root node
        node = self.root
        # Iterate over each
        # character in the word
        for ch in word:
            # If the character is
            # found in the trie
            if node.contains_key(ch):
                # Move to the child node
                # corresponding to the character
                node = node.get(ch)
                # Decrement the prefix
                # count for the node
                node.reduce_prefix()
            else:
                # Return if the
                # character is not found
                return
        # Decrement the end count
        # for the last node of the word
        node.delete_end()


if __name__ == "__main__":
    trie = Trie()
    trie.insert("apple")
    trie.insert("app")
    print("Inserting strings 'apple', 'app' into Trie")
    print("Count Words Equal to 'apple':", trie.count_words_equal_to("apple"))
    print("Count Words Starting With 'app':", trie.count_words_starting_with("app"))
    print("Erasing word 'app' from trie")
    trie.erase("app")
    print("Count Words Equal to 'apple':", trie.count_words_equal_to("apple"))
    print("Count Words Starting With 'apple':", trie.count_words_starting_with("app"))
                           
                         


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : longest string with all prefixes
'''


ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡


https://bit.ly/3n3kedU


'''
# method 1 : brute force approch
''' 

Time Complexity:

Insert Operation: Inserting a word into the Trie takes O(L) time, where L is the length of the word. For N words, the total time complexity for inserting all words is O(N * L).
Prefix Validity Check: For each word, checking if it has all valid prefixes also takes O(L) time. For N words, the total time complexity is O(N * L).
Therefore, the overall time complexity is O(N * L), where N is the number of words and L is the length of the longest word in the list.
Space Complexity:

Trie Construction: The space used by the Trie is proportional to the total number of characters across all words. In the worst case, if there are N words with a total of C characters, the space complexity of the Trie is O(C).
Additional Space: We also use O(N) space for storing the result and maintaining the list of words.
Therefore, the overall space complexity is O(C + N), where C is the total number of characters across all words and N is the number of words.


''' 
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_word_end = False

class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_word_end = True

    def is_prefix_valid(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
            if not node.is_word_end:  # Check if the prefix is a valid word
                return False
        return True

def longestStringWithAllPrefixes(words):
    trie = Trie()
    
    # Insert all words into the Trie
    for word in words:
        trie.insert(word)
    
    longest_word = ""
    
    # Step 2: Find the longest word with all valid prefixes
    for word in words:
        if trie.is_prefix_valid(word) and len(word) > len(longest_word):
            longest_word = word
            
    return longest_word

# Example usage:
words = ["a", "apple", "appl", "app", "apply", "b", "bat"]
result = longestStringWithAllPrefixes(words)
print("Longest string with all prefixes:", result)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 3 TODO : number of distinct substrings in a string
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://takeuforward.org/data-structure/number-of-distinct-substrings-in-a-string-using-trie/
https://bit.ly/3ocRQW0

'''
# method 1 : brute force approch
Time Complexity: O(N*N) where N is the number of characters in the given word. The implementation has two nested loops:

The outer loop iterates over each character of the string, leading to O(N) iterations.
The inner loop iterates over the remaining characters in the string for each character, also leading to O(N) iterations in the worst case.
Space Complexity : O(N*N)where N is the number of characters in the given word. The size of the set to store distinct substrings can grow up to O(N*N) in the worst case where all substrings are distinct. Each substring stored in the set occupies space proportional to its length, but the total space occupied by all substrings will limit to O(N*N).
                                
# Function to count all distinct
# substrings of a given string
def count_distinct_substrings(s):
    # Set to store
    # distinct substrings
    st = set()

    # Length of the
    # input string
    n = len(s)

    # Iterate over each
    # character in the string
    for i in range(n):
        # Initialize an empty string
        # to store the current substring
        substr = ""

        # Iterate over the remaining characters 
        # in the string starting from index i
        for j in range(i, n):
            # Append the current
            # character to the substring
            substr += s[j]

            # Insert the current
            # substring into the set
            st.add(substr)

    # Return the set containing
    # all distinct substrings
    return st

if __name__ == "__main__":
    s = "striver"
    print("Given String:", s)

    # Call the function to
    # count distinct substrings
    substrings = count_distinct_substrings(s)
    count = 0

    # Print the distinct substrings
    print("Distinct Substrings:")
    for substr in substrings:
        print(substr)
        count += 1

    # Count + 1 as we have to count
    # the empty string as well
    print("Number of distinct substrings:", count + 1)
                                




# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
Time Complexity: O(N*N)where N is the length of the input string. This is because for each starting position of the substring, we traverse the entire substring once. However, due to the Trie structure, the actual number of comparisons is reduced as we progress.

Space Complexity : O(N*N) where N is the length of the input string. In the worst-case scenario, where there are no common prefixes among substrings the number of nodes could be as high as the total number of substrings which is bounded by O(N*N).
                                
                     
class Node:
    """
    Node structure representing
    each node in the trie
    """

    def __init__(self):
        self.links = [None] * 26  
        # Array of pointers to child nodes,
        # each corresponding to a letter
        # of the alphabet
        self.flag = False  
        # Flag indicating if the current
        # node represents the end of a substring

    def containsKey(self, ch):
        """
        Method to check if a specific character key
        exists in the children of the current node
        """
        # Check if the current node has a child node
        # corresponding to character 'ch'
        return self.links[ord(ch) - ord('a')] is not None

    def get(self, ch):
        """
        Method to get the child node corresponding
        to a specific character key
        """
        # Get the child node
        # corresponding to character 'ch'
        return self.links[ord(ch) - ord('a')]

    def put(self, ch, node):
        """
        Method to insert a new child
        node with a specific character key
        """
        # Insert a new child
        # node for character 'ch'
        self.links[ord(ch) - ord('a')] = node

    def setEnd(self):
        """
        Method to mark the current
        node as the end of a substring
        """
        # Mark the current node
        # as the end of a substring
        self.flag = True

    def isEnd(self):
        """
        Method to check if the current
        node marks the end of a substring
        """
        # Check if the current node
        # marks the end of a substring
        return self.flag


def countDistinctSubstrings(s):
    """
    Function to count the number of
    distinct substrings in the given string
    """
    root = Node()  
    # Creating the root
    # node of the trie
    cnt = 0  
    # Counter to keep track
    # of distinct substrings
    n = len(s)  
    # Length of the input string

    # Nested loops to iterate through all
    # possible substrings of the input string
    for i in range(n):  
        # Iterate through each
        # starting position of the substring
        node = root  
        # Start from the root for each substring
        for j in range(i, n):  
            # Iterate through each character of the substring
            # If the current character is not a child
            # of the current node, insert it as a new child node
            if not node.containsKey(s[j]):
                node.put(s[j], Node())  
                # Insert a new child
                # node for character s[j]
                cnt += 1  
                # Increment the counter
                # since a new substring is found
            node = node.get(s[j])  
            # Move to the child node
            # corresponding to character s[j]

    return cnt + 1  
    # Return the total count of distinct substrings
    # (+1 to account for the input string itself)


if __name__ == "__main__":
    s = "striver"  
    # Input string
    print("Current String:", s)
    print("Number of distinct substrings:", countDistinctSubstrings(s))  
    # Output the result
                                
                              


# 4 TODO : bit preRequisites for trie problems
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://bit.ly/3Vw4XB1


'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 5 TODO : maximum xor of two numbers in an array
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://takeuforward.org/data-structure/maximum-xor-of-two-numbers-in-an-array/


https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/


'''
# method 1 : brute force approch
''' 

Time Complexity:
Insert Operation:

For each number, inserting it into the Trie takes O(32) time (since we are working with 32-bit integers).
Inserting all N numbers into the Trie takes O(N * 32) = O(N) time.
Find Maximum XOR Operation:

For each number, finding the maximum XOR with the current Trie takes O(32) time.
For N numbers, the total time complexity for finding the maximum XOR is O(N * 32) = O(N).
Hence, the overall time complexity is O(N), where N is the number of elements in the array.

Space Complexity:
Trie Space:

The Trie stores every bit of each number. Since each number has 32 bits, the space required for storing N numbers in the Trie is proportional to the number of bits stored, i.e., O(N * 32) = O(N).
Other Space:

We only use a constant amount of extra space for variables and the result, so the space complexity is O(N).
Thus, the space complexity is O(N), where N is the number of elements in the array.

'''  
class TrieNode:
    def __init__(self):
        self.children = {}
        
class Trie:
    def __init__(self):
        self.root = TrieNode()
        
    def insert(self, num):
        node = self.root
        # Insert each bit of the number (32-bit integer)
        for i in range(31, -1, -1):  # from the most significant bit to the least
            bit = (num >> i) & 1
            if bit not in node.children:
                node.children[bit] = TrieNode()
            node = node.children[bit]
    
    def find_max_xor(self, num):
        node = self.root
        max_xor = 0
        for i in range(31, -1, -1):
            bit = (num >> i) & 1
            opposite_bit = 1 - bit  # Opposite bit to maximize XOR
            if opposite_bit in node.children:
                max_xor |= (1 << i)  # Set the i-th bit of max_xor
                node = node.children[opposite_bit]
            else:
                node = node.children[bit]
        return max_xor

def find_maximum_xor(nums):
    trie = Trie()
    max_xor = 0
    for num in nums:
        trie.insert(num)
    
    for num in nums:
        max_xor = max(max_xor, trie.find_max_xor(num))
    
    return max_xor

# Example usage:
nums = [3, 10, 5, 25, 2, 8]
result = find_maximum_xor(nums)
print("Maximum XOR of two numbers in the array:", result)


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
Time Complexity: O(32*N + 32*M) where N is the length of the input array.

Insertion: The time complexity of inserting each number into the Trie is O(32) as each number is composed of 32 bits in the Binary Representation. This operation is performed for each of the N numbers in the first array.
Finding Maximum XOR Operation: To find the maximum XOR value for each number, we iterate through its 32 bits performing constant-time operations for each bit. This is performed for all M numbers in the second array hence this operation accounts for the second time complexity of O(32*N).
Space Complexity: O(32N) where N is the length of the input array. This algorithm has a linear space complexity with respect to the size of the input array and each number takes up space proportional to 32 which is the size in Binary Representation.
                            
class Node:
    """Node structure for the Trie"""

    def __init__(self):
        # Array to store links
        # to child nodes (0 and 1)
        self.links = [None, None]

    def contains_key(self, bit):
        # Method to check if a specific
        # bit key is present in the child nodes
        # Returns True if the link at
        # index 'bit' is not None
        return self.links[bit] is not None

    def get(self, bit):
        # Method to get the child node
        # corresponding to a specific bit
        # Returns the child
        # node at index 'bit'
        return self.links[bit]

    def put(self, bit, node):
        # Method to set a child node at a
        # specific index in the links array
        # Sets the child node at index
        # 'bit' to the provided node
        self.links[bit] = node


class Trie:
    """Trie class"""

    def __init__(self):
        # Constructor to initialize
        # the Trie with a root node
        # Creates a new root
        # node for the Trie
        self.root = Node()

    def insert(self, num):
        # Method to insert a number into the Trie
        # Start from the root node
        node = self.root
        # Iterate through each bit of the
        # number (from left to right)
        for i in range(31, -1, -1):
            # Extract the i-th bit of the number
            bit = (num >> i) & 1

            # If the current node doesn't have a
            # child node with the current bit
            if not node.contains_key(bit):
                # Create a new child node
                # with the current bit
                node.put(bit, Node())

            # Move to the child node
            # corresponding to the current bit
            node = node.get(bit)

    def get_max(self, num):
        # Method to find the maximum
        # XOR value for a given number
        # Start from the root node
        node = self.root

        # Initialize the maximum XOR value
        max_num = 0

        # Iterate through each bit of
        # the number (from left to right)
        for i in range(31, -1, -1):
            # Extract the i-th
            # bit of the number
            bit = (num >> i) & 1

            # If the complement of the current
            # bit exists in the Trie
            if node.contains_key(1 - bit):
                # Update the maximum XOR
                # value with the current bit
                max_num |= (1 << i)

                # Move to the child node corresponding
                # to the complement of the current bit
                node = node.get(1 - bit)
            else:
                # Move to the child node
                # corresponding to the current bit
                node = node.get(bit)

        # Return the maximum XOR value
        return max_num


def max_xor(n, m, arr1, arr2):
    # Function to find the maximum XOR
    # value between two sets of numbers
    # Create a Trie object
    trie = Trie()
    # Insert each number from
    # the first set into the Trie
    for num in arr1:
        trie.insert(num)

    # Initialize the maximum XOR value
    maxi = 0

    # Iterate through each
    # number in the second set
    for num in arr2:
        # Update the maximum XOR value
        # with the result from the Trie
        maxi = max(maxi, trie.get_max(num))

    # Return the
    # maximum XOR value
    return maxi


def print_arr(arr):
    # Function to print the
    # Input Arrays
    for item in arr:
        print(item, end=" ")
    print()


if __name__ == "__main__":
    arr1 = [3, 10, 5, 25, 2]
    arr2 = [8, 1, 2, 12, 7]
    n = len(arr1)
    m = len(arr2)

    print("Arr1: ", end="")
    print_arr(arr1)
    print("Arr2: ", end="")
    print_arr(arr2)

    result = max_xor(n, m, arr1, arr2)
    print("Maximum XOR value:", result)
                           
                          


# 6 TODO : maximum xor with an element from array
'''

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://takeuforward.org/trie/maximum-xor-queries-trie/


https://leetcode.com/problems/maximum-xor-with-an-element-from-array/


'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
Time Complexity: O(32*N + Q(logQ) + 32*Q) where N is the size of the input array and Q is the number of queries.

For each number in the input array, we traverse its bits from left to right (total of 32 bits). Since there are â€˜Nâ€™ numbers in the array, the total time complexity is O(32*N).
Sorting the offline queries based on their endpoints requires O(Q log(Q) time using the inbuilt library for sorting.
For each query, we traverse the bits of the numbers in the Trie to find the maximum XOR value. Since each number has 32 bits and there are Q Queries, the total time complexity for processing is O(32*Q).
Space Complexity: O(32*N + Q) where N is the size of the input array and Q is the number of queries.

The space complexity of the Trie depends on the number of bits required to represent the numbers in the input array. Each number is represented as a sequence of 32 bits hence the space required by the Trie is O(32*N).
We store the queries and sort them based on the endpoint of each query. This requires an additional space complexity of O(Q).
                            
class Node:
    def __init__(self):
        # Array to hold links
        # to child nodes (0 and 1)
        self.links = [None, None]

    # Function to check if a child node
    # exists at a given index (0 or 1)
    def containsKey(self, ind):
        return self.links[ind] is not None

    # Function to get the child
    # node at a given index (0 or 1)
    def get(self, ind):
        return self.links[ind]

    # Function to set the child
    # node at a given index (0 or 1)
    def put(self, ind, node):
        self.links[ind] = node


class Trie:
    def __init__(self):
        # Pointer to the root
        # node of the trie
        self.root = Node()

    # Function to insert a
    # number into the trie
    def insert(self, num):
        # Start traversal
        # from the root node
        node = self.root

        # Traverse each bit of the number
        # from the most significant bit
        # to the least significant bit
        for i in range(31, -1, -1):
            # Extract the i-th
            # bit of the number
            bit = (num >> i) & 1

            # If the current node doesn't
            # have a child node at the
            # current bit, create one
            if not node.containsKey(bit):
                node.put(bit, Node())

            # Move to the child node
            # corresponding to the current bit
            node = node.get(bit)

    # Function to find the maximum XOR
    # value achievable with a given number
    def findMax(self, num):
        # Start traversal from the root node
        node = self.root

        # Initialize the maximum XOR value
        maxNum = 0

        # Traverse each bit of the number
        # from the most significant bit to
        # the least significant bit
        for i in range(31, -1, -1):
            # Extract the i-th
            # bit of the number
            bit = (num >> i) & 1

            # If there exists a different bit
            # in the trie at the current position,
            # choose it to maximize XOR
            if node.containsKey(not bit):
                # Set the corresponding
                # bit in the result
                maxNum |= (1 << i)
                # Move to the child node
                # with the different bit
                node = node.get(not bit)
            else:
                # Move to the child node
                # with the same bit
                node = node.get(bit)

        # Return the maximum XOR value
        return maxNum


# Function to perform offline
# maximum XOR queries
def maxXorQueries(arr, queries):
    # Initialize list to
    # store results of queries
    ans = [0] * len(queries)

    # Vector to store offline queries
    offlineQueries = []

    # Sort the array of numbers
    arr.sort()

    # Convert queries to offline
    # queries and store them in a list
    index = 0
    for query in queries:
        offlineQueries.append((query[1], (query[0], index)))
        index += 1

    # Sort offline queries
    # based on their end points
    offlineQueries.sort()

    # Pointer to iterate through
    # the array of numbers
    i = 0

    # Number of elements in the array
    n = len(arr)

    # Create an instance of
    # the Trie data structure
    trie = Trie()

    # Process each offline query
    for end, (start, queryIndex) in offlineQueries:
        # Insert numbers into the trie
        # until the current query's end point
        while i < n and arr[i] <= end:
            trie.insert(arr[i])
            i += 1

        # If there are numbers inserted
        # into the trie, find the maximum
        # XOR value for the query range
        if i != 0:
            ans[queryIndex] = trie.findMax(start)
        else:
            # If no numbers inserted,
            # set result to -1
            ans[queryIndex] = -1

    # Return the results
    # of all queries
    return ans


if __name__ == "__main__":
    arr = [3, 10, 5, 25, 2, 8]
    print("Given Array:", arr)
    queries = [[0, 1], [1, 2], [0, 3], [3, 3]]
    print("Queries:", queries)

    result = maxXorQueries(arr, queries)

    print("Result of Max XOR Queries:")
    for i, res in enumerate(result):
        print(f"Query {i+1}: {res}")


# endregion





# region 18.1 STRINGS - HARD
# --------------------------

# 1 TODO :  minimum number of brackets reversals neededto make an expression balanced
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/

'''
# method 1 : brute force approch
''' 

Time Complexity:

The function processes the string once, making the time complexity O(N), where N is the length of the string.

Space Complexity:

We only use a constant amount of extra space for the counters (left_unmatched and right_unmatched), so the space complexity is O(1).

'''
def minReversalsToBalance(expression):
    # Step 1: If the length is odd, it's impossible to balance
    if len(expression) % 2 != 0:
        return -1
    
    # Step 2: Initialize counters for unmatched `{` and `}`
    left_unmatched = 0  # For `{`
    right_unmatched = 0  # For `}`
    
    for char in expression:
        if char == '{':
            left_unmatched += 1
        else:  # char == '}'
            if left_unmatched > 0:
                left_unmatched -= 1  # Match with an opening brace
            else:
                right_unmatched += 1  # Increment for unmatched closing brace
    
    # Step 3: Calculate the number of reversals needed
    # To balance the expression, we need to reverse half of the unmatched `{` and `}`
    return (left_unmatched + 1) // 2 + (right_unmatched + 1) // 2

# Example usage:
expression = "}{{}}{{{"
result = minReversalsToBalance(expression)
print(f"Minimum reversals needed: {result}")


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 2 TODO : count and say
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://leetcode.com/problems/count-and-say/


'''
# method 1 : brute force approch
''' 

Time Complexity:
For each term in the sequence, we have to iterate over the characters of the previous term.
The length of the terms grows rapidly (approximately doubles for each next term). Specifically, the length of the term in the nth sequence is roughly O(2^n).
Thus, the time complexity of generating the nth term is O(2^n).

Space Complexity:
We only store the current and next term in the sequence, so the space complexity is O(2^n) for the nth term.


'''
def countAndSay(n: int) -> str:
    # The first term in the sequence is always "1"
    result = "1"
    
    # Generate the sequence from 2 to n
    for _ in range(1, n):
        next_result = ""
        i = 0
        while i < len(result):
            count = 1
            # Count consecutive identical digits
            while i + 1 < len(result) and result[i] == result[i + 1]:
                count += 1
                i += 1
            # Append the count and the digit
            next_result += str(count) + result[i]
            i += 1
        
        # Move to the next term in the sequence
        result = next_result
    
    return result

# Example usage:
n = 5
print(f"The {n}th term in the Count and Say sequence is: {countAndSay(n)}")


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 3 TODO : hashing in strings | theory
'''

ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡



https://bit.ly/3glak75


'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 4 TODO : rabin karp
'''
ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

- The Rabin-Karp Algorithm is a popular string-searching (or substring searching) algorithm. It is used to find a pattern within a text (or large string) by utilizing a hashing technique. Instead of checking each substring individually in a brute force manner, it computes the hash of the pattern and compares it with hashes of substrings in the text, making it faster in many cases.

https://leetcode.com/problems/repeated-string-match/discuss/416144/Rabin-Karp-algorithm-C%2B%2B-implementation


'''
# method 1 : brute force approch
# TC     -      
# SC     -     
def rabinKarp(text, pattern):
    n = len(text)
    m = len(pattern)
    
    if m > n:
        return []

    # Prime number for hashing
    p = 31
    q = 10**9 + 7

    # Compute the hash of the pattern
    pattern_hash = 0
    for i in range(m):
        pattern_hash = (pattern_hash * p + ord(pattern[i])) % q

    # Compute the hash of the first window of the text
    window_hash = 0
    for i in range(m):
        window_hash = (window_hash * p + ord(text[i])) % q

    # Precompute p^m % q (for rolling hash update)
    p_m = pow(p, m, q)
    
    result = []

    # Sliding the window over the text
    for i in range(n - m + 1):
        # If hashes match, we check for exact string match
        if window_hash == pattern_hash and text[i:i + m] == pattern:
            result.append(i)

        # Roll the window (remove the old character and add the new one)
        if i < n - m:
            window_hash = (window_hash - ord(text[i]) * p_m) * p + ord(text[i + m])
            window_hash = window_hash % q

    return result

# Example usage:
text = "ababcababc"
pattern = "abc"
matches = rabinKarp(text, pattern)
print(f"Pattern found at indices: {matches}")


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 5 TODO : 2-function
'''
ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢


https://leetcode.com/problems/implement-strstr/



'''
# method 1 : brute force approch
# TC     -      
# SC     -     


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 6 TODO : KMP algo/LSP(pl) array

'''
ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

- KMP Algorithm (Knuth-Morris-Pratt Algorithm)
The KMP (Knuth-Morris-Pratt) algorithm is a famous string-searching (substring searching) algorithm that searches for occurrences of a pattern P within a text T. It improves upon the brute-force approach by avoiding redundant comparisons through preprocessing.
LPS Array (Longest Prefix Suffix): For a pattern, the LPS array stores, for each position i, the length of the longest proper prefix of the substring P[0..i] which is also a suffix of this substring. This allows the algorithm to "skip" certain character comparisons when mismatches occur during the search phase.
LPS (Longest Prefix Suffix) Array:
The LPS array helps in determining the next positions to compare by using previously gathered information about the pattern.
The array is constructed by comparing the current character of the pattern with the characters before it.

https://leetcode.com/problems/implement-strstr/




'''
# method 1 : brute force approch
# TC     -      
# SC     -     
def computeLPSArray(pattern):
    m = len(pattern)
    lps = [0] * m
    length = 0  # length of the previous longest prefix suffix
    i = 1
    
    while i < m:
        if pattern[i] == pattern[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                length = lps[length - 1]
            else:
                lps[i] = 0
                i += 1
    return lps

def KMPSearch(text, pattern):
    n = len(text)
    m = len(pattern)
    
    # Preprocess the pattern to create the LPS array
    lps = computeLPSArray(pattern)
    
    i = 0  # index for text
    j = 0  # index for pattern
    while i < n:
        if text[i] == pattern[j]:
            i += 1
            j += 1
        
        if j == m:
            print(f"Pattern found at index {i - j}")
            j = lps[j - 1]
        elif i < n and text[i] != pattern[j]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1
text = "ABABDABACDABABCABAB"
pattern = "ABABCABAB"
KMPSearch(text, pattern)

# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 7 TODO : shortest pallindrome
'''
ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´


https://leetcode.com/problems/shortest-palindrome/


'''
# method 1 : brute force approch
''' 

Time Complexity:
Reversing the String: O(n) where n is the length of the string s.
Constructing the LPS Array: O(2n) since we create the combined string (which has length 2n + 1) and calculate the LPS array for this string.
Overall Time Complexity: O(n) because reversing the string and calculating the LPS array both contribute linear time complexity.

Space Complexity:
Space for Reversed String: O(n) for storing the reversed string.
Space for LPS Array: O(n) for storing the LPS array.
Overall Space Complexity: O(n) due to the storage of the reversed string and the LPS array.
Conclusion:
The shortest palindrome problem can be efficiently solved using a KMP-based approach. By using the LPS array to find the longest matching prefix and suffix, we can determine the minimal number of characters that need to be added in front of the string to make it a palindrome. This approach runs in linear time (O(n)) and is very efficient for large strings.



Get smarter responses, upload files and images, and more.

Log in

Sig


'''
def shortestPalindrome(s: str) -> str:
    # Step 1: Reverse the string
    rev_s = s[::-1]
    
    # Step 2: Create a combined string with the original string and the reversed string
    combined = s + "#" + rev_s
    
    # Step 3: Generate the LPS array for the combined string
    lps = computeLPSArray(combined)
    
    # Step 4: The longest prefix which is also a suffix
    longest_prefix_length = lps[-1]  # The last value in the LPS array
    
    # Step 5: The part of the reversed string that does not match the prefix
    add_str = rev_s[:len(s) - longest_prefix_length]
    
    # Step 6: Return the shortest palindrome
    return add_str + s

def computeLPSArray(pattern: str) -> list:
    # Create the LPS array for the pattern string
    m = len(pattern)
    lps = [0] * m
    length = 0  # Length of the previous longest prefix suffix
    i = 1
    
    while i < m:
        if pattern[i] == pattern[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                length = lps[length - 1]
            else:
                lps[i] = 0
                i += 1
    return lps


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 8 TODO : longest happy prefix
'''
ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

- A happy prefix is defined as the longest prefix of the string which is also a suffix but not equal to the whole string itself.

https://leetcode.com/problems/longest-happy-prefix/



'''
# method 1 : brute force approch
''' 
Time Complexity:
Generating the LPS Array:
The time complexity of generating the LPS array is O(n) where n is the length of the string s. This is because we iterate over the string only once.
Overall Time Complexity:
Since the function only makes one pass through the string to build the LPS array and slice the result, the overall time complexity is O(n).

Space Complexity:
LPS Array:
The space complexity is O(n) because we store the LPS array, which has the same length as the input string.
Overall Space Complexity:
The overall space complexity is O(n), where n is the length of the input string, due to the space required for storing the LPS array.

''' 
def longestPrefix(s: str) -> str:
    # Step 1: Generate the LPS (Longest Prefix Suffix) array
    lps = computeLPSArray(s)
    
    # Step 2: The length of the longest prefix which is also a suffix
    longest_prefix_len = lps[-1]
    
    # Step 3: Return the substring that corresponds to the longest prefix
    return s[:longest_prefix_len]

def computeLPSArray(pattern: str) -> list:
    # Step 1: Initialize variables
    n = len(pattern)
    lps = [0] * n
    length = 0  # length of the previous longest prefix suffix
    i = 1
    
    # Step 2: Preprocess the string to generate the LPS array
    while i < n:
        if pattern[i] == pattern[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                length = lps[length - 1]
            else:
                lps[i] = 0
                i += 1
                
    return lps


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# 9 TODO : count pallindromic subsequence in given string
'''
ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

https://practice.geeksforgeeks.org/problems/count-palindromic-subsequences/1#:~:text=Given%20a%20string%20str%20of,formed%20from%20the%20string%20str.&text=Your%20Task%3A,read%20input%20or%20print%20anything.



'''
# method 1 : brute force approch
''' 

Time Complexity:
DP Table Calculation:
We fill a n x n table, where n is the length of the string.
For each cell, the calculation involves constant time operations (basic arithmetic and comparisons).
Therefore, the time complexity is O(n^2).

Space Complexity:
DP Table:
The DP table requires O(n^2) space to store the results.
Hence, the space complexity is O(n^2).

'''
def countPalindromicSubsequences(s: str) -> int:
    n = len(s)
    
    # Create a DP table to store the count of palindromic subsequences
    dp = [[0] * n for _ in range(n)]
    
    # Base case: every single character is a palindrome of length 1
    for i in range(n):
        dp[i][i] = 1
    
    # Fill the DP table for substrings of length 2 to n
    for length in range(2, n + 1):  # length of the substring
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] == s[j]:
                dp[i][j] = dp[i+1][j] + dp[i][j-1] + 1
            else:
                dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]
    
    # Return the number of palindromic subsequences for the entire string
    return dp[0][n-1]

# Example usage:
s = "bccb"
result = countPalindromicSubsequences(s)
print(result)  # Output: 6


# method 2 : better approch
# TC     -      
# SC     -     


# method 3 : optimal solution
# TC     -      
# SC     -      


# endregion

